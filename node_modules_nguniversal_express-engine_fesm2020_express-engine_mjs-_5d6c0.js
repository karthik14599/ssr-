exports.id = "node_modules_nguniversal_express-engine_fesm2020_express-engine_mjs-_5d6c0";
exports.ids = ["node_modules_nguniversal_express-engine_fesm2020_express-engine_mjs-_5d6c0"];
exports.modules = {

/***/ 40579:
/*!*******************************************!*\
  !*** ./node_modules/ansi-styles/index.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


const wrapAnsi16 = (fn, offset) => (...args) => {
  const code = fn(...args);
  return `\u001B[${code + offset}m`;
};
const wrapAnsi256 = (fn, offset) => (...args) => {
  const code = fn(...args);
  return `\u001B[${38 + offset};5;${code}m`;
};
const wrapAnsi16m = (fn, offset) => (...args) => {
  const rgb = fn(...args);
  return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};
const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];
const setLazyProperty = (object, property, get) => {
  Object.defineProperty(object, property, {
    get: () => {
      const value = get();
      Object.defineProperty(object, property, {
        value,
        enumerable: true,
        configurable: true
      });
      return value;
    },
    enumerable: true,
    configurable: true
  });
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
  if (colorConvert === undefined) {
    colorConvert = __webpack_require__(/*! color-convert */ 24974);
  }
  const offset = isBackground ? 10 : 0;
  const styles = {};
  for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
    const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
    if (sourceSpace === targetSpace) {
      styles[name] = wrap(identity, offset);
    } else if (typeof suite === 'object') {
      styles[name] = wrap(suite[targetSpace], offset);
    }
  }
  return styles;
};
function assembleStyles() {
  const codes = new Map();
  const styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };

  // Alias bright black as gray (and grey)
  styles.color.gray = styles.color.blackBright;
  styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
  styles.color.grey = styles.color.blackBright;
  styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\u001B[${style[0]}m`,
        close: `\u001B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, 'codes', {
    value: codes,
    enumerable: false
  });
  styles.color.close = '\u001B[39m';
  styles.bgColor.close = '\u001B[49m';
  setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
  setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
  setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
  setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
  setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
  setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));
  return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
  enumerable: true,
  get: assembleStyles
});

/***/ }),

/***/ 37424:
/*!****************************************!*\
  !*** ./node_modules/boolbase/index.js ***!
  \****************************************/
/***/ (function(module) {

module.exports = {
  trueFunc: function trueFunc() {
    return true;
  },
  falseFunc: function falseFunc() {
    return false;
  }
};

/***/ }),

/***/ 33168:
/*!********************************************!*\
  !*** ./node_modules/chalk/source/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const ansiStyles = __webpack_require__(/*! ansi-styles */ 40579);
const {
  stdout: stdoutColor,
  stderr: stderrColor
} = __webpack_require__(/*! supports-color */ 76583);
const {
  stringReplaceAll,
  stringEncaseCRLFWithFirstIndex
} = __webpack_require__(/*! ./util */ 65722);
const {
  isArray
} = Array;

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  }

  // Detect level if not set manually
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
class ChalkClass {
  constructor(options) {
    // eslint-disable-next-line no-constructor-return
    return chalkFactory(options);
  }
}
const chalkFactory = options => {
  const chalk = {};
  applyOptions(chalk, options);
  chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);
  Object.setPrototypeOf(chalk, Chalk.prototype);
  Object.setPrototypeOf(chalk.template, chalk);
  chalk.template.constructor = () => {
    throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
  };
  chalk.template.Instance = ChalkClass;
  return chalk.template;
};
function Chalk(options) {
  return chalkFactory(options);
}
for (const [styleName, style] of Object.entries(ansiStyles)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, {
        value: builder
      });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this._styler, true);
    Object.defineProperty(this, 'visible', {
      value: builder
    });
    return builder;
  }
};
const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const {
        level
      } = this;
      return function (...arguments_) {
        const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
for (const model of usedModels) {
  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const {
        level
      } = this;
      return function (...arguments_) {
        const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
        return createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
const proto = Object.defineProperties(() => {}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    }
  }
});
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
      // Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
      return applyStyle(builder, chalkTag(builder, ...arguments_));
    }

    // Single argument is hot path, implicit coercion is faster than anything
    // eslint-disable-next-line no-implicit-coercion
    return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
  };

  // We alter the prototype because we must return a function, but there is
  // no way to create a function with a different prototype
  Object.setPrototypeOf(builder, proto);
  builder._generator = self;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self._isEmpty ? '' : string;
  }
  let styler = self._styler;
  if (styler === undefined) {
    return string;
  }
  const {
    openAll,
    closeAll
  } = styler;
  if (string.indexOf('\u001B') !== -1) {
    while (styler !== undefined) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }

  // We can move both next actions out of loop, because remaining actions in loop won't have
  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
  const lfIndex = string.indexOf('\n');
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
let template;
const chalkTag = (chalk, ...strings) => {
  const [firstString] = strings;
  if (!isArray(firstString) || !isArray(firstString.raw)) {
    // If chalk() was called by itself or with a string,
    // return the string itself as a string.
    return strings.join(' ');
  }
  const arguments_ = strings.slice(1);
  const parts = [firstString.raw[0]];
  for (let i = 1; i < firstString.length; i++) {
    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'), String(firstString.raw[i]));
  }
  if (template === undefined) {
    template = __webpack_require__(/*! ./templates */ 29119);
  }
  return template(chalk, parts.join(''));
};
Object.defineProperties(Chalk.prototype, styles);
const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({
  level: stderrColor ? stderrColor.level : 0
}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;
module.exports = chalk;

/***/ }),

/***/ 29119:
/*!************************************************!*\
  !*** ./node_modules/chalk/source/templates.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";


const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
const ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', '\u001B'], ['a', '\u0007']]);
function unescape(c) {
  const u = c[0] === 'u';
  const bracket = c[1] === '{';
  if (u && !bracket && c.length === 5 || c[0] === 'x' && c.length === 3) {
    return String.fromCharCode(parseInt(c.slice(1), 16));
  }
  if (u && bracket) {
    return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
  }
  return ESCAPES.get(c) || c;
}
function parseArguments(name, arguments_) {
  const results = [];
  const chunks = arguments_.trim().split(/\s*,\s*/g);
  let matches;
  for (const chunk of chunks) {
    const number = Number(chunk);
    if (!Number.isNaN(number)) {
      results.push(number);
    } else if (matches = chunk.match(STRING_REGEX)) {
      results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
    } else {
      throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
  }
  return results;
}
function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;
  const results = [];
  let matches;
  while ((matches = STYLE_REGEX.exec(style)) !== null) {
    const name = matches[1];
    if (matches[2]) {
      const args = parseArguments(name, matches[2]);
      results.push([name].concat(args));
    } else {
      results.push([name]);
    }
  }
  return results;
}
function buildStyle(chalk, styles) {
  const enabled = {};
  for (const layer of styles) {
    for (const style of layer.styles) {
      enabled[style[0]] = layer.inverse ? null : style.slice(1);
    }
  }
  let current = chalk;
  for (const [styleName, styles] of Object.entries(enabled)) {
    if (!Array.isArray(styles)) {
      continue;
    }
    if (!(styleName in current)) {
      throw new Error(`Unknown Chalk style: ${styleName}`);
    }
    current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
  }
  return current;
}
module.exports = (chalk, temporary) => {
  const styles = [];
  const chunks = [];
  let chunk = [];

  // eslint-disable-next-line max-params
  temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
    if (escapeCharacter) {
      chunk.push(unescape(escapeCharacter));
    } else if (style) {
      const string = chunk.join('');
      chunk = [];
      chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
      styles.push({
        inverse,
        styles: parseStyle(style)
      });
    } else if (close) {
      if (styles.length === 0) {
        throw new Error('Found extraneous } in Chalk template literal');
      }
      chunks.push(buildStyle(chalk, styles)(chunk.join('')));
      chunk = [];
      styles.pop();
    } else {
      chunk.push(character);
    }
  });
  chunks.push(chunk.join(''));
  if (styles.length > 0) {
    const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
    throw new Error(errMessage);
  }
  return chunks.join('');
};

/***/ }),

/***/ 65722:
/*!*******************************************!*\
  !*** ./node_modules/chalk/source/util.js ***!
  \*******************************************/
/***/ (function(module) {

"use strict";


const stringReplaceAll = (string, substring, replacer) => {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = '';
  do {
    returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = '';
  do {
    const gotCR = string[index - 1] === '\r';
    returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
    endIndex = index + 1;
    index = string.indexOf('\n', endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
module.exports = {
  stringReplaceAll,
  stringEncaseCRLFWithFirstIndex
};

/***/ }),

/***/ 36619:
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = __webpack_require__(/*! color-name */ 50684);

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
  reverseKeywords[cssKeywords[key]] = key;
}
const convert = {
  rgb: {
    channels: 3,
    labels: 'rgb'
  },
  hsl: {
    channels: 3,
    labels: 'hsl'
  },
  hsv: {
    channels: 3,
    labels: 'hsv'
  },
  hwb: {
    channels: 3,
    labels: 'hwb'
  },
  cmyk: {
    channels: 4,
    labels: 'cmyk'
  },
  xyz: {
    channels: 3,
    labels: 'xyz'
  },
  lab: {
    channels: 3,
    labels: 'lab'
  },
  lch: {
    channels: 3,
    labels: 'lch'
  },
  hex: {
    channels: 1,
    labels: ['hex']
  },
  keyword: {
    channels: 1,
    labels: ['keyword']
  },
  ansi16: {
    channels: 1,
    labels: ['ansi16']
  },
  ansi256: {
    channels: 1,
    labels: ['ansi256']
  },
  hcg: {
    channels: 3,
    labels: ['h', 'c', 'g']
  },
  apple: {
    channels: 3,
    labels: ['r16', 'g16', 'b16']
  },
  gray: {
    channels: 1,
    labels: ['gray']
  }
};
module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
  if (!('channels' in convert[model])) {
    throw new Error('missing channels property: ' + model);
  }
  if (!('labels' in convert[model])) {
    throw new Error('missing channel labels property: ' + model);
  }
  if (convert[model].labels.length !== convert[model].channels) {
    throw new Error('channel and label counts mismatch: ' + model);
  }
  const {
    channels,
    labels
  } = convert[model];
  delete convert[model].channels;
  delete convert[model].labels;
  Object.defineProperty(convert[model], 'channels', {
    value: channels
  });
  Object.defineProperty(convert[model], 'labels', {
    value: labels
  });
}
convert.rgb.hsl = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  const delta = max - min;
  let h;
  let s;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  const l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  return [h, s * 100, l * 100];
};
convert.rgb.hsv = function (rgb) {
  let rdif;
  let gdif;
  let bdif;
  let h;
  let s;
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const v = Math.max(r, g, b);
  const diff = v - Math.min(r, g, b);
  const diffc = function (c) {
    return (v - c) / 6 / diff + 1 / 2;
  };
  if (diff === 0) {
    h = 0;
    s = 0;
  } else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);
    if (r === v) {
      h = bdif - gdif;
    } else if (g === v) {
      h = 1 / 3 + rdif - bdif;
    } else if (b === v) {
      h = 2 / 3 + gdif - rdif;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return [h * 360, s * 100, v * 100];
};
convert.rgb.hwb = function (rgb) {
  const r = rgb[0];
  const g = rgb[1];
  let b = rgb[2];
  const h = convert.rgb.hsl(rgb)[0];
  const w = 1 / 255 * Math.min(r, Math.min(g, b));
  b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
  return [h, w * 100, b * 100];
};
convert.rgb.cmyk = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const k = Math.min(1 - r, 1 - g, 1 - b);
  const c = (1 - r - k) / (1 - k) || 0;
  const m = (1 - g - k) / (1 - k) || 0;
  const y = (1 - b - k) / (1 - k) || 0;
  return [c * 100, m * 100, y * 100, k * 100];
};
function comparativeDistance(x, y) {
  /*
  	See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
  */
  return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
}
convert.rgb.keyword = function (rgb) {
  const reversed = reverseKeywords[rgb];
  if (reversed) {
    return reversed;
  }
  let currentClosestDistance = Infinity;
  let currentClosestKeyword;
  for (const keyword of Object.keys(cssKeywords)) {
    const value = cssKeywords[keyword];

    // Compute comparative distance
    const distance = comparativeDistance(rgb, value);

    // Check if its less, if so set as closest
    if (distance < currentClosestDistance) {
      currentClosestDistance = distance;
      currentClosestKeyword = keyword;
    }
  }
  return currentClosestKeyword;
};
convert.keyword.rgb = function (keyword) {
  return cssKeywords[keyword];
};
convert.rgb.xyz = function (rgb) {
  let r = rgb[0] / 255;
  let g = rgb[1] / 255;
  let b = rgb[2] / 255;

  // Assume sRGB
  r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
  g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
  b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
  const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  return [x * 100, y * 100, z * 100];
};
convert.rgb.lab = function (rgb) {
  const xyz = convert.rgb.xyz(rgb);
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};
convert.hsl.rgb = function (hsl) {
  const h = hsl[0] / 360;
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  let t2;
  let t3;
  let val;
  if (s === 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5) {
    t2 = l * (1 + s);
  } else {
    t2 = l + s - l * s;
  }
  const t1 = 2 * l - t2;
  const rgb = [0, 0, 0];
  for (let i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);
    if (t3 < 0) {
      t3++;
    }
    if (t3 > 1) {
      t3--;
    }
    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3;
    } else if (2 * t3 < 1) {
      val = t2;
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    } else {
      val = t1;
    }
    rgb[i] = val * 255;
  }
  return rgb;
};
convert.hsl.hsv = function (hsl) {
  const h = hsl[0];
  let s = hsl[1] / 100;
  let l = hsl[2] / 100;
  let smin = s;
  const lmin = Math.max(l, 0.01);
  l *= 2;
  s *= l <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  const v = (l + s) / 2;
  const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
  return [h, sv * 100, v * 100];
};
convert.hsv.rgb = function (hsv) {
  const h = hsv[0] / 60;
  const s = hsv[1] / 100;
  let v = hsv[2] / 100;
  const hi = Math.floor(h) % 6;
  const f = h - Math.floor(h);
  const p = 255 * v * (1 - s);
  const q = 255 * v * (1 - s * f);
  const t = 255 * v * (1 - s * (1 - f));
  v *= 255;
  switch (hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
};
convert.hsv.hsl = function (hsv) {
  const h = hsv[0];
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const vmin = Math.max(v, 0.01);
  let sl;
  let l;
  l = (2 - s) * v;
  const lmin = (2 - s) * vmin;
  sl = s * vmin;
  sl /= lmin <= 1 ? lmin : 2 - lmin;
  sl = sl || 0;
  l /= 2;
  return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
  const h = hwb[0] / 360;
  let wh = hwb[1] / 100;
  let bl = hwb[2] / 100;
  const ratio = wh + bl;
  let f;

  // Wh + bl cant be > 1
  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }
  const i = Math.floor(6 * h);
  const v = 1 - bl;
  f = 6 * h - i;
  if ((i & 0x01) !== 0) {
    f = 1 - f;
  }
  const n = wh + f * (v - wh); // Linear interpolation

  let r;
  let g;
  let b;
  /* eslint-disable max-statements-per-line,no-multi-spaces */
  switch (i) {
    default:
    case 6:
    case 0:
      r = v;
      g = n;
      b = wh;
      break;
    case 1:
      r = n;
      g = v;
      b = wh;
      break;
    case 2:
      r = wh;
      g = v;
      b = n;
      break;
    case 3:
      r = wh;
      g = n;
      b = v;
      break;
    case 4:
      r = n;
      g = wh;
      b = v;
      break;
    case 5:
      r = v;
      g = wh;
      b = n;
      break;
  }
  /* eslint-enable max-statements-per-line,no-multi-spaces */

  return [r * 255, g * 255, b * 255];
};
convert.cmyk.rgb = function (cmyk) {
  const c = cmyk[0] / 100;
  const m = cmyk[1] / 100;
  const y = cmyk[2] / 100;
  const k = cmyk[3] / 100;
  const r = 1 - Math.min(1, c * (1 - k) + k);
  const g = 1 - Math.min(1, m * (1 - k) + k);
  const b = 1 - Math.min(1, y * (1 - k) + k);
  return [r * 255, g * 255, b * 255];
};
convert.xyz.rgb = function (xyz) {
  const x = xyz[0] / 100;
  const y = xyz[1] / 100;
  const z = xyz[2] / 100;
  let r;
  let g;
  let b;
  r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  b = x * 0.0557 + y * -0.2040 + z * 1.0570;

  // Assume sRGB
  r = r > 0.0031308 ? 1.055 * r ** (1.0 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * g ** (1.0 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * b ** (1.0 / 2.4) - 0.055 : b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};
convert.xyz.lab = function (xyz) {
  let x = xyz[0];
  let y = xyz[1];
  let z = xyz[2];
  x /= 95.047;
  y /= 100;
  z /= 108.883;
  x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
  const l = 116 * y - 16;
  const a = 500 * (x - y);
  const b = 200 * (y - z);
  return [l, a, b];
};
convert.lab.xyz = function (lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let x;
  let y;
  let z;
  y = (l + 16) / 116;
  x = a / 500 + y;
  z = y - b / 200;
  const y2 = y ** 3;
  const x2 = x ** 3;
  const z2 = z ** 3;
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
  x *= 95.047;
  y *= 100;
  z *= 108.883;
  return [x, y, z];
};
convert.lab.lch = function (lab) {
  const l = lab[0];
  const a = lab[1];
  const b = lab[2];
  let h;
  const hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  const c = Math.sqrt(a * a + b * b);
  return [l, c, h];
};
convert.lch.lab = function (lch) {
  const l = lch[0];
  const c = lch[1];
  const h = lch[2];
  const hr = h / 360 * 2 * Math.PI;
  const a = c * Math.cos(hr);
  const b = c * Math.sin(hr);
  return [l, a, b];
};
convert.rgb.ansi16 = function (args, saturation = null) {
  const [r, g, b] = args;
  let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

  value = Math.round(value / 50);
  if (value === 0) {
    return 30;
  }
  let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
  if (value === 2) {
    ansi += 60;
  }
  return ansi;
};
convert.hsv.ansi16 = function (args) {
  // Optimization here; we already know the value and don't need to get
  // it converted for us.
  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};
convert.rgb.ansi256 = function (args) {
  const r = args[0];
  const g = args[1];
  const b = args[2];

  // We use the extended greyscale palette here, with the exception of
  // black and white. normal palette only has 4 greyscale shades.
  if (r === g && g === b) {
    if (r < 8) {
      return 16;
    }
    if (r > 248) {
      return 231;
    }
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
};
convert.ansi16.rgb = function (args) {
  let color = args % 10;

  // Handle greyscale
  if (color === 0 || color === 7) {
    if (args > 50) {
      color += 3.5;
    }
    color = color / 10.5 * 255;
    return [color, color, color];
  }
  const mult = (~~(args > 50) + 1) * 0.5;
  const r = (color & 1) * mult * 255;
  const g = (color >> 1 & 1) * mult * 255;
  const b = (color >> 2 & 1) * mult * 255;
  return [r, g, b];
};
convert.ansi256.rgb = function (args) {
  // Handle greyscale
  if (args >= 232) {
    const c = (args - 232) * 10 + 8;
    return [c, c, c];
  }
  args -= 16;
  let rem;
  const r = Math.floor(args / 36) / 5 * 255;
  const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
  const b = rem % 6 / 5 * 255;
  return [r, g, b];
};
convert.rgb.hex = function (args) {
  const integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
  const string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};
convert.hex.rgb = function (args) {
  const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) {
    return [0, 0, 0];
  }
  let colorString = match[0];
  if (match[0].length === 3) {
    colorString = colorString.split('').map(char => {
      return char + char;
    }).join('');
  }
  const integer = parseInt(colorString, 16);
  const r = integer >> 16 & 0xFF;
  const g = integer >> 8 & 0xFF;
  const b = integer & 0xFF;
  return [r, g, b];
};
convert.rgb.hcg = function (rgb) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max = Math.max(Math.max(r, g), b);
  const min = Math.min(Math.min(r, g), b);
  const chroma = max - min;
  let grayscale;
  let hue;
  if (chroma < 1) {
    grayscale = min / (1 - chroma);
  } else {
    grayscale = 0;
  }
  if (chroma <= 0) {
    hue = 0;
  } else if (max === r) {
    hue = (g - b) / chroma % 6;
  } else if (max === g) {
    hue = 2 + (b - r) / chroma;
  } else {
    hue = 4 + (r - g) / chroma;
  }
  hue /= 6;
  hue %= 1;
  return [hue * 360, chroma * 100, grayscale * 100];
};
convert.hsl.hcg = function (hsl) {
  const s = hsl[1] / 100;
  const l = hsl[2] / 100;
  const c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
  let f = 0;
  if (c < 1.0) {
    f = (l - 0.5 * c) / (1.0 - c);
  }
  return [hsl[0], c * 100, f * 100];
};
convert.hsv.hcg = function (hsv) {
  const s = hsv[1] / 100;
  const v = hsv[2] / 100;
  const c = s * v;
  let f = 0;
  if (c < 1.0) {
    f = (v - c) / (1 - c);
  }
  return [hsv[0], c * 100, f * 100];
};
convert.hcg.rgb = function (hcg) {
  const h = hcg[0] / 360;
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  if (c === 0.0) {
    return [g * 255, g * 255, g * 255];
  }
  const pure = [0, 0, 0];
  const hi = h % 1 * 6;
  const v = hi % 1;
  const w = 1 - v;
  let mg = 0;

  /* eslint-disable max-statements-per-line */
  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1;
      pure[1] = v;
      pure[2] = 0;
      break;
    case 1:
      pure[0] = w;
      pure[1] = 1;
      pure[2] = 0;
      break;
    case 2:
      pure[0] = 0;
      pure[1] = 1;
      pure[2] = v;
      break;
    case 3:
      pure[0] = 0;
      pure[1] = w;
      pure[2] = 1;
      break;
    case 4:
      pure[0] = v;
      pure[1] = 0;
      pure[2] = 1;
      break;
    default:
      pure[0] = 1;
      pure[1] = 0;
      pure[2] = w;
  }
  /* eslint-enable max-statements-per-line */

  mg = (1.0 - c) * g;
  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
};
convert.hcg.hsv = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1.0 - c);
  let f = 0;
  if (v > 0.0) {
    f = c / v;
  }
  return [hcg[0], f * 100, v * 100];
};
convert.hcg.hsl = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const l = g * (1.0 - c) + 0.5 * c;
  let s = 0;
  if (l > 0.0 && l < 0.5) {
    s = c / (2 * l);
  } else if (l >= 0.5 && l < 1.0) {
    s = c / (2 * (1 - l));
  }
  return [hcg[0], s * 100, l * 100];
};
convert.hcg.hwb = function (hcg) {
  const c = hcg[1] / 100;
  const g = hcg[2] / 100;
  const v = c + g * (1.0 - c);
  return [hcg[0], (v - c) * 100, (1 - v) * 100];
};
convert.hwb.hcg = function (hwb) {
  const w = hwb[1] / 100;
  const b = hwb[2] / 100;
  const v = 1 - b;
  const c = v - w;
  let g = 0;
  if (c < 1) {
    g = (v - c) / (1 - c);
  }
  return [hwb[0], c * 100, g * 100];
};
convert.apple.rgb = function (apple) {
  return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
};
convert.rgb.apple = function (rgb) {
  return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
};
convert.gray.rgb = function (args) {
  return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};
convert.gray.hsl = function (args) {
  return [0, 0, args[0]];
};
convert.gray.hsv = convert.gray.hsl;
convert.gray.hwb = function (gray) {
  return [0, 100, gray[0]];
};
convert.gray.cmyk = function (gray) {
  return [0, 0, 0, gray[0]];
};
convert.gray.lab = function (gray) {
  return [gray[0], 0, 0];
};
convert.gray.hex = function (gray) {
  const val = Math.round(gray[0] / 100 * 255) & 0xFF;
  const integer = (val << 16) + (val << 8) + val;
  const string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};
convert.rgb.gray = function (rgb) {
  const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
  return [val / 255 * 100];
};

/***/ }),

/***/ 24974:
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const conversions = __webpack_require__(/*! ./conversions */ 36619);
const route = __webpack_require__(/*! ./route */ 39003);
const convert = {};
const models = Object.keys(conversions);
function wrapRaw(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];
    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    return fn(args);
  };

  // Preserve .conversion property if there is one
  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
function wrapRounded(fn) {
  const wrappedFn = function (...args) {
    const arg0 = args[0];
    if (arg0 === undefined || arg0 === null) {
      return arg0;
    }
    if (arg0.length > 1) {
      args = arg0;
    }
    const result = fn(args);

    // We're assuming the result is an array here.
    // see notice in conversions.js; don't use box types
    // in conversion functions.
    if (typeof result === 'object') {
      for (let len = result.length, i = 0; i < len; i++) {
        result[i] = Math.round(result[i]);
      }
    }
    return result;
  };

  // Preserve .conversion property if there is one
  if ('conversion' in fn) {
    wrappedFn.conversion = fn.conversion;
  }
  return wrappedFn;
}
models.forEach(fromModel => {
  convert[fromModel] = {};
  Object.defineProperty(convert[fromModel], 'channels', {
    value: conversions[fromModel].channels
  });
  Object.defineProperty(convert[fromModel], 'labels', {
    value: conversions[fromModel].labels
  });
  const routes = route(fromModel);
  const routeModels = Object.keys(routes);
  routeModels.forEach(toModel => {
    const fn = routes[toModel];
    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});
module.exports = convert;

/***/ }),

/***/ 39003:
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const conversions = __webpack_require__(/*! ./conversions */ 36619);

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
  const graph = {};
  // https://jsperf.com/object-keys-vs-for-in-with-closure/3
  const models = Object.keys(conversions);
  for (let len = models.length, i = 0; i < len; i++) {
    graph[models[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  }
  return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
  const graph = buildGraph();
  const queue = [fromModel]; // Unshift -> queue -> pop

  graph[fromModel].distance = 0;
  while (queue.length) {
    const current = queue.pop();
    const adjacents = Object.keys(conversions[current]);
    for (let len = adjacents.length, i = 0; i < len; i++) {
      const adjacent = adjacents[i];
      const node = graph[adjacent];
      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }
  return graph;
}
function link(from, to) {
  return function (args) {
    return to(from(args));
  };
}
function wrapConversion(toModel, graph) {
  const path = [graph[toModel].parent, toModel];
  let fn = conversions[graph[toModel].parent][toModel];
  let cur = graph[toModel].parent;
  while (graph[cur].parent) {
    path.unshift(graph[cur].parent);
    fn = link(conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }
  fn.conversion = path;
  return fn;
}
module.exports = function (fromModel) {
  const graph = deriveBFS(fromModel);
  const conversion = {};
  const models = Object.keys(graph);
  for (let len = models.length, i = 0; i < len; i++) {
    const toModel = models[i];
    const node = graph[toModel];
    if (node.parent === null) {
      // No possible conversion, or this node is the source model.
      continue;
    }
    conversion[toModel] = wrapConversion(toModel, graph);
  }
  return conversion;
};

/***/ }),

/***/ 50684:
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/***/ (function(module) {

"use strict";


module.exports = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};

/***/ }),

/***/ 29059:
/*!*********************************!*\
  !*** parse5/lib/common/doctype ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


const {
  DOCUMENT_MODE
} = __webpack_require__(/*! ./html */ 39604);

//Const
const VALID_DOCTYPE_NAME = 'html';
const VALID_SYSTEM_ID = 'about:legacy-compat';
const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
const QUIRKS_MODE_PUBLIC_ID_PREFIXES = ['+//silmaril//dtd html pro v0r11 19970101//', '-//as//dtd html 3.0 aswedit + extensions//', '-//advasoft ltd//dtd html 3.0 aswedit + extensions//', '-//ietf//dtd html 2.0 level 1//', '-//ietf//dtd html 2.0 level 2//', '-//ietf//dtd html 2.0 strict level 1//', '-//ietf//dtd html 2.0 strict level 2//', '-//ietf//dtd html 2.0 strict//', '-//ietf//dtd html 2.0//', '-//ietf//dtd html 2.1e//', '-//ietf//dtd html 3.0//', '-//ietf//dtd html 3.2 final//', '-//ietf//dtd html 3.2//', '-//ietf//dtd html 3//', '-//ietf//dtd html level 0//', '-//ietf//dtd html level 1//', '-//ietf//dtd html level 2//', '-//ietf//dtd html level 3//', '-//ietf//dtd html strict level 0//', '-//ietf//dtd html strict level 1//', '-//ietf//dtd html strict level 2//', '-//ietf//dtd html strict level 3//', '-//ietf//dtd html strict//', '-//ietf//dtd html//', '-//metrius//dtd metrius presentational//', '-//microsoft//dtd internet explorer 2.0 html strict//', '-//microsoft//dtd internet explorer 2.0 html//', '-//microsoft//dtd internet explorer 2.0 tables//', '-//microsoft//dtd internet explorer 3.0 html strict//', '-//microsoft//dtd internet explorer 3.0 html//', '-//microsoft//dtd internet explorer 3.0 tables//', '-//netscape comm. corp.//dtd html//', '-//netscape comm. corp.//dtd strict html//', "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", '-//sq//dtd html 2.0 hotmetal + extensions//', '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//', '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//', '-//spyglass//dtd html 2.0 extended//', '-//sun microsystems corp.//dtd hotjava html//', '-//sun microsystems corp.//dtd hotjava strict html//', '-//w3c//dtd html 3 1995-03-24//', '-//w3c//dtd html 3.2 draft//', '-//w3c//dtd html 3.2 final//', '-//w3c//dtd html 3.2//', '-//w3c//dtd html 3.2s draft//', '-//w3c//dtd html 4.0 frameset//', '-//w3c//dtd html 4.0 transitional//', '-//w3c//dtd html experimental 19960712//', '-//w3c//dtd html experimental 970421//', '-//w3c//dtd w3 html//', '-//w3o//dtd w3 html 3.0//', '-//webtechs//dtd mozilla html 2.0//', '-//webtechs//dtd mozilla html//'];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat(['-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']);
const QUIRKS_MODE_PUBLIC_IDS = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'];
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat(['-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']);

//Utils
function enquoteDoctypeId(id) {
  const quote = id.indexOf('"') !== -1 ? "'" : '"';
  return quote + id + quote;
}
function hasPrefix(publicId, prefixes) {
  for (let i = 0; i < prefixes.length; i++) {
    if (publicId.indexOf(prefixes[i]) === 0) {
      return true;
    }
  }
  return false;
}

//API
exports.isConforming = function (token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
};
exports.getDocumentMode = function (token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const systemId = token.systemId;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let publicId = token.publicId;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
};
exports.serializeContent = function (name, publicId, systemId) {
  let str = '!DOCTYPE ';
  if (name) {
    str += name;
  }
  if (publicId) {
    str += ' PUBLIC ' + enquoteDoctypeId(publicId);
  } else if (systemId) {
    str += ' SYSTEM';
  }
  if (systemId !== null) {
    str += ' ' + enquoteDoctypeId(systemId);
  }
  return str;
};

/***/ }),

/***/ 63136:
/*!*****************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/common/error-codes.js ***!
  \*****************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = {
  controlCharacterInInputStream: 'control-character-in-input-stream',
  noncharacterInInputStream: 'noncharacter-in-input-stream',
  surrogateInInputStream: 'surrogate-in-input-stream',
  nonVoidHtmlElementStartTagWithTrailingSolidus: 'non-void-html-element-start-tag-with-trailing-solidus',
  endTagWithAttributes: 'end-tag-with-attributes',
  endTagWithTrailingSolidus: 'end-tag-with-trailing-solidus',
  unexpectedSolidusInTag: 'unexpected-solidus-in-tag',
  unexpectedNullCharacter: 'unexpected-null-character',
  unexpectedQuestionMarkInsteadOfTagName: 'unexpected-question-mark-instead-of-tag-name',
  invalidFirstCharacterOfTagName: 'invalid-first-character-of-tag-name',
  unexpectedEqualsSignBeforeAttributeName: 'unexpected-equals-sign-before-attribute-name',
  missingEndTagName: 'missing-end-tag-name',
  unexpectedCharacterInAttributeName: 'unexpected-character-in-attribute-name',
  unknownNamedCharacterReference: 'unknown-named-character-reference',
  missingSemicolonAfterCharacterReference: 'missing-semicolon-after-character-reference',
  unexpectedCharacterAfterDoctypeSystemIdentifier: 'unexpected-character-after-doctype-system-identifier',
  unexpectedCharacterInUnquotedAttributeValue: 'unexpected-character-in-unquoted-attribute-value',
  eofBeforeTagName: 'eof-before-tag-name',
  eofInTag: 'eof-in-tag',
  missingAttributeValue: 'missing-attribute-value',
  missingWhitespaceBetweenAttributes: 'missing-whitespace-between-attributes',
  missingWhitespaceAfterDoctypePublicKeyword: 'missing-whitespace-after-doctype-public-keyword',
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: 'missing-whitespace-between-doctype-public-and-system-identifiers',
  missingWhitespaceAfterDoctypeSystemKeyword: 'missing-whitespace-after-doctype-system-keyword',
  missingQuoteBeforeDoctypePublicIdentifier: 'missing-quote-before-doctype-public-identifier',
  missingQuoteBeforeDoctypeSystemIdentifier: 'missing-quote-before-doctype-system-identifier',
  missingDoctypePublicIdentifier: 'missing-doctype-public-identifier',
  missingDoctypeSystemIdentifier: 'missing-doctype-system-identifier',
  abruptDoctypePublicIdentifier: 'abrupt-doctype-public-identifier',
  abruptDoctypeSystemIdentifier: 'abrupt-doctype-system-identifier',
  cdataInHtmlContent: 'cdata-in-html-content',
  incorrectlyOpenedComment: 'incorrectly-opened-comment',
  eofInScriptHtmlCommentLikeText: 'eof-in-script-html-comment-like-text',
  eofInDoctype: 'eof-in-doctype',
  nestedComment: 'nested-comment',
  abruptClosingOfEmptyComment: 'abrupt-closing-of-empty-comment',
  eofInComment: 'eof-in-comment',
  incorrectlyClosedComment: 'incorrectly-closed-comment',
  eofInCdata: 'eof-in-cdata',
  absenceOfDigitsInNumericCharacterReference: 'absence-of-digits-in-numeric-character-reference',
  nullCharacterReference: 'null-character-reference',
  surrogateCharacterReference: 'surrogate-character-reference',
  characterReferenceOutsideUnicodeRange: 'character-reference-outside-unicode-range',
  controlCharacterReference: 'control-character-reference',
  noncharacterCharacterReference: 'noncharacter-character-reference',
  missingWhitespaceBeforeDoctypeName: 'missing-whitespace-before-doctype-name',
  missingDoctypeName: 'missing-doctype-name',
  invalidCharacterSequenceAfterDoctypeName: 'invalid-character-sequence-after-doctype-name',
  duplicateAttribute: 'duplicate-attribute',
  nonConformingDoctype: 'non-conforming-doctype',
  missingDoctype: 'missing-doctype',
  misplacedDoctype: 'misplaced-doctype',
  endTagWithoutMatchingOpenElement: 'end-tag-without-matching-open-element',
  closingOfElementWithOpenChildElements: 'closing-of-element-with-open-child-elements',
  disallowedContentInNoscriptInHead: 'disallowed-content-in-noscript-in-head',
  openElementsLeftAfterEof: 'open-elements-left-after-eof',
  abandonedHeadElementChild: 'abandoned-head-element-child',
  misplacedStartTagForHeadElement: 'misplaced-start-tag-for-head-element',
  nestedNoscriptInHead: 'nested-noscript-in-head',
  eofInElementThatCanContainOnlyText: 'eof-in-element-that-can-contain-only-text'
};

/***/ }),

/***/ 17189:
/*!*********************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/common/foreign-content.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


const Tokenizer = __webpack_require__(/*! ../tokenizer */ 9285);
const HTML = __webpack_require__(/*! ./html */ 39604);

//Aliases
const $ = HTML.TAG_NAMES;
const NS = HTML.NAMESPACES;
const ATTRS = HTML.ATTRS;

//MIME types
const MIME_TYPES = {
  TEXT_HTML: 'text/html',
  APPLICATION_XML: 'application/xhtml+xml'
};

//Attributes
const DEFINITION_URL_ATTR = 'definitionurl';
const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
const SVG_ATTRS_ADJUSTMENT_MAP = {
  attributename: 'attributeName',
  attributetype: 'attributeType',
  basefrequency: 'baseFrequency',
  baseprofile: 'baseProfile',
  calcmode: 'calcMode',
  clippathunits: 'clipPathUnits',
  diffuseconstant: 'diffuseConstant',
  edgemode: 'edgeMode',
  filterunits: 'filterUnits',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  limitingconeangle: 'limitingConeAngle',
  markerheight: 'markerHeight',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  numoctaves: 'numOctaves',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  refx: 'refX',
  refy: 'refY',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stitchtiles: 'stitchTiles',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textlength: 'textLength',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  xchannelselector: 'xChannelSelector',
  ychannelselector: 'yChannelSelector',
  zoomandpan: 'zoomAndPan'
};
const XML_ATTRS_ADJUSTMENT_MAP = {
  'xlink:actuate': {
    prefix: 'xlink',
    name: 'actuate',
    namespace: NS.XLINK
  },
  'xlink:arcrole': {
    prefix: 'xlink',
    name: 'arcrole',
    namespace: NS.XLINK
  },
  'xlink:href': {
    prefix: 'xlink',
    name: 'href',
    namespace: NS.XLINK
  },
  'xlink:role': {
    prefix: 'xlink',
    name: 'role',
    namespace: NS.XLINK
  },
  'xlink:show': {
    prefix: 'xlink',
    name: 'show',
    namespace: NS.XLINK
  },
  'xlink:title': {
    prefix: 'xlink',
    name: 'title',
    namespace: NS.XLINK
  },
  'xlink:type': {
    prefix: 'xlink',
    name: 'type',
    namespace: NS.XLINK
  },
  'xml:base': {
    prefix: 'xml',
    name: 'base',
    namespace: NS.XML
  },
  'xml:lang': {
    prefix: 'xml',
    name: 'lang',
    namespace: NS.XML
  },
  'xml:space': {
    prefix: 'xml',
    name: 'space',
    namespace: NS.XML
  },
  xmlns: {
    prefix: '',
    name: 'xmlns',
    namespace: NS.XMLNS
  },
  'xmlns:xlink': {
    prefix: 'xmlns',
    name: 'xlink',
    namespace: NS.XMLNS
  }
};

//SVG tag names adjustment map
const SVG_TAG_NAMES_ADJUSTMENT_MAP = exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
  altglyph: 'altGlyph',
  altglyphdef: 'altGlyphDef',
  altglyphitem: 'altGlyphItem',
  animatecolor: 'animateColor',
  animatemotion: 'animateMotion',
  animatetransform: 'animateTransform',
  clippath: 'clipPath',
  feblend: 'feBlend',
  fecolormatrix: 'feColorMatrix',
  fecomponenttransfer: 'feComponentTransfer',
  fecomposite: 'feComposite',
  feconvolvematrix: 'feConvolveMatrix',
  fediffuselighting: 'feDiffuseLighting',
  fedisplacementmap: 'feDisplacementMap',
  fedistantlight: 'feDistantLight',
  feflood: 'feFlood',
  fefunca: 'feFuncA',
  fefuncb: 'feFuncB',
  fefuncg: 'feFuncG',
  fefuncr: 'feFuncR',
  fegaussianblur: 'feGaussianBlur',
  feimage: 'feImage',
  femerge: 'feMerge',
  femergenode: 'feMergeNode',
  femorphology: 'feMorphology',
  feoffset: 'feOffset',
  fepointlight: 'fePointLight',
  fespecularlighting: 'feSpecularLighting',
  fespotlight: 'feSpotLight',
  fetile: 'feTile',
  feturbulence: 'feTurbulence',
  foreignobject: 'foreignObject',
  glyphref: 'glyphRef',
  lineargradient: 'linearGradient',
  radialgradient: 'radialGradient',
  textpath: 'textPath'
};

//Tags that causes exit from foreign content
const EXITS_FOREIGN_CONTENT = {
  [$.B]: true,
  [$.BIG]: true,
  [$.BLOCKQUOTE]: true,
  [$.BODY]: true,
  [$.BR]: true,
  [$.CENTER]: true,
  [$.CODE]: true,
  [$.DD]: true,
  [$.DIV]: true,
  [$.DL]: true,
  [$.DT]: true,
  [$.EM]: true,
  [$.EMBED]: true,
  [$.H1]: true,
  [$.H2]: true,
  [$.H3]: true,
  [$.H4]: true,
  [$.H5]: true,
  [$.H6]: true,
  [$.HEAD]: true,
  [$.HR]: true,
  [$.I]: true,
  [$.IMG]: true,
  [$.LI]: true,
  [$.LISTING]: true,
  [$.MENU]: true,
  [$.META]: true,
  [$.NOBR]: true,
  [$.OL]: true,
  [$.P]: true,
  [$.PRE]: true,
  [$.RUBY]: true,
  [$.S]: true,
  [$.SMALL]: true,
  [$.SPAN]: true,
  [$.STRONG]: true,
  [$.STRIKE]: true,
  [$.SUB]: true,
  [$.SUP]: true,
  [$.TABLE]: true,
  [$.TT]: true,
  [$.U]: true,
  [$.UL]: true,
  [$.VAR]: true
};

//Check exit from foreign content
exports.causesExit = function (startTagToken) {
  const tn = startTagToken.tagName;
  const isFontWithAttrs = tn === $.FONT && (Tokenizer.getTokenAttr(startTagToken, ATTRS.COLOR) !== null || Tokenizer.getTokenAttr(startTagToken, ATTRS.SIZE) !== null || Tokenizer.getTokenAttr(startTagToken, ATTRS.FACE) !== null);
  return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
};

//Token adjustments
exports.adjustTokenMathMLAttrs = function (token) {
  for (let i = 0; i < token.attrs.length; i++) {
    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
};
exports.adjustTokenSVGAttrs = function (token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
    if (adjustedAttrName) {
      token.attrs[i].name = adjustedAttrName;
    }
  }
};
exports.adjustTokenXMLAttrs = function (token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];
    if (adjustedAttrEntry) {
      token.attrs[i].prefix = adjustedAttrEntry.prefix;
      token.attrs[i].name = adjustedAttrEntry.name;
      token.attrs[i].namespace = adjustedAttrEntry.namespace;
    }
  }
};
exports.adjustTokenSVGTagName = function (token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];
  if (adjustedTagName) {
    token.tagName = adjustedTagName;
  }
};

//Integration points
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === NS.MATHML && (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {
    for (let i = 0; i < attrs.length; i++) {
      if (attrs[i].name === ATTRS.ENCODING) {
        const value = attrs[i].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);
}
exports.isIntegrationPoint = function (tn, ns, attrs, foreignNS) {
  if ((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
    return true;
  }
  if ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
    return true;
  }
  return false;
};

/***/ }),

/***/ 39604:
/*!******************************!*\
  !*** parse5/lib/common/html ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


const NS = exports.NAMESPACES = {
  HTML: 'http://www.w3.org/1999/xhtml',
  MATHML: 'http://www.w3.org/1998/Math/MathML',
  SVG: 'http://www.w3.org/2000/svg',
  XLINK: 'http://www.w3.org/1999/xlink',
  XML: 'http://www.w3.org/XML/1998/namespace',
  XMLNS: 'http://www.w3.org/2000/xmlns/'
};
exports.ATTRS = {
  TYPE: 'type',
  ACTION: 'action',
  ENCODING: 'encoding',
  PROMPT: 'prompt',
  NAME: 'name',
  COLOR: 'color',
  FACE: 'face',
  SIZE: 'size'
};
exports.DOCUMENT_MODE = {
  NO_QUIRKS: 'no-quirks',
  QUIRKS: 'quirks',
  LIMITED_QUIRKS: 'limited-quirks'
};
const $ = exports.TAG_NAMES = {
  A: 'a',
  ADDRESS: 'address',
  ANNOTATION_XML: 'annotation-xml',
  APPLET: 'applet',
  AREA: 'area',
  ARTICLE: 'article',
  ASIDE: 'aside',
  B: 'b',
  BASE: 'base',
  BASEFONT: 'basefont',
  BGSOUND: 'bgsound',
  BIG: 'big',
  BLOCKQUOTE: 'blockquote',
  BODY: 'body',
  BR: 'br',
  BUTTON: 'button',
  CAPTION: 'caption',
  CENTER: 'center',
  CODE: 'code',
  COL: 'col',
  COLGROUP: 'colgroup',
  DD: 'dd',
  DESC: 'desc',
  DETAILS: 'details',
  DIALOG: 'dialog',
  DIR: 'dir',
  DIV: 'div',
  DL: 'dl',
  DT: 'dt',
  EM: 'em',
  EMBED: 'embed',
  FIELDSET: 'fieldset',
  FIGCAPTION: 'figcaption',
  FIGURE: 'figure',
  FONT: 'font',
  FOOTER: 'footer',
  FOREIGN_OBJECT: 'foreignObject',
  FORM: 'form',
  FRAME: 'frame',
  FRAMESET: 'frameset',
  H1: 'h1',
  H2: 'h2',
  H3: 'h3',
  H4: 'h4',
  H5: 'h5',
  H6: 'h6',
  HEAD: 'head',
  HEADER: 'header',
  HGROUP: 'hgroup',
  HR: 'hr',
  HTML: 'html',
  I: 'i',
  IMG: 'img',
  IMAGE: 'image',
  INPUT: 'input',
  IFRAME: 'iframe',
  KEYGEN: 'keygen',
  LABEL: 'label',
  LI: 'li',
  LINK: 'link',
  LISTING: 'listing',
  MAIN: 'main',
  MALIGNMARK: 'malignmark',
  MARQUEE: 'marquee',
  MATH: 'math',
  MENU: 'menu',
  META: 'meta',
  MGLYPH: 'mglyph',
  MI: 'mi',
  MO: 'mo',
  MN: 'mn',
  MS: 'ms',
  MTEXT: 'mtext',
  NAV: 'nav',
  NOBR: 'nobr',
  NOFRAMES: 'noframes',
  NOEMBED: 'noembed',
  NOSCRIPT: 'noscript',
  OBJECT: 'object',
  OL: 'ol',
  OPTGROUP: 'optgroup',
  OPTION: 'option',
  P: 'p',
  PARAM: 'param',
  PLAINTEXT: 'plaintext',
  PRE: 'pre',
  RB: 'rb',
  RP: 'rp',
  RT: 'rt',
  RTC: 'rtc',
  RUBY: 'ruby',
  S: 's',
  SCRIPT: 'script',
  SECTION: 'section',
  SELECT: 'select',
  SOURCE: 'source',
  SMALL: 'small',
  SPAN: 'span',
  STRIKE: 'strike',
  STRONG: 'strong',
  STYLE: 'style',
  SUB: 'sub',
  SUMMARY: 'summary',
  SUP: 'sup',
  TABLE: 'table',
  TBODY: 'tbody',
  TEMPLATE: 'template',
  TEXTAREA: 'textarea',
  TFOOT: 'tfoot',
  TD: 'td',
  TH: 'th',
  THEAD: 'thead',
  TITLE: 'title',
  TR: 'tr',
  TRACK: 'track',
  TT: 'tt',
  U: 'u',
  UL: 'ul',
  SVG: 'svg',
  VAR: 'var',
  WBR: 'wbr',
  XMP: 'xmp'
};
exports.SPECIAL_ELEMENTS = {
  [NS.HTML]: {
    [$.ADDRESS]: true,
    [$.APPLET]: true,
    [$.AREA]: true,
    [$.ARTICLE]: true,
    [$.ASIDE]: true,
    [$.BASE]: true,
    [$.BASEFONT]: true,
    [$.BGSOUND]: true,
    [$.BLOCKQUOTE]: true,
    [$.BODY]: true,
    [$.BR]: true,
    [$.BUTTON]: true,
    [$.CAPTION]: true,
    [$.CENTER]: true,
    [$.COL]: true,
    [$.COLGROUP]: true,
    [$.DD]: true,
    [$.DETAILS]: true,
    [$.DIR]: true,
    [$.DIV]: true,
    [$.DL]: true,
    [$.DT]: true,
    [$.EMBED]: true,
    [$.FIELDSET]: true,
    [$.FIGCAPTION]: true,
    [$.FIGURE]: true,
    [$.FOOTER]: true,
    [$.FORM]: true,
    [$.FRAME]: true,
    [$.FRAMESET]: true,
    [$.H1]: true,
    [$.H2]: true,
    [$.H3]: true,
    [$.H4]: true,
    [$.H5]: true,
    [$.H6]: true,
    [$.HEAD]: true,
    [$.HEADER]: true,
    [$.HGROUP]: true,
    [$.HR]: true,
    [$.HTML]: true,
    [$.IFRAME]: true,
    [$.IMG]: true,
    [$.INPUT]: true,
    [$.LI]: true,
    [$.LINK]: true,
    [$.LISTING]: true,
    [$.MAIN]: true,
    [$.MARQUEE]: true,
    [$.MENU]: true,
    [$.META]: true,
    [$.NAV]: true,
    [$.NOEMBED]: true,
    [$.NOFRAMES]: true,
    [$.NOSCRIPT]: true,
    [$.OBJECT]: true,
    [$.OL]: true,
    [$.P]: true,
    [$.PARAM]: true,
    [$.PLAINTEXT]: true,
    [$.PRE]: true,
    [$.SCRIPT]: true,
    [$.SECTION]: true,
    [$.SELECT]: true,
    [$.SOURCE]: true,
    [$.STYLE]: true,
    [$.SUMMARY]: true,
    [$.TABLE]: true,
    [$.TBODY]: true,
    [$.TD]: true,
    [$.TEMPLATE]: true,
    [$.TEXTAREA]: true,
    [$.TFOOT]: true,
    [$.TH]: true,
    [$.THEAD]: true,
    [$.TITLE]: true,
    [$.TR]: true,
    [$.TRACK]: true,
    [$.UL]: true,
    [$.WBR]: true,
    [$.XMP]: true
  },
  [NS.MATHML]: {
    [$.MI]: true,
    [$.MO]: true,
    [$.MN]: true,
    [$.MS]: true,
    [$.MTEXT]: true,
    [$.ANNOTATION_XML]: true
  },
  [NS.SVG]: {
    [$.TITLE]: true,
    [$.FOREIGN_OBJECT]: true,
    [$.DESC]: true
  }
};

/***/ }),

/***/ 84382:
/*!*************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/common/unicode.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


const UNDEFINED_CODE_POINTS = [0xfffe, 0xffff, 0x1fffe, 0x1ffff, 0x2fffe, 0x2ffff, 0x3fffe, 0x3ffff, 0x4fffe, 0x4ffff, 0x5fffe, 0x5ffff, 0x6fffe, 0x6ffff, 0x7fffe, 0x7ffff, 0x8fffe, 0x8ffff, 0x9fffe, 0x9ffff, 0xafffe, 0xaffff, 0xbfffe, 0xbffff, 0xcfffe, 0xcffff, 0xdfffe, 0xdffff, 0xefffe, 0xeffff, 0xffffe, 0xfffff, 0x10fffe, 0x10ffff];
exports.REPLACEMENT_CHARACTER = '\uFFFD';
exports.CODE_POINTS = {
  EOF: -1,
  NULL: 0x00,
  TABULATION: 0x09,
  CARRIAGE_RETURN: 0x0d,
  LINE_FEED: 0x0a,
  FORM_FEED: 0x0c,
  SPACE: 0x20,
  EXCLAMATION_MARK: 0x21,
  QUOTATION_MARK: 0x22,
  NUMBER_SIGN: 0x23,
  AMPERSAND: 0x26,
  APOSTROPHE: 0x27,
  HYPHEN_MINUS: 0x2d,
  SOLIDUS: 0x2f,
  DIGIT_0: 0x30,
  DIGIT_9: 0x39,
  SEMICOLON: 0x3b,
  LESS_THAN_SIGN: 0x3c,
  EQUALS_SIGN: 0x3d,
  GREATER_THAN_SIGN: 0x3e,
  QUESTION_MARK: 0x3f,
  LATIN_CAPITAL_A: 0x41,
  LATIN_CAPITAL_F: 0x46,
  LATIN_CAPITAL_X: 0x58,
  LATIN_CAPITAL_Z: 0x5a,
  RIGHT_SQUARE_BRACKET: 0x5d,
  GRAVE_ACCENT: 0x60,
  LATIN_SMALL_A: 0x61,
  LATIN_SMALL_F: 0x66,
  LATIN_SMALL_X: 0x78,
  LATIN_SMALL_Z: 0x7a,
  REPLACEMENT_CHARACTER: 0xfffd
};
exports.CODE_POINT_SEQUENCES = {
  DASH_DASH_STRING: [0x2d, 0x2d],
  //--
  DOCTYPE_STRING: [0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45],
  //DOCTYPE
  CDATA_START_STRING: [0x5b, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5b],
  //[CDATA[
  SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74],
  //script
  PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4c, 0x49, 0x43],
  //PUBLIC
  SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4d] //SYSTEM
};

//Surrogates
exports.isSurrogate = function (cp) {
  return cp >= 0xd800 && cp <= 0xdfff;
};
exports.isSurrogatePair = function (cp) {
  return cp >= 0xdc00 && cp <= 0xdfff;
};
exports.getSurrogatePairCodePoint = function (cp1, cp2) {
  return (cp1 - 0xd800) * 0x400 + 0x2400 + cp2;
};

//NOTE: excluding NULL and ASCII whitespace
exports.isControlCodePoint = function (cp) {
  return cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f || cp >= 0x7f && cp <= 0x9f;
};
exports.isUndefinedCodePoint = function (cp) {
  return cp >= 0xfdd0 && cp <= 0xfdef || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
};

/***/ }),

/***/ 9043:
/*!************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
class ErrorReportingMixinBase extends Mixin {
  constructor(host, opts) {
    super(host);
    this.posTracker = null;
    this.onParseError = opts.onParseError;
  }
  _setErrorLocation(err) {
    err.startLine = err.endLine = this.posTracker.line;
    err.startCol = err.endCol = this.posTracker.col;
    err.startOffset = err.endOffset = this.posTracker.offset;
  }
  _reportError(code) {
    const err = {
      code: code,
      startLine: -1,
      startCol: -1,
      startOffset: -1,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    this._setErrorLocation(err);
    this.onParseError(err);
  }
  _getOverriddenMethods(mxn) {
    return {
      _err(code) {
        mxn._reportError(code);
      }
    };
  }
}
module.exports = ErrorReportingMixinBase;

/***/ }),

/***/ 457:
/*!**************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js ***!
  \**************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ 9043);
const ErrorReportingTokenizerMixin = __webpack_require__(/*! ./tokenizer-mixin */ 96393);
const LocationInfoTokenizerMixin = __webpack_require__(/*! ../location-info/tokenizer-mixin */ 80510);
const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
class ErrorReportingParserMixin extends ErrorReportingMixinBase {
  constructor(parser, opts) {
    super(parser, opts);
    this.opts = opts;
    this.ctLoc = null;
    this.locBeforeToken = false;
  }
  _setErrorLocation(err) {
    if (this.ctLoc) {
      err.startLine = this.ctLoc.startLine;
      err.startCol = this.ctLoc.startCol;
      err.startOffset = this.ctLoc.startOffset;
      err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
      err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
      err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
    }
  }
  _getOverriddenMethods(mxn, orig) {
    return {
      _bootstrap(document, fragmentContext) {
        orig._bootstrap.call(this, document, fragmentContext);
        Mixin.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
        Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
      },
      _processInputToken(token) {
        mxn.ctLoc = token.location;
        orig._processInputToken.call(this, token);
      },
      _err(code, options) {
        mxn.locBeforeToken = options && options.beforeToken;
        mxn._reportError(code);
      }
    };
  }
}
module.exports = ErrorReportingParserMixin;

/***/ }),

/***/ 86585:
/*!********************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js ***!
  \********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ 9043);
const PositionTrackingPreprocessorMixin = __webpack_require__(/*! ../position-tracking/preprocessor-mixin */ 17027);
const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
class ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase {
  constructor(preprocessor, opts) {
    super(preprocessor, opts);
    this.posTracker = Mixin.install(preprocessor, PositionTrackingPreprocessorMixin);
    this.lastErrOffset = -1;
  }
  _reportError(code) {
    //NOTE: avoid reporting error twice on advance/retreat
    if (this.lastErrOffset !== this.posTracker.offset) {
      this.lastErrOffset = this.posTracker.offset;
      super._reportError(code);
    }
  }
}
module.exports = ErrorReportingPreprocessorMixin;

/***/ }),

/***/ 96393:
/*!*****************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ 9043);
const ErrorReportingPreprocessorMixin = __webpack_require__(/*! ./preprocessor-mixin */ 86585);
const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
class ErrorReportingTokenizerMixin extends ErrorReportingMixinBase {
  constructor(tokenizer, opts) {
    super(tokenizer, opts);
    const preprocessorMixin = Mixin.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);
    this.posTracker = preprocessorMixin.posTracker;
  }
}
module.exports = ErrorReportingTokenizerMixin;

/***/ }),

/***/ 81675:
/*!************************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
class LocationInfoOpenElementStackMixin extends Mixin {
  constructor(stack, opts) {
    super(stack);
    this.onItemPop = opts.onItemPop;
  }
  _getOverriddenMethods(mxn, orig) {
    return {
      pop() {
        mxn.onItemPop(this.current);
        orig.pop.call(this);
      },
      popAllUpToHtmlElement() {
        for (let i = this.stackTop; i > 0; i--) {
          mxn.onItemPop(this.items[i]);
        }
        orig.popAllUpToHtmlElement.call(this);
      },
      remove(element) {
        mxn.onItemPop(this.current);
        orig.remove.call(this, element);
      }
    };
  }
}
module.exports = LocationInfoOpenElementStackMixin;

/***/ }),

/***/ 98800:
/*!************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/location-info/parser-mixin.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
const Tokenizer = __webpack_require__(/*! ../../tokenizer */ 9285);
const LocationInfoTokenizerMixin = __webpack_require__(/*! ./tokenizer-mixin */ 80510);
const LocationInfoOpenElementStackMixin = __webpack_require__(/*! ./open-element-stack-mixin */ 81675);
const HTML = __webpack_require__(/*! ../../common/html */ 39604);

//Aliases
const $ = HTML.TAG_NAMES;
class LocationInfoParserMixin extends Mixin {
  constructor(parser) {
    super(parser);
    this.parser = parser;
    this.treeAdapter = this.parser.treeAdapter;
    this.posTracker = null;
    this.lastStartTagToken = null;
    this.lastFosterParentingLocation = null;
    this.currentToken = null;
  }
  _setStartLocation(element) {
    let loc = null;
    if (this.lastStartTagToken) {
      loc = Object.assign({}, this.lastStartTagToken.location);
      loc.startTag = this.lastStartTagToken.location;
    }
    this.treeAdapter.setNodeSourceCodeLocation(element, loc);
  }
  _setEndLocation(element, closingToken) {
    const loc = this.treeAdapter.getNodeSourceCodeLocation(element);
    if (loc) {
      if (closingToken.location) {
        const ctLoc = closingToken.location;
        const tn = this.treeAdapter.getTagName(element);

        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;
        const endLoc = {};
        if (isClosingEndTag) {
          endLoc.endTag = Object.assign({}, ctLoc);
          endLoc.endLine = ctLoc.endLine;
          endLoc.endCol = ctLoc.endCol;
          endLoc.endOffset = ctLoc.endOffset;
        } else {
          endLoc.endLine = ctLoc.startLine;
          endLoc.endCol = ctLoc.startCol;
          endLoc.endOffset = ctLoc.startOffset;
        }
        this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
      }
    }
  }
  _getOverriddenMethods(mxn, orig) {
    return {
      _bootstrap(document, fragmentContext) {
        orig._bootstrap.call(this, document, fragmentContext);
        mxn.lastStartTagToken = null;
        mxn.lastFosterParentingLocation = null;
        mxn.currentToken = null;
        const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
        mxn.posTracker = tokenizerMixin.posTracker;
        Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
          onItemPop: function (element) {
            mxn._setEndLocation(element, mxn.currentToken);
          }
        });
      },
      _runParsingLoop(scriptHandler) {
        orig._runParsingLoop.call(this, scriptHandler);

        // NOTE: generate location info for elements
        // that remains on open element stack
        for (let i = this.openElements.stackTop; i >= 0; i--) {
          mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
        }
      },
      //Token processing
      _processTokenInForeignContent(token) {
        mxn.currentToken = token;
        orig._processTokenInForeignContent.call(this, token);
      },
      _processToken(token) {
        mxn.currentToken = token;
        orig._processToken.call(this, token);

        //NOTE: <body> and <html> are never popped from the stack, so we need to updated
        //their end location explicitly.
        const requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));
        if (requireExplicitUpdate) {
          for (let i = this.openElements.stackTop; i >= 0; i--) {
            const element = this.openElements.items[i];
            if (this.treeAdapter.getTagName(element) === token.tagName) {
              mxn._setEndLocation(element, token);
              break;
            }
          }
        }
      },
      //Doctype
      _setDocumentType(token) {
        orig._setDocumentType.call(this, token);
        const documentChildren = this.treeAdapter.getChildNodes(this.document);
        const cnLength = documentChildren.length;
        for (let i = 0; i < cnLength; i++) {
          const node = documentChildren[i];
          if (this.treeAdapter.isDocumentTypeNode(node)) {
            this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
            break;
          }
        }
      },
      //Elements
      _attachElementToTree(element) {
        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
        //So we will use token location stored in this methods for the element.
        mxn._setStartLocation(element);
        mxn.lastStartTagToken = null;
        orig._attachElementToTree.call(this, element);
      },
      _appendElement(token, namespaceURI) {
        mxn.lastStartTagToken = token;
        orig._appendElement.call(this, token, namespaceURI);
      },
      _insertElement(token, namespaceURI) {
        mxn.lastStartTagToken = token;
        orig._insertElement.call(this, token, namespaceURI);
      },
      _insertTemplate(token) {
        mxn.lastStartTagToken = token;
        orig._insertTemplate.call(this, token);
        const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
        this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
      },
      _insertFakeRootElement() {
        orig._insertFakeRootElement.call(this);
        this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
      },
      //Comments
      _appendCommentNode(token, parent) {
        orig._appendCommentNode.call(this, token, parent);
        const children = this.treeAdapter.getChildNodes(parent);
        const commentNode = children[children.length - 1];
        this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
      },
      //Text
      _findFosterParentingLocation() {
        //NOTE: store last foster parenting location, so we will be able to find inserted text
        //in case of foster parenting
        mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
        return mxn.lastFosterParentingLocation;
      },
      _insertCharacters(token) {
        orig._insertCharacters.call(this, token);
        const hasFosterParent = this._shouldFosterParentOnInsertion();
        const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
        const siblings = this.treeAdapter.getChildNodes(parent);
        const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;
        const textNode = siblings[textNodeIdx];

        //NOTE: if we have location assigned by another token, then just update end position
        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
        if (tnLoc) {
          const {
            endLine,
            endCol,
            endOffset
          } = token.location;
          this.treeAdapter.updateNodeSourceCodeLocation(textNode, {
            endLine,
            endCol,
            endOffset
          });
        } else {
          this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
        }
      }
    };
  }
}
module.exports = LocationInfoParserMixin;

/***/ }),

/***/ 80510:
/*!***************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js ***!
  \***************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
const Tokenizer = __webpack_require__(/*! ../../tokenizer */ 9285);
const PositionTrackingPreprocessorMixin = __webpack_require__(/*! ../position-tracking/preprocessor-mixin */ 17027);
class LocationInfoTokenizerMixin extends Mixin {
  constructor(tokenizer) {
    super(tokenizer);
    this.tokenizer = tokenizer;
    this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);
    this.currentAttrLocation = null;
    this.ctLoc = null;
  }
  _getCurrentLocation() {
    return {
      startLine: this.posTracker.line,
      startCol: this.posTracker.col,
      startOffset: this.posTracker.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _attachCurrentAttrLocationInfo() {
    this.currentAttrLocation.endLine = this.posTracker.line;
    this.currentAttrLocation.endCol = this.posTracker.col;
    this.currentAttrLocation.endOffset = this.posTracker.offset;
    const currentToken = this.tokenizer.currentToken;
    const currentAttr = this.tokenizer.currentAttr;
    if (!currentToken.location.attrs) {
      currentToken.location.attrs = Object.create(null);
    }
    currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
  }
  _getOverriddenMethods(mxn, orig) {
    const methods = {
      _createStartTagToken() {
        orig._createStartTagToken.call(this);
        this.currentToken.location = mxn.ctLoc;
      },
      _createEndTagToken() {
        orig._createEndTagToken.call(this);
        this.currentToken.location = mxn.ctLoc;
      },
      _createCommentToken() {
        orig._createCommentToken.call(this);
        this.currentToken.location = mxn.ctLoc;
      },
      _createDoctypeToken(initialName) {
        orig._createDoctypeToken.call(this, initialName);
        this.currentToken.location = mxn.ctLoc;
      },
      _createCharacterToken(type, ch) {
        orig._createCharacterToken.call(this, type, ch);
        this.currentCharacterToken.location = mxn.ctLoc;
      },
      _createEOFToken() {
        orig._createEOFToken.call(this);
        this.currentToken.location = mxn._getCurrentLocation();
      },
      _createAttr(attrNameFirstCh) {
        orig._createAttr.call(this, attrNameFirstCh);
        mxn.currentAttrLocation = mxn._getCurrentLocation();
      },
      _leaveAttrName(toState) {
        orig._leaveAttrName.call(this, toState);
        mxn._attachCurrentAttrLocationInfo();
      },
      _leaveAttrValue(toState) {
        orig._leaveAttrValue.call(this, toState);
        mxn._attachCurrentAttrLocationInfo();
      },
      _emitCurrentToken() {
        const ctLoc = this.currentToken.location;

        //NOTE: if we have pending character token make it's end location equal to the
        //current token's start location.
        if (this.currentCharacterToken) {
          this.currentCharacterToken.location.endLine = ctLoc.startLine;
          this.currentCharacterToken.location.endCol = ctLoc.startCol;
          this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
        }
        if (this.currentToken.type === Tokenizer.EOF_TOKEN) {
          ctLoc.endLine = ctLoc.startLine;
          ctLoc.endCol = ctLoc.startCol;
          ctLoc.endOffset = ctLoc.startOffset;
        } else {
          ctLoc.endLine = mxn.posTracker.line;
          ctLoc.endCol = mxn.posTracker.col + 1;
          ctLoc.endOffset = mxn.posTracker.offset + 1;
        }
        orig._emitCurrentToken.call(this);
      },
      _emitCurrentCharacterToken() {
        const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;

        //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),
        //then set it's location at the current preprocessor position.
        //We don't need to increment preprocessor position, since character token
        //emission is always forced by the start of the next character token here.
        //So, we already have advanced position.
        if (ctLoc && ctLoc.endOffset === -1) {
          ctLoc.endLine = mxn.posTracker.line;
          ctLoc.endCol = mxn.posTracker.col;
          ctLoc.endOffset = mxn.posTracker.offset;
        }
        orig._emitCurrentCharacterToken.call(this);
      }
    };

    //NOTE: patch initial states for each mode to obtain token start position
    Object.keys(Tokenizer.MODE).forEach(modeName => {
      const state = Tokenizer.MODE[modeName];
      methods[state] = function (cp) {
        mxn.ctLoc = mxn._getCurrentLocation();
        orig[state].call(this, cp);
      };
    });
    return methods;
  }
}
module.exports = LocationInfoTokenizerMixin;

/***/ }),

/***/ 17027:
/*!**********************************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js ***!
  \**********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Mixin = __webpack_require__(/*! ../../utils/mixin */ 7596);
class PositionTrackingPreprocessorMixin extends Mixin {
  constructor(preprocessor) {
    super(preprocessor);
    this.preprocessor = preprocessor;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.offset = 0;
    this.col = 0;
    this.line = 1;
  }
  _getOverriddenMethods(mxn, orig) {
    return {
      advance() {
        const pos = this.pos + 1;
        const ch = this.html[pos];

        //NOTE: LF should be in the last column of the line
        if (mxn.isEol) {
          mxn.isEol = false;
          mxn.line++;
          mxn.lineStartPos = pos;
        }
        if (ch === '\n' || ch === '\r' && this.html[pos + 1] !== '\n') {
          mxn.isEol = true;
        }
        mxn.col = pos - mxn.lineStartPos + 1;
        mxn.offset = mxn.droppedBufferSize + pos;
        return orig.advance.call(this);
      },
      retreat() {
        orig.retreat.call(this);
        mxn.isEol = false;
        mxn.col = this.pos - mxn.lineStartPos + 1;
      },
      dropParsedChunk() {
        const prevPos = this.pos;
        orig.dropParsedChunk.call(this);
        const reduction = prevPos - this.pos;
        mxn.lineStartPos -= reduction;
        mxn.droppedBufferSize += reduction;
        mxn.offset = mxn.droppedBufferSize + this.pos;
      }
    };
  }
}
module.exports = PositionTrackingPreprocessorMixin;

/***/ }),

/***/ 53563:
/*!****************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


const Parser = __webpack_require__(/*! ./parser */ 26139);
const Serializer = __webpack_require__(/*! ./serializer */ 64620);

// Shorthands
exports.parse = function parse(html, options) {
  const parser = new Parser(options);
  return parser.parse(html);
};
exports.parseFragment = function parseFragment(fragmentContext, html, options) {
  if (typeof fragmentContext === 'string') {
    options = html;
    html = fragmentContext;
    fragmentContext = null;
  }
  const parser = new Parser(options);
  return parser.parseFragment(html, fragmentContext);
};
exports.serialize = function (node, options) {
  const serializer = new Serializer(node, options);
  return serializer.serialize();
};

/***/ }),

/***/ 40762:
/*!*****************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/parser/formatting-element-list.js ***!
  \*****************************************************************************************/
/***/ (function(module) {

"use strict";


//Const
const NOAH_ARK_CAPACITY = 3;

//List of formatting elements
class FormattingElementList {
  constructor(treeAdapter) {
    this.length = 0;
    this.entries = [];
    this.treeAdapter = treeAdapter;
    this.bookmark = null;
  }

  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement) {
    const candidates = [];
    if (this.length >= NOAH_ARK_CAPACITY) {
      const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
      const neTagName = this.treeAdapter.getTagName(newElement);
      const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
      for (let i = this.length - 1; i >= 0; i--) {
        const entry = this.entries[i];
        if (entry.type === FormattingElementList.MARKER_ENTRY) {
          break;
        }
        const element = entry.element;
        const elementAttrs = this.treeAdapter.getAttrList(element);
        const isCandidate = this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI && elementAttrs.length === neAttrsLength;
        if (isCandidate) {
          candidates.push({
            idx: i,
            attrs: elementAttrs
          });
        }
      }
    }
    return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
  }
  _ensureNoahArkCondition(newElement) {
    const candidates = this._getNoahArkConditionCandidates(newElement);
    let cLength = candidates.length;
    if (cLength) {
      const neAttrs = this.treeAdapter.getAttrList(newElement);
      const neAttrsLength = neAttrs.length;
      const neAttrsMap = Object.create(null);

      //NOTE: build attrs map for the new element so we can perform fast lookups
      for (let i = 0; i < neAttrsLength; i++) {
        const neAttr = neAttrs[i];
        neAttrsMap[neAttr.name] = neAttr.value;
      }
      for (let i = 0; i < neAttrsLength; i++) {
        for (let j = 0; j < cLength; j++) {
          const cAttr = candidates[j].attrs[i];
          if (neAttrsMap[cAttr.name] !== cAttr.value) {
            candidates.splice(j, 1);
            cLength--;
          }
          if (candidates.length < NOAH_ARK_CAPACITY) {
            return;
          }
        }
      }

      //NOTE: remove bottommost candidates until Noah's Ark condition will not be met
      for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {
        this.entries.splice(candidates[i].idx, 1);
        this.length--;
      }
    }
  }

  //Mutations
  insertMarker() {
    this.entries.push({
      type: FormattingElementList.MARKER_ENTRY
    });
    this.length++;
  }
  pushElement(element, token) {
    this._ensureNoahArkCondition(element);
    this.entries.push({
      type: FormattingElementList.ELEMENT_ENTRY,
      element: element,
      token: token
    });
    this.length++;
  }
  insertElementAfterBookmark(element, token) {
    let bookmarkIdx = this.length - 1;
    for (; bookmarkIdx >= 0; bookmarkIdx--) {
      if (this.entries[bookmarkIdx] === this.bookmark) {
        break;
      }
    }
    this.entries.splice(bookmarkIdx + 1, 0, {
      type: FormattingElementList.ELEMENT_ENTRY,
      element: element,
      token: token
    });
    this.length++;
  }
  removeEntry(entry) {
    for (let i = this.length - 1; i >= 0; i--) {
      if (this.entries[i] === entry) {
        this.entries.splice(i, 1);
        this.length--;
        break;
      }
    }
  }
  clearToLastMarker() {
    while (this.length) {
      const entry = this.entries.pop();
      this.length--;
      if (entry.type === FormattingElementList.MARKER_ENTRY) {
        break;
      }
    }
  }

  //Search
  getElementEntryInScopeWithTagName(tagName) {
    for (let i = this.length - 1; i >= 0; i--) {
      const entry = this.entries[i];
      if (entry.type === FormattingElementList.MARKER_ENTRY) {
        return null;
      }
      if (this.treeAdapter.getTagName(entry.element) === tagName) {
        return entry;
      }
    }
    return null;
  }
  getElementEntry(element) {
    for (let i = this.length - 1; i >= 0; i--) {
      const entry = this.entries[i];
      if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {
        return entry;
      }
    }
    return null;
  }
}

//Entry types
FormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';
FormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';
module.exports = FormattingElementList;

/***/ }),

/***/ 26139:
/*!***********************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/parser/index.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Tokenizer = __webpack_require__(/*! ../tokenizer */ 9285);
const OpenElementStack = __webpack_require__(/*! ./open-element-stack */ 5795);
const FormattingElementList = __webpack_require__(/*! ./formatting-element-list */ 40762);
const LocationInfoParserMixin = __webpack_require__(/*! ../extensions/location-info/parser-mixin */ 98800);
const ErrorReportingParserMixin = __webpack_require__(/*! ../extensions/error-reporting/parser-mixin */ 457);
const Mixin = __webpack_require__(/*! ../utils/mixin */ 7596);
const defaultTreeAdapter = __webpack_require__(/*! ../tree-adapters/default */ 80382);
const mergeOptions = __webpack_require__(/*! ../utils/merge-options */ 34378);
const doctype = __webpack_require__(/*! ../common/doctype */ 29059);
const foreignContent = __webpack_require__(/*! ../common/foreign-content */ 17189);
const ERR = __webpack_require__(/*! ../common/error-codes */ 63136);
const unicode = __webpack_require__(/*! ../common/unicode */ 84382);
const HTML = __webpack_require__(/*! ../common/html */ 39604);

//Aliases
const $ = HTML.TAG_NAMES;
const NS = HTML.NAMESPACES;
const ATTRS = HTML.ATTRS;
const DEFAULT_OPTIONS = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  onParseError: null,
  treeAdapter: defaultTreeAdapter
};

//Misc constants
const HIDDEN_INPUT_TYPE = 'hidden';

//Adoption agency loops iteration count
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;

//Insertion modes
const INITIAL_MODE = 'INITIAL_MODE';
const BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';
const BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';
const IN_HEAD_MODE = 'IN_HEAD_MODE';
const IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';
const AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';
const IN_BODY_MODE = 'IN_BODY_MODE';
const TEXT_MODE = 'TEXT_MODE';
const IN_TABLE_MODE = 'IN_TABLE_MODE';
const IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';
const IN_CAPTION_MODE = 'IN_CAPTION_MODE';
const IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';
const IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';
const IN_ROW_MODE = 'IN_ROW_MODE';
const IN_CELL_MODE = 'IN_CELL_MODE';
const IN_SELECT_MODE = 'IN_SELECT_MODE';
const IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';
const IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';
const AFTER_BODY_MODE = 'AFTER_BODY_MODE';
const IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';
const AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';
const AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';
const AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';

//Insertion mode reset map
const INSERTION_MODE_RESET_MAP = {
  [$.TR]: IN_ROW_MODE,
  [$.TBODY]: IN_TABLE_BODY_MODE,
  [$.THEAD]: IN_TABLE_BODY_MODE,
  [$.TFOOT]: IN_TABLE_BODY_MODE,
  [$.CAPTION]: IN_CAPTION_MODE,
  [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
  [$.TABLE]: IN_TABLE_MODE,
  [$.BODY]: IN_BODY_MODE,
  [$.FRAMESET]: IN_FRAMESET_MODE
};

//Template insertion mode switch map
const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
  [$.CAPTION]: IN_TABLE_MODE,
  [$.COLGROUP]: IN_TABLE_MODE,
  [$.TBODY]: IN_TABLE_MODE,
  [$.TFOOT]: IN_TABLE_MODE,
  [$.THEAD]: IN_TABLE_MODE,
  [$.COL]: IN_COLUMN_GROUP_MODE,
  [$.TR]: IN_TABLE_BODY_MODE,
  [$.TD]: IN_ROW_MODE,
  [$.TH]: IN_ROW_MODE
};

//Token handlers map for insertion modes
const TOKEN_HANDLERS = {
  [INITIAL_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
    [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
    [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
    [Tokenizer.EOF_TOKEN]: tokenInInitialMode
  },
  [BEFORE_HTML_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
    [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
    [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
  },
  [BEFORE_HEAD_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
    [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
    [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
    [Tokenizer.EOF_TOKEN]: tokenBeforeHead
  },
  [IN_HEAD_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
    [Tokenizer.START_TAG_TOKEN]: startTagInHead,
    [Tokenizer.END_TAG_TOKEN]: endTagInHead,
    [Tokenizer.EOF_TOKEN]: tokenInHead
  },
  [IN_HEAD_NO_SCRIPT_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
    [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
    [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
    [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
  },
  [AFTER_HEAD_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
    [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
    [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
    [Tokenizer.EOF_TOKEN]: tokenAfterHead
  },
  [IN_BODY_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInBody,
    [Tokenizer.END_TAG_TOKEN]: endTagInBody,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [TEXT_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: ignoreToken,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: ignoreToken,
    [Tokenizer.END_TAG_TOKEN]: endTagInText,
    [Tokenizer.EOF_TOKEN]: eofInText
  },
  [IN_TABLE_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInTable,
    [Tokenizer.END_TAG_TOKEN]: endTagInTable,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_TABLE_TEXT_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
    [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
    [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
    [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
    [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
    [Tokenizer.EOF_TOKEN]: tokenInTableText
  },
  [IN_CAPTION_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
    [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_COLUMN_GROUP_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
    [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_TABLE_BODY_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
    [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_ROW_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInRow,
    [Tokenizer.END_TAG_TOKEN]: endTagInRow,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_CELL_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInCell,
    [Tokenizer.END_TAG_TOKEN]: endTagInCell,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_SELECT_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
    [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_SELECT_IN_TABLE_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
    [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
    [Tokenizer.EOF_TOKEN]: eofInBody
  },
  [IN_TEMPLATE_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: characterInBody,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
    [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
    [Tokenizer.EOF_TOKEN]: eofInTemplate
  },
  [AFTER_BODY_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
    [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
    [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
    [Tokenizer.EOF_TOKEN]: stopParsing
  },
  [IN_FRAMESET_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
    [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
    [Tokenizer.EOF_TOKEN]: stopParsing
  },
  [AFTER_FRAMESET_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
    [Tokenizer.COMMENT_TOKEN]: appendComment,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
    [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
    [Tokenizer.EOF_TOKEN]: stopParsing
  },
  [AFTER_AFTER_BODY_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
    [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
    [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
    [Tokenizer.EOF_TOKEN]: stopParsing
  },
  [AFTER_AFTER_FRAMESET_MODE]: {
    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
    [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
    [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
    [Tokenizer.END_TAG_TOKEN]: ignoreToken,
    [Tokenizer.EOF_TOKEN]: stopParsing
  }
};

//Parser
class Parser {
  constructor(options) {
    this.options = mergeOptions(DEFAULT_OPTIONS, options);
    this.treeAdapter = this.options.treeAdapter;
    this.pendingScript = null;
    if (this.options.sourceCodeLocationInfo) {
      Mixin.install(this, LocationInfoParserMixin);
    }
    if (this.options.onParseError) {
      Mixin.install(this, ErrorReportingParserMixin, {
        onParseError: this.options.onParseError
      });
    }
  }

  // API
  parse(html) {
    const document = this.treeAdapter.createDocument();
    this._bootstrap(document, null);
    this.tokenizer.write(html, true);
    this._runParsingLoop(null);
    return document;
  }
  parseFragment(html, fragmentContext) {
    //NOTE: use <template> element as a fragment context if context element was not provided,
    //so we will parse in "forgiving" manner
    if (!fragmentContext) {
      fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
    }

    //NOTE: create fake element which will be used as 'document' for fragment parsing.
    //This is important for jsdom there 'document' can't be recreated, therefore
    //fragment parsing causes messing of the main `document`.
    const documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);
    this._bootstrap(documentMock, fragmentContext);
    if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
      this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
    }
    this._initTokenizerForFragmentParsing();
    this._insertFakeRootElement();
    this._resetInsertionMode();
    this._findFormInFragmentContext();
    this.tokenizer.write(html, true);
    this._runParsingLoop(null);
    const rootElement = this.treeAdapter.getFirstChild(documentMock);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }

  //Bootstrap parser
  _bootstrap(document, fragmentContext) {
    this.tokenizer = new Tokenizer(this.options);
    this.stopped = false;
    this.insertionMode = INITIAL_MODE;
    this.originalInsertionMode = '';
    this.document = document;
    this.fragmentContext = fragmentContext;
    this.headElement = null;
    this.formElement = null;
    this.openElements = new OpenElementStack(this.document, this.treeAdapter);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.tmplInsertionModeStack = [];
    this.tmplInsertionModeStackTop = -1;
    this.currentTmplInsertionMode = null;
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
  }

  //Errors
  _err() {
    // NOTE: err reporting is noop by default. Enabled by mixin.
  }

  //Parsing loop
  _runParsingLoop(scriptHandler) {
    while (!this.stopped) {
      this._setupTokenizerCDATAMode();
      const token = this.tokenizer.getNextToken();
      if (token.type === Tokenizer.HIBERNATION_TOKEN) {
        break;
      }
      if (this.skipNextNewLine) {
        this.skipNextNewLine = false;
        if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
          if (token.chars.length === 1) {
            continue;
          }
          token.chars = token.chars.substr(1);
        }
      }
      this._processInputToken(token);
      if (scriptHandler && this.pendingScript) {
        break;
      }
    }
  }
  runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
    this._runParsingLoop(scriptHandler);
    if (scriptHandler && this.pendingScript) {
      const script = this.pendingScript;
      this.pendingScript = null;
      scriptHandler(script);
      return;
    }
    if (writeCallback) {
      writeCallback();
    }
  }

  //Text parsing
  _setupTokenizerCDATAMode() {
    const current = this._getAdjustedCurrentElement();
    this.tokenizer.allowCDATA = current && current !== this.document && this.treeAdapter.getNamespaceURI(current) !== NS.HTML && !this._isIntegrationPoint(current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = TEXT_MODE;
  }
  switchToPlaintextParsing() {
    this.insertionMode = TEXT_MODE;
    this.originalInsertionMode = IN_BODY_MODE;
    this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
  }

  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node = this.fragmentContext;
    do {
      if (this.treeAdapter.getTagName(node) === $.FORM) {
        this.formElement = node;
        break;
      }
      node = this.treeAdapter.getParentNode(node);
    } while (node);
  }
  _initTokenizerForFragmentParsing() {
    if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
      const tn = this.treeAdapter.getTagName(this.fragmentContext);
      if (tn === $.TITLE || tn === $.TEXTAREA) {
        this.tokenizer.state = Tokenizer.MODE.RCDATA;
      } else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME || tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {
        this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
      } else if (tn === $.SCRIPT) {
        this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
      } else if (tn === $.PLAINTEXT) {
        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
      }
    }
  }

  //Tree mutation
  _setDocumentType(token) {
    const name = token.name || '';
    const publicId = token.publicId || '';
    const systemId = token.systemId || '';
    this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
  }
  _attachElementToTree(element) {
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element);
    } else {
      const parent = this.openElements.currentTmplContent || this.openElements.current;
      this.treeAdapter.appendChild(parent, element);
    }
  }
  _appendElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element);
  }
  _insertElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element);
    this.openElements.push(element);
  }
  _insertFakeElement(tagName) {
    const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element);
    this.openElements.push(element);
  }
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl);
    this.openElements.push(tmpl);
  }
  _insertFakeRootElement() {
    const element = this.treeAdapter.createElement($.HTML, NS.HTML, []);
    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element);
  }
  _appendCommentNode(token, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent, commentNode);
  }
  _insertCharacters(token) {
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentText(token.chars);
    } else {
      const parent = this.openElements.currentTmplContent || this.openElements.current;
      this.treeAdapter.insertText(parent, token.chars);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }

  //Token processing
  _shouldProcessTokenInForeignContent(token) {
    const current = this._getAdjustedCurrentElement();
    if (!current || current === this.document) {
      return false;
    }
    const ns = this.treeAdapter.getNamespaceURI(current);
    if (ns === NS.HTML) {
      return false;
    }
    if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns === NS.MATHML && token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG) {
      return false;
    }
    const isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;
    const isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;
    if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {
      return false;
    }
    if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS.HTML)) {
      return false;
    }
    return token.type !== Tokenizer.EOF_TOKEN;
  }
  _processToken(token) {
    TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
  }
  _processTokenInBodyMode(token) {
    TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
  }
  _processTokenInForeignContent(token) {
    if (token.type === Tokenizer.CHARACTER_TOKEN) {
      characterInForeignContent(this, token);
    } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
      nullCharacterInForeignContent(this, token);
    } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
      insertCharacters(this, token);
    } else if (token.type === Tokenizer.COMMENT_TOKEN) {
      appendComment(this, token);
    } else if (token.type === Tokenizer.START_TAG_TOKEN) {
      startTagInForeignContent(this, token);
    } else if (token.type === Tokenizer.END_TAG_TOKEN) {
      endTagInForeignContent(this, token);
    }
  }
  _processInputToken(token) {
    if (this._shouldProcessTokenInForeignContent(token)) {
      this._processTokenInForeignContent(token);
    } else {
      this._processToken(token);
    }
    if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {
      this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }

  //Integration points
  _isIntegrationPoint(element, foreignNS) {
    const tn = this.treeAdapter.getTagName(element);
    const ns = this.treeAdapter.getNamespaceURI(element);
    const attrs = this.treeAdapter.getAttrList(element);
    return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
  }

  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.length;
    if (listLength) {
      let unopenIdx = listLength;
      let entry = null;
      do {
        unopenIdx--;
        entry = this.activeFormattingElements.entries[unopenIdx];
        if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
          unopenIdx++;
          break;
        }
      } while (unopenIdx > 0);
      for (let i = unopenIdx; i < listLength; i++) {
        entry = this.activeFormattingElements.entries[i];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }

  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = IN_ROW_MODE;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion($.P);
    this.openElements.popUntilTagNamePopped($.P);
  }

  //Insertion modes
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {
      let element = this.openElements.items[i];
      if (i === 0) {
        last = true;
        if (this.fragmentContext) {
          element = this.fragmentContext;
        }
      }
      const tn = this.treeAdapter.getTagName(element);
      const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];
      if (newInsertionMode) {
        this.insertionMode = newInsertionMode;
        break;
      } else if (!last && (tn === $.TD || tn === $.TH)) {
        this.insertionMode = IN_CELL_MODE;
        break;
      } else if (!last && tn === $.HEAD) {
        this.insertionMode = IN_HEAD_MODE;
        break;
      } else if (tn === $.SELECT) {
        this._resetInsertionModeForSelect(i);
        break;
      } else if (tn === $.TEMPLATE) {
        this.insertionMode = this.currentTmplInsertionMode;
        break;
      } else if (tn === $.HTML) {
        this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
        break;
      } else if (last) {
        this.insertionMode = IN_BODY_MODE;
        break;
      }
    }
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const ancestor = this.openElements.items[i];
        const tn = this.treeAdapter.getTagName(ancestor);
        if (tn === $.TEMPLATE) {
          break;
        } else if (tn === $.TABLE) {
          this.insertionMode = IN_SELECT_IN_TABLE_MODE;
          return;
        }
      }
    }
    this.insertionMode = IN_SELECT_MODE;
  }
  _pushTmplInsertionMode(mode) {
    this.tmplInsertionModeStack.push(mode);
    this.tmplInsertionModeStackTop++;
    this.currentTmplInsertionMode = mode;
  }
  _popTmplInsertionMode() {
    this.tmplInsertionModeStack.pop();
    this.tmplInsertionModeStackTop--;
    this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
  }

  //Foster parenting
  _isElementCausesFosterParenting(element) {
    const tn = this.treeAdapter.getTagName(element);
    return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
  }
  _findFosterParentingLocation() {
    const location = {
      parent: null,
      beforeElement: null
    };
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      const tn = this.treeAdapter.getTagName(openElement);
      const ns = this.treeAdapter.getNamespaceURI(openElement);
      if (tn === $.TEMPLATE && ns === NS.HTML) {
        location.parent = this.treeAdapter.getTemplateContent(openElement);
        break;
      } else if (tn === $.TABLE) {
        location.parent = this.treeAdapter.getParentNode(openElement);
        if (location.parent) {
          location.beforeElement = openElement;
        } else {
          location.parent = this.openElements.items[i - 1];
        }
        break;
      }
    }
    if (!location.parent) {
      location.parent = this.openElements.items[0];
    }
    return location;
  }
  _fosterParentElement(element) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
    } else {
      this.treeAdapter.appendChild(location.parent, element);
    }
  }
  _fosterParentText(chars) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
    } else {
      this.treeAdapter.insertText(location.parent, chars);
    }
  }

  //Special elements
  _isSpecialElement(element) {
    const tn = this.treeAdapter.getTagName(element);
    const ns = this.treeAdapter.getNamespaceURI(element);
    return HTML.SPECIAL_ELEMENTS[ns][tn];
  }
}
module.exports = Parser;

//Adoption agency algorithm
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
//------------------------------------------------------------------

//Steps 5-8 of the algorithm
function aaObtainFormattingElementEntry(p, token) {
  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagName)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p, token);
  }
  return formattingElementEntry;
}

//Steps 9 and 10 of the algorithm
function aaObtainFurthestBlock(p, formattingElementEntry) {
  let furthestBlock = null;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const element = p.openElements.items[i];
    if (element === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element)) {
      furthestBlock = element;
    }
  }
  if (!furthestBlock) {
    p.openElements.popUntilElementPopped(formattingElementEntry.element);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}

//Step 13 of the algorithm
function aaInnerLoop(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
    //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)
    nextElement = p.openElements.getCommonAncestor(element);
    const elementEntry = p.activeFormattingElements.getElementEntry(element);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element);
    } else {
      element = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element, lastElement);
      lastElement = element;
    }
  }
  return lastElement;
}

//Step 13.7 of the algorithm
function aaRecreateElementFromEntry(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}

//Step 14 of the algorithm
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  if (p._isElementCausesFosterParenting(commonAncestor)) {
    p._fosterParentElement(lastElement);
  } else {
    const tn = p.treeAdapter.getTagName(commonAncestor);
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tn === $.TEMPLATE && ns === NS.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}

//Steps 15-19 of the algorithm
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const token = formattingElementEntry.token;
  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement);
}

//Algorithm entry point
function callAdoptionAgency(p, token) {
  let formattingElementEntry;
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    formattingElementEntry = aaObtainFormattingElementEntry(p, token, formattingElementEntry);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}

//Generic token handlers
//------------------------------------------------------------------
function ignoreToken() {
  //NOTE: do nothing =)
}
function misplacedDoctype(p) {
  p._err(ERR.misplacedDoctype);
}
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function insertCharacters(p, token) {
  p._insertCharacters(token);
}
function stopParsing(p) {
  p.stopped = true;
}

// The "initial" insertion mode
//------------------------------------------------------------------
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);
  if (!doctype.isConforming(token)) {
    p._err(ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = BEFORE_HTML_MODE;
}
function tokenInInitialMode(p, token) {
  p._err(ERR.missingDoctype, {
    beforeToken: true
  });
  p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);
  p.insertionMode = BEFORE_HTML_MODE;
  p._processToken(token);
}

// The "before html" insertion mode
//------------------------------------------------------------------
function startTagBeforeHtml(p, token) {
  if (token.tagName === $.HTML) {
    p._insertElement(token, NS.HTML);
    p.insertionMode = BEFORE_HEAD_MODE;
  } else {
    tokenBeforeHtml(p, token);
  }
}
function endTagBeforeHtml(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
    tokenBeforeHtml(p, token);
  }
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = BEFORE_HEAD_MODE;
  p._processToken(token);
}

// The "before head" insertion mode
//------------------------------------------------------------------
function startTagBeforeHead(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.HEAD) {
    p._insertElement(token, NS.HTML);
    p.headElement = p.openElements.current;
    p.insertionMode = IN_HEAD_MODE;
  } else {
    tokenBeforeHead(p, token);
  }
}
function endTagBeforeHead(p, token) {
  const tn = token.tagName;
  if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
    tokenBeforeHead(p, token);
  } else {
    p._err(ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement($.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = IN_HEAD_MODE;
  p._processToken(token);
}

// The "in head" insertion mode
//------------------------------------------------------------------
function startTagInHead(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {
    p._appendElement(token, NS.HTML);
    token.ackSelfClosing = true;
  } else if (tn === $.TITLE) {
    p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
  } else if (tn === $.NOSCRIPT) {
    if (p.options.scriptingEnabled) {
      p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
    } else {
      p._insertElement(token, NS.HTML);
      p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
    }
  } else if (tn === $.NOFRAMES || tn === $.STYLE) {
    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
  } else if (tn === $.SCRIPT) {
    p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
  } else if (tn === $.TEMPLATE) {
    p._insertTemplate(token, NS.HTML);
    p.activeFormattingElements.insertMarker();
    p.framesetOk = false;
    p.insertionMode = IN_TEMPLATE_MODE;
    p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
  } else if (tn === $.HEAD) {
    p._err(ERR.misplacedStartTagForHeadElement);
  } else {
    tokenInHead(p, token);
  }
}
function endTagInHead(p, token) {
  const tn = token.tagName;
  if (tn === $.HEAD) {
    p.openElements.pop();
    p.insertionMode = AFTER_HEAD_MODE;
  } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
    tokenInHead(p, token);
  } else if (tn === $.TEMPLATE) {
    if (p.openElements.tmplCount > 0) {
      p.openElements.generateImpliedEndTagsThoroughly();
      if (p.openElements.currentTagName !== $.TEMPLATE) {
        p._err(ERR.closingOfElementWithOpenChildElements);
      }
      p.openElements.popUntilTagNamePopped($.TEMPLATE);
      p.activeFormattingElements.clearToLastMarker();
      p._popTmplInsertionMode();
      p._resetInsertionMode();
    } else {
      p._err(ERR.endTagWithoutMatchingOpenElement);
    }
  } else {
    p._err(ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = AFTER_HEAD_MODE;
  p._processToken(token);
}

// The "in head no script" insertion mode
//------------------------------------------------------------------
function startTagInHeadNoScript(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.BASEFONT || tn === $.BGSOUND || tn === $.HEAD || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.STYLE) {
    startTagInHead(p, token);
  } else if (tn === $.NOSCRIPT) {
    p._err(ERR.nestedNoscriptInHead);
  } else {
    tokenInHeadNoScript(p, token);
  }
}
function endTagInHeadNoScript(p, token) {
  const tn = token.tagName;
  if (tn === $.NOSCRIPT) {
    p.openElements.pop();
    p.insertionMode = IN_HEAD_MODE;
  } else if (tn === $.BR) {
    tokenInHeadNoScript(p, token);
  } else {
    p._err(ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode = token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p._err(errCode);
  p.openElements.pop();
  p.insertionMode = IN_HEAD_MODE;
  p._processToken(token);
}

// The "after head" insertion mode
//------------------------------------------------------------------
function startTagAfterHead(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.BODY) {
    p._insertElement(token, NS.HTML);
    p.framesetOk = false;
    p.insertionMode = IN_BODY_MODE;
  } else if (tn === $.FRAMESET) {
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_FRAMESET_MODE;
  } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
    p._err(ERR.abandonedHeadElementChild);
    p.openElements.push(p.headElement);
    startTagInHead(p, token);
    p.openElements.remove(p.headElement);
  } else if (tn === $.HEAD) {
    p._err(ERR.misplacedStartTagForHeadElement);
  } else {
    tokenAfterHead(p, token);
  }
}
function endTagAfterHead(p, token) {
  const tn = token.tagName;
  if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
    tokenAfterHead(p, token);
  } else if (tn === $.TEMPLATE) {
    endTagInHead(p, token);
  } else {
    p._err(ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenAfterHead(p, token) {
  p._insertFakeElement($.BODY);
  p.insertionMode = IN_BODY_MODE;
  p._processToken(token);
}

// The "in body" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_FRAMESET_MODE;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  const tn = p.openElements.currentTagName;
  if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
    p.openElements.pop();
  }
  p._insertElement(token, NS.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
  //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope($.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  const tn = token.tagName;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const element = p.openElements.items[i];
    const elementTn = p.treeAdapter.getTagName(element);
    let closeTn = null;
    if (tn === $.LI && elementTn === $.LI) {
      closeTn = $.LI;
    } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
      closeTn = elementTn;
    }
    if (closeTn) {
      p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
      p.openElements.popUntilTagNamePopped(closeTn);
      break;
    }
    if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element)) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope($.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped($.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope($.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  p.insertionMode = IN_TABLE_MODE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS.HTML);
  const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
  if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._appendElement(token, NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
  token.tagName = $.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, NS.HTML);
  //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
  //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
  p.skipNextNewLine = true;
  p.tokenizer.state = Tokenizer.MODE.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = TEXT_MODE;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}

//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
//<noembed> as a rawtext.
function noembedStartTagInBody(p, token) {
  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
  p.framesetOk = false;
  if (p.insertionMode === IN_TABLE_MODE || p.insertionMode === IN_CAPTION_MODE || p.insertionMode === IN_TABLE_BODY_MODE || p.insertionMode === IN_ROW_MODE || p.insertionMode === IN_CELL_MODE) {
    p.insertionMode = IN_SELECT_IN_TABLE_MODE;
  } else {
    p.insertionMode = IN_SELECT_MODE;
  }
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagName === $.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope($.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope($.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion($.RTC);
  }
  p._insertElement(token, NS.HTML);
}
function menuStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  foreignContent.adjustTokenMathMLAttrs(token);
  foreignContent.adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.MATHML);
  } else {
    p._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  foreignContent.adjustTokenSVGAttrs(token);
  foreignContent.adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS.SVG);
  } else {
    p._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS.HTML);
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function startTagInBody(p, token) {
  const tn = token.tagName;
  switch (tn.length) {
    case 1:
      if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
        bStartTagInBody(p, token);
      } else if (tn === $.P) {
        addressStartTagInBody(p, token);
      } else if (tn === $.A) {
        aStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    case 2:
      if (tn === $.DL || tn === $.OL || tn === $.UL) {
        addressStartTagInBody(p, token);
      } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
        numberedHeaderStartTagInBody(p, token);
      } else if (tn === $.LI || tn === $.DD || tn === $.DT) {
        listItemStartTagInBody(p, token);
      } else if (tn === $.EM || tn === $.TT) {
        bStartTagInBody(p, token);
      } else if (tn === $.BR) {
        areaStartTagInBody(p, token);
      } else if (tn === $.HR) {
        hrStartTagInBody(p, token);
      } else if (tn === $.RB) {
        rbStartTagInBody(p, token);
      } else if (tn === $.RT || tn === $.RP) {
        rtStartTagInBody(p, token);
      } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
        genericStartTagInBody(p, token);
      }
      break;
    case 3:
      if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
        addressStartTagInBody(p, token);
      } else if (tn === $.PRE) {
        preStartTagInBody(p, token);
      } else if (tn === $.BIG) {
        bStartTagInBody(p, token);
      } else if (tn === $.IMG || tn === $.WBR) {
        areaStartTagInBody(p, token);
      } else if (tn === $.XMP) {
        xmpStartTagInBody(p, token);
      } else if (tn === $.SVG) {
        svgStartTagInBody(p, token);
      } else if (tn === $.RTC) {
        rbStartTagInBody(p, token);
      } else if (tn !== $.COL) {
        genericStartTagInBody(p, token);
      }
      break;
    case 4:
      if (tn === $.HTML) {
        htmlStartTagInBody(p, token);
      } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
        startTagInHead(p, token);
      } else if (tn === $.BODY) {
        bodyStartTagInBody(p, token);
      } else if (tn === $.MAIN || tn === $.MENU) {
        addressStartTagInBody(p, token);
      } else if (tn === $.FORM) {
        formStartTagInBody(p, token);
      } else if (tn === $.CODE || tn === $.FONT) {
        bStartTagInBody(p, token);
      } else if (tn === $.NOBR) {
        nobrStartTagInBody(p, token);
      } else if (tn === $.AREA) {
        areaStartTagInBody(p, token);
      } else if (tn === $.MATH) {
        mathStartTagInBody(p, token);
      } else if (tn === $.MENU) {
        menuStartTagInBody(p, token);
      } else if (tn !== $.HEAD) {
        genericStartTagInBody(p, token);
      }
      break;
    case 5:
      if (tn === $.STYLE || tn === $.TITLE) {
        startTagInHead(p, token);
      } else if (tn === $.ASIDE) {
        addressStartTagInBody(p, token);
      } else if (tn === $.SMALL) {
        bStartTagInBody(p, token);
      } else if (tn === $.TABLE) {
        tableStartTagInBody(p, token);
      } else if (tn === $.EMBED) {
        areaStartTagInBody(p, token);
      } else if (tn === $.INPUT) {
        inputStartTagInBody(p, token);
      } else if (tn === $.PARAM || tn === $.TRACK) {
        paramStartTagInBody(p, token);
      } else if (tn === $.IMAGE) {
        imageStartTagInBody(p, token);
      } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
        genericStartTagInBody(p, token);
      }
      break;
    case 6:
      if (tn === $.SCRIPT) {
        startTagInHead(p, token);
      } else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
        addressStartTagInBody(p, token);
      } else if (tn === $.BUTTON) {
        buttonStartTagInBody(p, token);
      } else if (tn === $.STRIKE || tn === $.STRONG) {
        bStartTagInBody(p, token);
      } else if (tn === $.APPLET || tn === $.OBJECT) {
        appletStartTagInBody(p, token);
      } else if (tn === $.KEYGEN) {
        areaStartTagInBody(p, token);
      } else if (tn === $.SOURCE) {
        paramStartTagInBody(p, token);
      } else if (tn === $.IFRAME) {
        iframeStartTagInBody(p, token);
      } else if (tn === $.SELECT) {
        selectStartTagInBody(p, token);
      } else if (tn === $.OPTION) {
        optgroupStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    case 7:
      if (tn === $.BGSOUND) {
        startTagInHead(p, token);
      } else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY) {
        addressStartTagInBody(p, token);
      } else if (tn === $.LISTING) {
        preStartTagInBody(p, token);
      } else if (tn === $.MARQUEE) {
        appletStartTagInBody(p, token);
      } else if (tn === $.NOEMBED) {
        noembedStartTagInBody(p, token);
      } else if (tn !== $.CAPTION) {
        genericStartTagInBody(p, token);
      }
      break;
    case 8:
      if (tn === $.BASEFONT) {
        startTagInHead(p, token);
      } else if (tn === $.FRAMESET) {
        framesetStartTagInBody(p, token);
      } else if (tn === $.FIELDSET) {
        addressStartTagInBody(p, token);
      } else if (tn === $.TEXTAREA) {
        textareaStartTagInBody(p, token);
      } else if (tn === $.TEMPLATE) {
        startTagInHead(p, token);
      } else if (tn === $.NOSCRIPT) {
        if (p.options.scriptingEnabled) {
          noembedStartTagInBody(p, token);
        } else {
          genericStartTagInBody(p, token);
        }
      } else if (tn === $.OPTGROUP) {
        optgroupStartTagInBody(p, token);
      } else if (tn !== $.COLGROUP) {
        genericStartTagInBody(p, token);
      }
      break;
    case 9:
      if (tn === $.PLAINTEXT) {
        plaintextStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    case 10:
      if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
        addressStartTagInBody(p, token);
      } else {
        genericStartTagInBody(p, token);
      }
      break;
    default:
      genericStartTagInBody(p, token);
  }
}
function bodyEndTagInBody(p) {
  if (p.openElements.hasInScope($.BODY)) {
    p.insertionMode = AFTER_BODY_MODE;
  }
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope($.BODY)) {
    p.insertionMode = AFTER_BODY_MODE;
    p._processToken(token);
  }
}
function addressEndTagInBody(p, token) {
  const tn = token.tagName;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const formElement = p.formElement;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped($.FORM);
    } else {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope($.P)) {
    p._insertFakeElement($.P);
  }
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope($.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion($.LI);
    p.openElements.popUntilTagNamePopped($.LI);
  }
}
function ddEndTagInBody(p, token) {
  const tn = token.tagName;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  const tn = token.tagName;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement($.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  const tn = token.tagName;
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getTagName(element) === tn) {
      p.openElements.generateImpliedEndTagsWithExclusion(tn);
      p.openElements.popUntilElementPopped(element);
      break;
    }
    if (p._isSpecialElement(element)) {
      break;
    }
  }
}

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function endTagInBody(p, token) {
  const tn = token.tagName;
  switch (tn.length) {
    case 1:
      if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
        callAdoptionAgency(p, token);
      } else if (tn === $.P) {
        pEndTagInBody(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 2:
      if (tn === $.DL || tn === $.UL || tn === $.OL) {
        addressEndTagInBody(p, token);
      } else if (tn === $.LI) {
        liEndTagInBody(p, token);
      } else if (tn === $.DD || tn === $.DT) {
        ddEndTagInBody(p, token);
      } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
        numberedHeaderEndTagInBody(p, token);
      } else if (tn === $.BR) {
        brEndTagInBody(p, token);
      } else if (tn === $.EM || tn === $.TT) {
        callAdoptionAgency(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 3:
      if (tn === $.BIG) {
        callAdoptionAgency(p, token);
      } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
        addressEndTagInBody(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 4:
      if (tn === $.BODY) {
        bodyEndTagInBody(p, token);
      } else if (tn === $.HTML) {
        htmlEndTagInBody(p, token);
      } else if (tn === $.FORM) {
        formEndTagInBody(p, token);
      } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
        callAdoptionAgency(p, token);
      } else if (tn === $.MAIN || tn === $.MENU) {
        addressEndTagInBody(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 5:
      if (tn === $.ASIDE) {
        addressEndTagInBody(p, token);
      } else if (tn === $.SMALL) {
        callAdoptionAgency(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 6:
      if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
        addressEndTagInBody(p, token);
      } else if (tn === $.APPLET || tn === $.OBJECT) {
        appletEndTagInBody(p, token);
      } else if (tn === $.STRIKE || tn === $.STRONG) {
        callAdoptionAgency(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 7:
      if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY || tn === $.LISTING) {
        addressEndTagInBody(p, token);
      } else if (tn === $.MARQUEE) {
        appletEndTagInBody(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 8:
      if (tn === $.FIELDSET) {
        addressEndTagInBody(p, token);
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    case 10:
      if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
        addressEndTagInBody(p, token);
      } else {
        genericEndTagInBody(p, token);
      }
      break;
    default:
      genericEndTagInBody(p, token);
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStackTop > -1) {
    eofInTemplate(p, token);
  } else {
    p.stopped = true;
  }
}

// The "text" insertion mode
//------------------------------------------------------------------
function endTagInText(p, token) {
  if (token.tagName === $.SCRIPT) {
    p.pendingScript = p.openElements.current;
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p._err(ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}

// The "in table" insertion mode
//------------------------------------------------------------------
function characterInTable(p, token) {
  const curTn = p.openElements.currentTagName;
  if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
    p.pendingCharacterTokens = [];
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = IN_TABLE_TEXT_MODE;
    p._processToken(token);
  } else {
    tokenInTable(p, token);
  }
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS.HTML);
  p.insertionMode = IN_CAPTION_MODE;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = IN_COLUMN_GROUP_MODE;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement($.COLGROUP);
  p.insertionMode = IN_COLUMN_GROUP_MODE;
  p._processToken(token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS.HTML);
  p.insertionMode = IN_TABLE_BODY_MODE;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement($.TBODY);
  p.insertionMode = IN_TABLE_BODY_MODE;
  p._processToken(token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope($.TABLE)) {
    p.openElements.popUntilTagNamePopped($.TABLE);
    p._resetInsertionMode();
    p._processToken(token);
  }
}
function inputStartTagInTable(p, token) {
  const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
  if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
    p._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  const tn = token.tagName;
  switch (tn.length) {
    case 2:
      if (tn === $.TD || tn === $.TH || tn === $.TR) {
        tdStartTagInTable(p, token);
      } else {
        tokenInTable(p, token);
      }
      break;
    case 3:
      if (tn === $.COL) {
        colStartTagInTable(p, token);
      } else {
        tokenInTable(p, token);
      }
      break;
    case 4:
      if (tn === $.FORM) {
        formStartTagInTable(p, token);
      } else {
        tokenInTable(p, token);
      }
      break;
    case 5:
      if (tn === $.TABLE) {
        tableStartTagInTable(p, token);
      } else if (tn === $.STYLE) {
        startTagInHead(p, token);
      } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        tbodyStartTagInTable(p, token);
      } else if (tn === $.INPUT) {
        inputStartTagInTable(p, token);
      } else {
        tokenInTable(p, token);
      }
      break;
    case 6:
      if (tn === $.SCRIPT) {
        startTagInHead(p, token);
      } else {
        tokenInTable(p, token);
      }
      break;
    case 7:
      if (tn === $.CAPTION) {
        captionStartTagInTable(p, token);
      } else {
        tokenInTable(p, token);
      }
      break;
    case 8:
      if (tn === $.COLGROUP) {
        colgroupStartTagInTable(p, token);
      } else if (tn === $.TEMPLATE) {
        startTagInHead(p, token);
      } else {
        tokenInTable(p, token);
      }
      break;
    default:
      tokenInTable(p, token);
  }
}
function endTagInTable(p, token) {
  const tn = token.tagName;
  if (tn === $.TABLE) {
    if (p.openElements.hasInTableScope($.TABLE)) {
      p.openElements.popUntilTagNamePopped($.TABLE);
      p._resetInsertionMode();
    }
  } else if (tn === $.TEMPLATE) {
    endTagInHead(p, token);
  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
    tokenInTable(p, token);
  }
}
function tokenInTable(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  p._processTokenInBodyMode(token);
  p.fosterParentingEnabled = savedFosterParentingState;
}

// The "in table text" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  let i = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i < p.pendingCharacterTokens.length; i++) {
      tokenInTable(p, p.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p.pendingCharacterTokens.length; i++) {
      p._insertCharacters(p.pendingCharacterTokens[i]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}

// The "in caption" insertion mode
//------------------------------------------------------------------
function startTagInCaption(p, token) {
  const tn = token.tagName;
  if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
    if (p.openElements.hasInTableScope($.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped($.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = IN_TABLE_MODE;
      p._processToken(token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCaption(p, token) {
  const tn = token.tagName;
  if (tn === $.CAPTION || tn === $.TABLE) {
    if (p.openElements.hasInTableScope($.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped($.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = IN_TABLE_MODE;
      if (tn === $.TABLE) {
        p._processToken(token);
      }
    }
  } else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
    endTagInBody(p, token);
  }
}

// The "in column group" insertion mode
//------------------------------------------------------------------
function startTagInColumnGroup(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.COL) {
    p._appendElement(token, NS.HTML);
    token.ackSelfClosing = true;
  } else if (tn === $.TEMPLATE) {
    startTagInHead(p, token);
  } else {
    tokenInColumnGroup(p, token);
  }
}
function endTagInColumnGroup(p, token) {
  const tn = token.tagName;
  if (tn === $.COLGROUP) {
    if (p.openElements.currentTagName === $.COLGROUP) {
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
    }
  } else if (tn === $.TEMPLATE) {
    endTagInHead(p, token);
  } else if (tn !== $.COL) {
    tokenInColumnGroup(p, token);
  }
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagName === $.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = IN_TABLE_MODE;
    p._processToken(token);
  }
}

// The "in table body" insertion mode
//------------------------------------------------------------------
function startTagInTableBody(p, token) {
  const tn = token.tagName;
  if (tn === $.TR) {
    p.openElements.clearBackToTableBodyContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_ROW_MODE;
  } else if (tn === $.TH || tn === $.TD) {
    p.openElements.clearBackToTableBodyContext();
    p._insertFakeElement($.TR);
    p.insertionMode = IN_ROW_MODE;
    p._processToken(token);
  } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
    if (p.openElements.hasTableBodyContextInTableScope()) {
      p.openElements.clearBackToTableBodyContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
      p._processToken(token);
    }
  } else {
    startTagInTable(p, token);
  }
}
function endTagInTableBody(p, token) {
  const tn = token.tagName;
  if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.clearBackToTableBodyContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
    }
  } else if (tn === $.TABLE) {
    if (p.openElements.hasTableBodyContextInTableScope()) {
      p.openElements.clearBackToTableBodyContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
      p._processToken(token);
    }
  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR) {
    endTagInTable(p, token);
  }
}

// The "in row" insertion mode
//------------------------------------------------------------------
function startTagInRow(p, token) {
  const tn = token.tagName;
  if (tn === $.TH || tn === $.TD) {
    p.openElements.clearBackToTableRowContext();
    p._insertElement(token, NS.HTML);
    p.insertionMode = IN_CELL_MODE;
    p.activeFormattingElements.insertMarker();
  } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
    if (p.openElements.hasInTableScope($.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
      p._processToken(token);
    }
  } else {
    startTagInTable(p, token);
  }
}
function endTagInRow(p, token) {
  const tn = token.tagName;
  if (tn === $.TR) {
    if (p.openElements.hasInTableScope($.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
    }
  } else if (tn === $.TABLE) {
    if (p.openElements.hasInTableScope($.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
      p._processToken(token);
    }
  } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
    if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
      p._processToken(token);
    }
  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH) {
    endTagInTable(p, token);
  }
}

// The "in cell" insertion mode
//------------------------------------------------------------------
function startTagInCell(p, token) {
  const tn = token.tagName;
  if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
    if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {
      p._closeTableCell();
      p._processToken(token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCell(p, token) {
  const tn = token.tagName;
  if (tn === $.TD || tn === $.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(tn);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = IN_ROW_MODE;
    }
  } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
    if (p.openElements.hasInTableScope(tn)) {
      p._closeTableCell();
      p._processToken(token);
    }
  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {
    endTagInBody(p, token);
  }
}

// The "in select" insertion mode
//------------------------------------------------------------------
function startTagInSelect(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.OPTION) {
    if (p.openElements.currentTagName === $.OPTION) {
      p.openElements.pop();
    }
    p._insertElement(token, NS.HTML);
  } else if (tn === $.OPTGROUP) {
    if (p.openElements.currentTagName === $.OPTION) {
      p.openElements.pop();
    }
    if (p.openElements.currentTagName === $.OPTGROUP) {
      p.openElements.pop();
    }
    p._insertElement(token, NS.HTML);
  } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
    if (p.openElements.hasInSelectScope($.SELECT)) {
      p.openElements.popUntilTagNamePopped($.SELECT);
      p._resetInsertionMode();
      if (tn !== $.SELECT) {
        p._processToken(token);
      }
    }
  } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
    startTagInHead(p, token);
  }
}
function endTagInSelect(p, token) {
  const tn = token.tagName;
  if (tn === $.OPTGROUP) {
    const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];
    const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);
    if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
      p.openElements.pop();
    }
    if (p.openElements.currentTagName === $.OPTGROUP) {
      p.openElements.pop();
    }
  } else if (tn === $.OPTION) {
    if (p.openElements.currentTagName === $.OPTION) {
      p.openElements.pop();
    }
  } else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {
    p.openElements.popUntilTagNamePopped($.SELECT);
    p._resetInsertionMode();
  } else if (tn === $.TEMPLATE) {
    endTagInHead(p, token);
  }
}

//12.2.5.4.17 The "in select in table" insertion mode
//------------------------------------------------------------------
function startTagInSelectInTable(p, token) {
  const tn = token.tagName;
  if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
    p.openElements.popUntilTagNamePopped($.SELECT);
    p._resetInsertionMode();
    p._processToken(token);
  } else {
    startTagInSelect(p, token);
  }
}
function endTagInSelectInTable(p, token) {
  const tn = token.tagName;
  if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped($.SELECT);
      p._resetInsertionMode();
      p._processToken(token);
    }
  } else {
    endTagInSelect(p, token);
  }
}

// The "in template" insertion mode
//------------------------------------------------------------------
function startTagInTemplate(p, token) {
  const tn = token.tagName;
  if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
    startTagInHead(p, token);
  } else {
    const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
    p._popTmplInsertionMode();
    p._pushTmplInsertionMode(newInsertionMode);
    p.insertionMode = newInsertionMode;
    p._processToken(token);
  }
}
function endTagInTemplate(p, token) {
  if (token.tagName === $.TEMPLATE) {
    endTagInHead(p, token);
  }
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped($.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p._popTmplInsertionMode();
    p._resetInsertionMode();
    p._processToken(token);
  } else {
    p.stopped = true;
  }
}

// The "after body" insertion mode
//------------------------------------------------------------------
function startTagAfterBody(p, token) {
  if (token.tagName === $.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterBody(p, token);
  }
}
function endTagAfterBody(p, token) {
  if (token.tagName === $.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = AFTER_AFTER_BODY_MODE;
    }
  } else {
    tokenAfterBody(p, token);
  }
}
function tokenAfterBody(p, token) {
  p.insertionMode = IN_BODY_MODE;
  p._processToken(token);
}

// The "in frameset" insertion mode
//------------------------------------------------------------------
function startTagInFrameset(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.FRAMESET) {
    p._insertElement(token, NS.HTML);
  } else if (tn === $.FRAME) {
    p._appendElement(token, NS.HTML);
    token.ackSelfClosing = true;
  } else if (tn === $.NOFRAMES) {
    startTagInHead(p, token);
  }
}
function endTagInFrameset(p, token) {
  if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET) {
      p.insertionMode = AFTER_FRAMESET_MODE;
    }
  }
}

// The "after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterFrameset(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.NOFRAMES) {
    startTagInHead(p, token);
  }
}
function endTagAfterFrameset(p, token) {
  if (token.tagName === $.HTML) {
    p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
  }
}

// The "after after body" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterBody(p, token) {
  if (token.tagName === $.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterAfterBody(p, token);
  }
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = IN_BODY_MODE;
  p._processToken(token);
}

// The "after after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterFrameset(p, token) {
  const tn = token.tagName;
  if (tn === $.HTML) {
    startTagInBody(p, token);
  } else if (tn === $.NOFRAMES) {
    startTagInHead(p, token);
  }
}

// The rules for parsing tokens in foreign content
//------------------------------------------------------------------
function nullCharacterInForeignContent(p, token) {
  token.chars = unicode.REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function startTagInForeignContent(p, token) {
  if (foreignContent.causesExit(token) && !p.fragmentContext) {
    while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.current)) {
      p.openElements.pop();
    }
    p._processToken(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      foreignContent.adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      foreignContent.adjustTokenSVGTagName(token);
      foreignContent.adjustTokenSVGAttrs(token);
    }
    foreignContent.adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p, token) {
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
      p._processToken(token);
      break;
    }
    if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {
      p.openElements.popUntilElementPopped(element);
      break;
    }
  }
}

/***/ }),

/***/ 5795:
/*!************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/parser/open-element-stack.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const HTML = __webpack_require__(/*! ../common/html */ 39604);

//Aliases
const $ = HTML.TAG_NAMES;
const NS = HTML.NAMESPACES;

//Element utils

//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.
//It's faster than using dictionary.
function isImpliedEndTagRequired(tn) {
  switch (tn.length) {
    case 1:
      return tn === $.P;
    case 2:
      return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;
    case 3:
      return tn === $.RTC;
    case 6:
      return tn === $.OPTION;
    case 8:
      return tn === $.OPTGROUP;
  }
  return false;
}
function isImpliedEndTagRequiredThoroughly(tn) {
  switch (tn.length) {
    case 1:
      return tn === $.P;
    case 2:
      return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI || tn === $.TD || tn === $.TH || tn === $.TR;
    case 3:
      return tn === $.RTC;
    case 5:
      return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;
    case 6:
      return tn === $.OPTION;
    case 7:
      return tn === $.CAPTION;
    case 8:
      return tn === $.OPTGROUP || tn === $.COLGROUP;
  }
  return false;
}
function isScopingElement(tn, ns) {
  switch (tn.length) {
    case 2:
      if (tn === $.TD || tn === $.TH) {
        return ns === NS.HTML;
      } else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {
        return ns === NS.MATHML;
      }
      break;
    case 4:
      if (tn === $.HTML) {
        return ns === NS.HTML;
      } else if (tn === $.DESC) {
        return ns === NS.SVG;
      }
      break;
    case 5:
      if (tn === $.TABLE) {
        return ns === NS.HTML;
      } else if (tn === $.MTEXT) {
        return ns === NS.MATHML;
      } else if (tn === $.TITLE) {
        return ns === NS.SVG;
      }
      break;
    case 6:
      return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;
    case 7:
      return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;
    case 8:
      return tn === $.TEMPLATE && ns === NS.HTML;
    case 13:
      return tn === $.FOREIGN_OBJECT && ns === NS.SVG;
    case 14:
      return tn === $.ANNOTATION_XML && ns === NS.MATHML;
  }
  return false;
}

//Stack of open elements
class OpenElementStack {
  constructor(document, treeAdapter) {
    this.stackTop = -1;
    this.items = [];
    this.current = document;
    this.currentTagName = null;
    this.currentTmplContent = null;
    this.tmplCount = 0;
    this.treeAdapter = treeAdapter;
  }

  //Index of element
  _indexOf(element) {
    let idx = -1;
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.items[i] === element) {
        idx = i;
        break;
      }
    }
    return idx;
  }

  //Update current element
  _isInTemplate() {
    return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
    this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
  }

  //Mutations
  push(element) {
    this.items[++this.stackTop] = element;
    this._updateCurrentElement();
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
  }
  pop() {
    this.stackTop--;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this._updateCurrentElement();
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this._updateCurrentElement();
    }
  }
  insertAfter(referenceElement, newElement) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    if (insertionIdx === ++this.stackTop) {
      this._updateCurrentElement();
    }
  }
  popUntilTagNamePopped(tagName) {
    while (this.stackTop > -1) {
      const tn = this.currentTagName;
      const ns = this.treeAdapter.getNamespaceURI(this.current);
      this.pop();
      if (tn === tagName && ns === NS.HTML) {
        break;
      }
    }
  }
  popUntilElementPopped(element) {
    while (this.stackTop > -1) {
      const poppedElement = this.current;
      this.pop();
      if (poppedElement === element) {
        break;
      }
    }
  }
  popUntilNumberedHeaderPopped() {
    while (this.stackTop > -1) {
      const tn = this.currentTagName;
      const ns = this.treeAdapter.getNamespaceURI(this.current);
      this.pop();
      if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6 && ns === NS.HTML) {
        break;
      }
    }
  }
  popUntilTableCellPopped() {
    while (this.stackTop > -1) {
      const tn = this.currentTagName;
      const ns = this.treeAdapter.getNamespaceURI(this.current);
      this.pop();
      if (tn === $.TD || tn === $.TH && ns === NS.HTML) {
        break;
      }
    }
  }
  popAllUpToHtmlElement() {
    //NOTE: here we assume that root <html> element is always first in the open element stack, so
    //we perform this fast stack clean up.
    this.stackTop = 0;
    this._updateCurrentElement();
  }
  clearBackToTableContext() {
    while (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {
      this.pop();
    }
  }
  clearBackToTableBodyContext() {
    while (this.currentTagName !== $.TBODY && this.currentTagName !== $.TFOOT && this.currentTagName !== $.THEAD && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {
      this.pop();
    }
  }
  clearBackToTableRowContext() {
    while (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML) {
      this.pop();
    }
  }
  remove(element) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.items[i] === element) {
        this.items.splice(i, 1);
        this.stackTop--;
        this._updateCurrentElement();
        break;
      }
    }
  }

  //Search
  tryPeekProperlyNestedBodyElement() {
    //Properly nested <body> element (should be second element in stack).
    const element = this.items[1];
    return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;
  }
  contains(element) {
    return this._indexOf(element) > -1;
  }
  getCommonAncestor(element) {
    let elementIdx = this._indexOf(element);
    return --elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.currentTagName === $.HTML;
  }

  //Element in scope
  hasInScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.treeAdapter.getTagName(this.items[i]);
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (isScopingElement(tn, ns)) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.treeAdapter.getTagName(this.items[i]);
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if ((tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) && ns === NS.HTML) {
        return true;
      }
      if (isScopingElement(tn, ns)) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.treeAdapter.getTagName(this.items[i]);
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if ((tn === $.UL || tn === $.OL) && ns === NS.HTML || isScopingElement(tn, ns)) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.treeAdapter.getTagName(this.items[i]);
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (tn === tagName && ns === NS.HTML) {
        return true;
      }
      if (tn === $.BUTTON && ns === NS.HTML || isScopingElement(tn, ns)) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.treeAdapter.getTagName(this.items[i]);
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.treeAdapter.getTagName(this.items[i]);
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {
        return true;
      }
      if (tn === $.TABLE || tn === $.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.treeAdapter.getTagName(this.items[i]);
      const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
      if (ns !== NS.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== $.OPTION && tn !== $.OPTGROUP) {
        return false;
      }
    }
    return true;
  }

  //Implied end tags
  generateImpliedEndTags() {
    while (isImpliedEndTagRequired(this.currentTagName)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionTagName) {
    while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
      this.pop();
    }
  }
}
module.exports = OpenElementStack;

/***/ }),

/***/ 64620:
/*!***************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/serializer/index.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const defaultTreeAdapter = __webpack_require__(/*! ../tree-adapters/default */ 80382);
const mergeOptions = __webpack_require__(/*! ../utils/merge-options */ 34378);
const doctype = __webpack_require__(/*! ../common/doctype */ 29059);
const HTML = __webpack_require__(/*! ../common/html */ 39604);

//Aliases
const $ = HTML.TAG_NAMES;
const NS = HTML.NAMESPACES;

//Default serializer options
const DEFAULT_OPTIONS = {
  treeAdapter: defaultTreeAdapter
};

//Escaping regexes
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;

//Serializer
class Serializer {
  constructor(node, options) {
    this.options = mergeOptions(DEFAULT_OPTIONS, options);
    this.treeAdapter = this.options.treeAdapter;
    this.html = '';
    this.startNode = node;
  }

  //API
  serialize() {
    this._serializeChildNodes(this.startNode);
    return this.html;
  }

  //Internals
  _serializeChildNodes(parentNode) {
    const childNodes = this.treeAdapter.getChildNodes(parentNode);
    if (childNodes) {
      for (let i = 0, cnLength = childNodes.length; i < cnLength; i++) {
        const currentNode = childNodes[i];
        if (this.treeAdapter.isElementNode(currentNode)) {
          this._serializeElement(currentNode);
        } else if (this.treeAdapter.isTextNode(currentNode)) {
          this._serializeTextNode(currentNode);
        } else if (this.treeAdapter.isCommentNode(currentNode)) {
          this._serializeCommentNode(currentNode);
        } else if (this.treeAdapter.isDocumentTypeNode(currentNode)) {
          this._serializeDocumentTypeNode(currentNode);
        }
      }
    }
  }
  _serializeElement(node) {
    const tn = this.treeAdapter.getTagName(node);
    const ns = this.treeAdapter.getNamespaceURI(node);
    this.html += '<' + tn;
    this._serializeAttributes(node);
    this.html += '>';
    if (tn !== $.AREA && tn !== $.BASE && tn !== $.BASEFONT && tn !== $.BGSOUND && tn !== $.BR && tn !== $.COL && tn !== $.EMBED && tn !== $.FRAME && tn !== $.HR && tn !== $.IMG && tn !== $.INPUT && tn !== $.KEYGEN && tn !== $.LINK && tn !== $.META && tn !== $.PARAM && tn !== $.SOURCE && tn !== $.TRACK && tn !== $.WBR) {
      const childNodesHolder = tn === $.TEMPLATE && ns === NS.HTML ? this.treeAdapter.getTemplateContent(node) : node;
      this._serializeChildNodes(childNodesHolder);
      this.html += '</' + tn + '>';
    }
  }
  _serializeAttributes(node) {
    const attrs = this.treeAdapter.getAttrList(node);
    for (let i = 0, attrsLength = attrs.length; i < attrsLength; i++) {
      const attr = attrs[i];
      const value = Serializer.escapeString(attr.value, true);
      this.html += ' ';
      if (!attr.namespace) {
        this.html += attr.name;
      } else if (attr.namespace === NS.XML) {
        this.html += 'xml:' + attr.name;
      } else if (attr.namespace === NS.XMLNS) {
        if (attr.name !== 'xmlns') {
          this.html += 'xmlns:';
        }
        this.html += attr.name;
      } else if (attr.namespace === NS.XLINK) {
        this.html += 'xlink:' + attr.name;
      } else {
        this.html += attr.prefix + ':' + attr.name;
      }
      this.html += '="' + value + '"';
    }
  }
  _serializeTextNode(node) {
    const content = this.treeAdapter.getTextNodeContent(node);
    const parent = this.treeAdapter.getParentNode(node);
    let parentTn = void 0;
    if (parent && this.treeAdapter.isElementNode(parent)) {
      parentTn = this.treeAdapter.getTagName(parent);
    }
    if (parentTn === $.STYLE || parentTn === $.SCRIPT || parentTn === $.XMP || parentTn === $.IFRAME || parentTn === $.NOEMBED || parentTn === $.NOFRAMES || parentTn === $.PLAINTEXT || parentTn === $.NOSCRIPT) {
      this.html += content;
    } else {
      this.html += Serializer.escapeString(content, false);
    }
  }
  _serializeCommentNode(node) {
    this.html += '<!--' + this.treeAdapter.getCommentNodeContent(node) + '-->';
  }
  _serializeDocumentTypeNode(node) {
    const name = this.treeAdapter.getDocumentTypeNodeName(node);
    this.html += '<' + doctype.serializeContent(name, null, null) + '>';
  }
}

// NOTE: used in tests and by rewriting stream
Serializer.escapeString = function (str, attrMode) {
  str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');
  if (attrMode) {
    str = str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
  } else {
    str = str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
  }
  return str;
};
module.exports = Serializer;

/***/ }),

/***/ 9285:
/*!**************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/tokenizer/index.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const Preprocessor = __webpack_require__(/*! ./preprocessor */ 43938);
const unicode = __webpack_require__(/*! ../common/unicode */ 84382);
const neTree = __webpack_require__(/*! ./named-entity-data */ 22555);
const ERR = __webpack_require__(/*! ../common/error-codes */ 63136);

//Aliases
const $ = unicode.CODE_POINTS;
const $$ = unicode.CODE_POINT_SEQUENCES;

//C1 Unicode control character reference replacements
const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
  0x80: 0x20ac,
  0x82: 0x201a,
  0x83: 0x0192,
  0x84: 0x201e,
  0x85: 0x2026,
  0x86: 0x2020,
  0x87: 0x2021,
  0x88: 0x02c6,
  0x89: 0x2030,
  0x8a: 0x0160,
  0x8b: 0x2039,
  0x8c: 0x0152,
  0x8e: 0x017d,
  0x91: 0x2018,
  0x92: 0x2019,
  0x93: 0x201c,
  0x94: 0x201d,
  0x95: 0x2022,
  0x96: 0x2013,
  0x97: 0x2014,
  0x98: 0x02dc,
  0x99: 0x2122,
  0x9a: 0x0161,
  0x9b: 0x203a,
  0x9c: 0x0153,
  0x9e: 0x017e,
  0x9f: 0x0178
};

// Named entity tree flags
const HAS_DATA_FLAG = 1 << 0;
const DATA_DUPLET_FLAG = 1 << 1;
const HAS_BRANCHES_FLAG = 1 << 2;
const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;

//States
const DATA_STATE = 'DATA_STATE';
const RCDATA_STATE = 'RCDATA_STATE';
const RAWTEXT_STATE = 'RAWTEXT_STATE';
const SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';
const PLAINTEXT_STATE = 'PLAINTEXT_STATE';
const TAG_OPEN_STATE = 'TAG_OPEN_STATE';
const END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';
const TAG_NAME_STATE = 'TAG_NAME_STATE';
const RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';
const RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';
const RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';
const RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';
const RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';
const RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';
const SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';
const SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';
const SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';
const SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';
const SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';
const SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';
const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';
const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';
const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';
const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';
const BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';
const ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';
const AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';
const BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';
const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';
const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';
const ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';
const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';
const SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';
const BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';
const MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';
const COMMENT_START_STATE = 'COMMENT_START_STATE';
const COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';
const COMMENT_STATE = 'COMMENT_STATE';
const COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';
const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';
const COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';
const COMMENT_END_STATE = 'COMMENT_END_STATE';
const COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';
const DOCTYPE_STATE = 'DOCTYPE_STATE';
const BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';
const DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';
const AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';
const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';
const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';
const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';
const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';
const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';
const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';
const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';
const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
const BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';
const CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';
const CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';
const CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';
const CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';
const NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';
const AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';
const NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';
const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';
const DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';
const HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';
const DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';
const NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';

//Utils

//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isWhitespace(cp) {
  return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;
}
function isAsciiDigit(cp) {
  return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}
function toAsciiLowerCodePoint(cp) {
  return cp + 0x0020;
}

//NOTE: String.fromCharCode() function can handle only characters from BMP subset.
//So, we need to workaround this manually.
//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)
function toChar(cp) {
  if (cp <= 0xffff) {
    return String.fromCharCode(cp);
  }
  cp -= 0x10000;
  return String.fromCharCode(cp >>> 10 & 0x3ff | 0xd800) + String.fromCharCode(0xdc00 | cp & 0x3ff);
}
function toAsciiLowerChar(cp) {
  return String.fromCharCode(toAsciiLowerCodePoint(cp));
}
function findNamedEntityTreeBranch(nodeIx, cp) {
  const branchCount = neTree[++nodeIx];
  let lo = ++nodeIx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midCp = neTree[mid];
    if (midCp < cp) {
      lo = mid + 1;
    } else if (midCp > cp) {
      hi = mid - 1;
    } else {
      return neTree[mid + branchCount];
    }
  }
  return -1;
}

//Tokenizer
class Tokenizer {
  constructor() {
    this.preprocessor = new Preprocessor();
    this.tokenQueue = [];
    this.allowCDATA = false;
    this.state = DATA_STATE;
    this.returnState = '';
    this.charRefCode = -1;
    this.tempBuff = [];
    this.lastStartTagName = '';
    this.consumedAfterSnapshot = -1;
    this.active = false;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = null;
  }

  //Errors
  _err() {
    // NOTE: err reporting is noop by default. Enabled by mixin.
  }
  _errOnNextCodePoint(err) {
    this._consume();
    this._err(err);
    this._unconsume();
  }

  //API
  getNextToken() {
    while (!this.tokenQueue.length && this.active) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this[this.state](cp);
      }
    }
    return this.tokenQueue.shift();
  }
  write(chunk, isLastChunk) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
  }

  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
        this.preprocessor.retreat();
      }
      this.active = false;
      this.tokenQueue.push({
        type: Tokenizer.HIBERNATION_TOKEN
      });
      return true;
    }
    return false;
  }

  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume() {
    this.consumedAfterSnapshot--;
    this.preprocessor.retreat();
  }
  _reconsumeInState(state) {
    this.state = state;
    this._unconsume();
  }
  _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
    let consumedCount = 0;
    let isMatch = true;
    const patternLength = pattern.length;
    let patternPos = 0;
    let cp = startCp;
    let patternCp = void 0;
    for (; patternPos < patternLength; patternPos++) {
      if (patternPos > 0) {
        cp = this._consume();
        consumedCount++;
      }
      if (cp === $.EOF) {
        isMatch = false;
        break;
      }
      patternCp = pattern[patternPos];
      if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
        isMatch = false;
        break;
      }
    }
    if (!isMatch) {
      while (consumedCount--) {
        this._unconsume();
      }
    }
    return isMatch;
  }

  //Temp buffer
  _isTempBufferEqualToScriptString() {
    if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
      return false;
    }
    for (let i = 0; i < this.tempBuff.length; i++) {
      if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {
        return false;
      }
    }
    return true;
  }

  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: Tokenizer.START_TAG_TOKEN,
      tagName: '',
      selfClosing: false,
      ackSelfClosing: false,
      attrs: []
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: Tokenizer.END_TAG_TOKEN,
      tagName: '',
      selfClosing: false,
      attrs: []
    };
  }
  _createCommentToken() {
    this.currentToken = {
      type: Tokenizer.COMMENT_TOKEN,
      data: ''
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: Tokenizer.DOCTYPE_TOKEN,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null
    };
  }
  _createCharacterToken(type, ch) {
    this.currentCharacterToken = {
      type: type,
      chars: ch
    };
  }
  _createEOFToken() {
    this.currentToken = {
      type: Tokenizer.EOF_TOKEN
    };
  }

  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ''
    };
  }
  _leaveAttrName(toState) {
    if (Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
      this.currentToken.attrs.push(this.currentAttr);
    } else {
      this._err(ERR.duplicateAttribute);
    }
    this.state = toState;
  }
  _leaveAttrValue(toState) {
    this.state = toState;
  }

  //Token emission
  _emitCurrentToken() {
    this._emitCurrentCharacterToken();
    const ct = this.currentToken;
    this.currentToken = null;

    //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.
    if (ct.type === Tokenizer.START_TAG_TOKEN) {
      this.lastStartTagName = ct.tagName;
    } else if (ct.type === Tokenizer.END_TAG_TOKEN) {
      if (ct.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
    }
    this.tokenQueue.push(ct);
  }
  _emitCurrentCharacterToken() {
    if (this.currentCharacterToken) {
      this.tokenQueue.push(this.currentCharacterToken);
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    this._createEOFToken();
    this._emitCurrentToken();
  }

  //Characters emission

  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
      this._emitCurrentCharacterToken();
    }
    if (this.currentCharacterToken) {
      this.currentCharacterToken.chars += ch;
    } else {
      this._createCharacterToken(type, ch);
    }
  }
  _emitCodePoint(cp) {
    let type = Tokenizer.CHARACTER_TOKEN;
    if (isWhitespace(cp)) {
      type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;
    } else if (cp === $.NULL) {
      type = Tokenizer.NULL_CHARACTER_TOKEN;
    }
    this._appendCharToCurrentCharacterToken(type, toChar(cp));
  }
  _emitSeveralCodePoints(codePoints) {
    for (let i = 0; i < codePoints.length; i++) {
      this._emitCodePoint(codePoints[i]);
    }
  }

  //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
  //So we can avoid additional checks here.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);
  }

  // Character reference helpers
  _matchNamedCharacterReference(startCp) {
    let result = null;
    let excess = 1;
    let i = findNamedEntityTreeBranch(0, startCp);
    this.tempBuff.push(startCp);
    while (i > -1) {
      const current = neTree[i];
      const inNode = current < MAX_BRANCH_MARKER_VALUE;
      const nodeWithData = inNode && current & HAS_DATA_FLAG;
      if (nodeWithData) {
        //NOTE: we use greedy search, so we continue lookup at this point
        result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];
        excess = 0;
      }
      const cp = this._consume();
      this.tempBuff.push(cp);
      excess++;
      if (cp === $.EOF) {
        break;
      }
      if (inNode) {
        i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;
      } else {
        i = cp === current ? ++i : -1;
      }
    }
    while (excess--) {
      this.tempBuff.pop();
      this._unconsume();
    }
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE;
  }
  _isCharacterReferenceAttributeQuirk(withSemicolon) {
    if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
      const nextCp = this._consume();
      this._unconsume();
      return nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
    }
    return false;
  }
  _flushCodePointsConsumedAsCharacterReference() {
    if (this._isCharacterReferenceInAttribute()) {
      for (let i = 0; i < this.tempBuff.length; i++) {
        this.currentAttr.value += toChar(this.tempBuff[i]);
      }
    } else {
      this._emitSeveralCodePoints(this.tempBuff);
    }
    this.tempBuff = [];
  }

  // State machine

  // Data state
  //------------------------------------------------------------------
  [DATA_STATE](cp) {
    this.preprocessor.dropParsedChunk();
    if (cp === $.LESS_THAN_SIGN) {
      this.state = TAG_OPEN_STATE;
    } else if (cp === $.AMPERSAND) {
      this.returnState = DATA_STATE;
      this.state = CHARACTER_REFERENCE_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._emitCodePoint(cp);
    } else if (cp === $.EOF) {
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  //  RCDATA state
  //------------------------------------------------------------------
  [RCDATA_STATE](cp) {
    this.preprocessor.dropParsedChunk();
    if (cp === $.AMPERSAND) {
      this.returnState = RCDATA_STATE;
      this.state = CHARACTER_REFERENCE_STATE;
    } else if (cp === $.LESS_THAN_SIGN) {
      this.state = RCDATA_LESS_THAN_SIGN_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  // RAWTEXT state
  //------------------------------------------------------------------
  [RAWTEXT_STATE](cp) {
    this.preprocessor.dropParsedChunk();
    if (cp === $.LESS_THAN_SIGN) {
      this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  // Script data state
  //------------------------------------------------------------------
  [SCRIPT_DATA_STATE](cp) {
    this.preprocessor.dropParsedChunk();
    if (cp === $.LESS_THAN_SIGN) {
      this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  // PLAINTEXT state
  //------------------------------------------------------------------
  [PLAINTEXT_STATE](cp) {
    this.preprocessor.dropParsedChunk();
    if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  // Tag open state
  //------------------------------------------------------------------
  [TAG_OPEN_STATE](cp) {
    if (cp === $.EXCLAMATION_MARK) {
      this.state = MARKUP_DECLARATION_OPEN_STATE;
    } else if (cp === $.SOLIDUS) {
      this.state = END_TAG_OPEN_STATE;
    } else if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this._reconsumeInState(TAG_NAME_STATE);
    } else if (cp === $.QUESTION_MARK) {
      this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
      this._createCommentToken();
      this._reconsumeInState(BOGUS_COMMENT_STATE);
    } else if (cp === $.EOF) {
      this._err(ERR.eofBeforeTagName);
      this._emitChars('<');
      this._emitEOFToken();
    } else {
      this._err(ERR.invalidFirstCharacterOfTagName);
      this._emitChars('<');
      this._reconsumeInState(DATA_STATE);
    }
  }

  // End tag open state
  //------------------------------------------------------------------
  [END_TAG_OPEN_STATE](cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this._reconsumeInState(TAG_NAME_STATE);
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.missingEndTagName);
      this.state = DATA_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofBeforeTagName);
      this._emitChars('</');
      this._emitEOFToken();
    } else {
      this._err(ERR.invalidFirstCharacterOfTagName);
      this._createCommentToken();
      this._reconsumeInState(BOGUS_COMMENT_STATE);
    }
  }

  // Tag name state
  //------------------------------------------------------------------
  [TAG_NAME_STATE](cp) {
    if (isWhitespace(cp)) {
      this.state = BEFORE_ATTRIBUTE_NAME_STATE;
    } else if (cp === $.SOLIDUS) {
      this.state = SELF_CLOSING_START_TAG_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (isAsciiUpper(cp)) {
      this.currentToken.tagName += toAsciiLowerChar(cp);
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.tagName += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInTag);
      this._emitEOFToken();
    } else {
      this.currentToken.tagName += toChar(cp);
    }
  }

  // RCDATA less-than sign state
  //------------------------------------------------------------------
  [RCDATA_LESS_THAN_SIGN_STATE](cp) {
    if (cp === $.SOLIDUS) {
      this.tempBuff = [];
      this.state = RCDATA_END_TAG_OPEN_STATE;
    } else {
      this._emitChars('<');
      this._reconsumeInState(RCDATA_STATE);
    }
  }

  // RCDATA end tag open state
  //------------------------------------------------------------------
  [RCDATA_END_TAG_OPEN_STATE](cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
    } else {
      this._emitChars('</');
      this._reconsumeInState(RCDATA_STATE);
    }
  }

  // RCDATA end tag name state
  //------------------------------------------------------------------
  [RCDATA_END_TAG_NAME_STATE](cp) {
    if (isAsciiUpper(cp)) {
      this.currentToken.tagName += toAsciiLowerChar(cp);
      this.tempBuff.push(cp);
    } else if (isAsciiLower(cp)) {
      this.currentToken.tagName += toChar(cp);
      this.tempBuff.push(cp);
    } else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
          return;
        }
        if (cp === $.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
          return;
        }
        if (cp === $.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
          return;
        }
      }
      this._emitChars('</');
      this._emitSeveralCodePoints(this.tempBuff);
      this._reconsumeInState(RCDATA_STATE);
    }
  }

  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
    if (cp === $.SOLIDUS) {
      this.tempBuff = [];
      this.state = RAWTEXT_END_TAG_OPEN_STATE;
    } else {
      this._emitChars('<');
      this._reconsumeInState(RAWTEXT_STATE);
    }
  }

  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  [RAWTEXT_END_TAG_OPEN_STATE](cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
    } else {
      this._emitChars('</');
      this._reconsumeInState(RAWTEXT_STATE);
    }
  }

  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  [RAWTEXT_END_TAG_NAME_STATE](cp) {
    if (isAsciiUpper(cp)) {
      this.currentToken.tagName += toAsciiLowerChar(cp);
      this.tempBuff.push(cp);
    } else if (isAsciiLower(cp)) {
      this.currentToken.tagName += toChar(cp);
      this.tempBuff.push(cp);
    } else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
          return;
        }
        if (cp === $.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
          return;
        }
        if (cp === $.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
          return;
        }
      }
      this._emitChars('</');
      this._emitSeveralCodePoints(this.tempBuff);
      this._reconsumeInState(RAWTEXT_STATE);
    }
  }

  // Script data less-than sign state
  //------------------------------------------------------------------
  [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
    if (cp === $.SOLIDUS) {
      this.tempBuff = [];
      this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
    } else if (cp === $.EXCLAMATION_MARK) {
      this.state = SCRIPT_DATA_ESCAPE_START_STATE;
      this._emitChars('<!');
    } else {
      this._emitChars('<');
      this._reconsumeInState(SCRIPT_DATA_STATE);
    }
  }

  // Script data end tag open state
  //------------------------------------------------------------------
  [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
    } else {
      this._emitChars('</');
      this._reconsumeInState(SCRIPT_DATA_STATE);
    }
  }

  // Script data end tag name state
  //------------------------------------------------------------------
  [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
    if (isAsciiUpper(cp)) {
      this.currentToken.tagName += toAsciiLowerChar(cp);
      this.tempBuff.push(cp);
    } else if (isAsciiLower(cp)) {
      this.currentToken.tagName += toChar(cp);
      this.tempBuff.push(cp);
    } else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
          return;
        } else if (cp === $.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
          return;
        } else if (cp === $.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
          return;
        }
      }
      this._emitChars('</');
      this._emitSeveralCodePoints(this.tempBuff);
      this._reconsumeInState(SCRIPT_DATA_STATE);
    }
  }

  // Script data escape start state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
      this._emitChars('-');
    } else {
      this._reconsumeInState(SCRIPT_DATA_STATE);
    }
  }

  // Script data escape start dash state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
      this._emitChars('-');
    } else {
      this._reconsumeInState(SCRIPT_DATA_STATE);
    }
  }

  // Script data escaped state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPED_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
      this._emitChars('-');
    } else if (cp === $.LESS_THAN_SIGN) {
      this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInScriptHtmlCommentLikeText);
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  // Script data escaped dash state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
      this._emitChars('-');
    } else if (cp === $.LESS_THAN_SIGN) {
      this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.state = SCRIPT_DATA_ESCAPED_STATE;
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInScriptHtmlCommentLikeText);
      this._emitEOFToken();
    } else {
      this.state = SCRIPT_DATA_ESCAPED_STATE;
      this._emitCodePoint(cp);
    }
  }

  // Script data escaped dash dash state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this._emitChars('-');
    } else if (cp === $.LESS_THAN_SIGN) {
      this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this.state = SCRIPT_DATA_STATE;
      this._emitChars('>');
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.state = SCRIPT_DATA_ESCAPED_STATE;
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInScriptHtmlCommentLikeText);
      this._emitEOFToken();
    } else {
      this.state = SCRIPT_DATA_ESCAPED_STATE;
      this._emitCodePoint(cp);
    }
  }

  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
    if (cp === $.SOLIDUS) {
      this.tempBuff = [];
      this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
    } else if (isAsciiLetter(cp)) {
      this.tempBuff = [];
      this._emitChars('<');
      this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
    } else {
      this._emitChars('<');
      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
  }

  // Script data escaped end tag open state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
    } else {
      this._emitChars('</');
      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
  }

  // Script data escaped end tag name state
  //------------------------------------------------------------------
  [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
    if (isAsciiUpper(cp)) {
      this.currentToken.tagName += toAsciiLowerChar(cp);
      this.tempBuff.push(cp);
    } else if (isAsciiLower(cp)) {
      this.currentToken.tagName += toChar(cp);
      this.tempBuff.push(cp);
    } else {
      if (this.lastStartTagName === this.currentToken.tagName) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
          return;
        }
        if (cp === $.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
          return;
        }
        if (cp === $.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
          return;
        }
      }
      this._emitChars('</');
      this._emitSeveralCodePoints(this.tempBuff);
      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
  }

  // Script data double escape start state
  //------------------------------------------------------------------
  [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
      this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
      this._emitCodePoint(cp);
    } else if (isAsciiUpper(cp)) {
      this.tempBuff.push(toAsciiLowerCodePoint(cp));
      this._emitCodePoint(cp);
    } else if (isAsciiLower(cp)) {
      this.tempBuff.push(cp);
      this._emitCodePoint(cp);
    } else {
      this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
    }
  }

  // Script data double escaped state
  //------------------------------------------------------------------
  [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
      this._emitChars('-');
    } else if (cp === $.LESS_THAN_SIGN) {
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
      this._emitChars('<');
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInScriptHtmlCommentLikeText);
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  // Script data double escaped dash state
  //------------------------------------------------------------------
  [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
      this._emitChars('-');
    } else if (cp === $.LESS_THAN_SIGN) {
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
      this._emitChars('<');
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInScriptHtmlCommentLikeText);
      this._emitEOFToken();
    } else {
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
      this._emitCodePoint(cp);
    }
  }

  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this._emitChars('-');
    } else if (cp === $.LESS_THAN_SIGN) {
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
      this._emitChars('<');
    } else if (cp === $.GREATER_THAN_SIGN) {
      this.state = SCRIPT_DATA_STATE;
      this._emitChars('>');
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
      this._emitChars(unicode.REPLACEMENT_CHARACTER);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInScriptHtmlCommentLikeText);
      this._emitEOFToken();
    } else {
      this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
      this._emitCodePoint(cp);
    }
  }

  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
    if (cp === $.SOLIDUS) {
      this.tempBuff = [];
      this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
      this._emitChars('/');
    } else {
      this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
    }
  }

  // Script data double escape end state
  //------------------------------------------------------------------
  [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
      this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
      this._emitCodePoint(cp);
    } else if (isAsciiUpper(cp)) {
      this.tempBuff.push(toAsciiLowerCodePoint(cp));
      this._emitCodePoint(cp);
    } else if (isAsciiLower(cp)) {
      this.tempBuff.push(cp);
      this._emitCodePoint(cp);
    } else {
      this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
    }
  }

  // Before attribute name state
  //------------------------------------------------------------------
  [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
      this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
    } else if (cp === $.EQUALS_SIGN) {
      this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
      this._createAttr('=');
      this.state = ATTRIBUTE_NAME_STATE;
    } else {
      this._createAttr('');
      this._reconsumeInState(ATTRIBUTE_NAME_STATE);
    }
  }

  // Attribute name state
  //------------------------------------------------------------------
  [ATTRIBUTE_NAME_STATE](cp) {
    if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
      this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
      this._unconsume();
    } else if (cp === $.EQUALS_SIGN) {
      this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
    } else if (isAsciiUpper(cp)) {
      this.currentAttr.name += toAsciiLowerChar(cp);
    } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {
      this._err(ERR.unexpectedCharacterInAttributeName);
      this.currentAttr.name += toChar(cp);
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentAttr.name += unicode.REPLACEMENT_CHARACTER;
    } else {
      this.currentAttr.name += toChar(cp);
    }
  }

  // After attribute name state
  //------------------------------------------------------------------
  [AFTER_ATTRIBUTE_NAME_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.SOLIDUS) {
      this.state = SELF_CLOSING_START_TAG_STATE;
    } else if (cp === $.EQUALS_SIGN) {
      this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInTag);
      this._emitEOFToken();
    } else {
      this._createAttr('');
      this._reconsumeInState(ATTRIBUTE_NAME_STATE);
    }
  }

  // Before attribute value state
  //------------------------------------------------------------------
  [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.QUOTATION_MARK) {
      this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
    } else if (cp === $.APOSTROPHE) {
      this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.missingAttributeValue);
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else {
      this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
    }
  }

  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
    if (cp === $.QUOTATION_MARK) {
      this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
    } else if (cp === $.AMPERSAND) {
      this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
      this.state = CHARACTER_REFERENCE_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInTag);
      this._emitEOFToken();
    } else {
      this.currentAttr.value += toChar(cp);
    }
  }

  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
    if (cp === $.APOSTROPHE) {
      this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
    } else if (cp === $.AMPERSAND) {
      this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
      this.state = CHARACTER_REFERENCE_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInTag);
      this._emitEOFToken();
    } else {
      this.currentAttr.value += toChar(cp);
    }
  }

  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
    if (isWhitespace(cp)) {
      this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
    } else if (cp === $.AMPERSAND) {
      this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
      this.state = CHARACTER_REFERENCE_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._leaveAttrValue(DATA_STATE);
      this._emitCurrentToken();
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN || cp === $.EQUALS_SIGN || cp === $.GRAVE_ACCENT) {
      this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
      this.currentAttr.value += toChar(cp);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInTag);
      this._emitEOFToken();
    } else {
      this.currentAttr.value += toChar(cp);
    }
  }

  // After attribute value (quoted) state
  //------------------------------------------------------------------
  [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
    if (isWhitespace(cp)) {
      this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
    } else if (cp === $.SOLIDUS) {
      this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._leaveAttrValue(DATA_STATE);
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInTag);
      this._emitEOFToken();
    } else {
      this._err(ERR.missingWhitespaceBetweenAttributes);
      this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
    }
  }

  // Self-closing start tag state
  //------------------------------------------------------------------
  [SELF_CLOSING_START_TAG_STATE](cp) {
    if (cp === $.GREATER_THAN_SIGN) {
      this.currentToken.selfClosing = true;
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInTag);
      this._emitEOFToken();
    } else {
      this._err(ERR.unexpectedSolidusInTag);
      this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
    }
  }

  // Bogus comment state
  //------------------------------------------------------------------
  [BOGUS_COMMENT_STATE](cp) {
    if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._emitCurrentToken();
      this._emitEOFToken();
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
    } else {
      this.currentToken.data += toChar(cp);
    }
  }

  // Markup declaration open state
  //------------------------------------------------------------------
  [MARKUP_DECLARATION_OPEN_STATE](cp) {
    if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
      this._createCommentToken();
      this.state = COMMENT_START_STATE;
    } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
      this.state = DOCTYPE_STATE;
    } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
      if (this.allowCDATA) {
        this.state = CDATA_SECTION_STATE;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken();
        this.currentToken.data = '[CDATA[';
        this.state = BOGUS_COMMENT_STATE;
      }
    }

    //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
    //results are no longer valid and we will need to start over.
    else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken();
      this._reconsumeInState(BOGUS_COMMENT_STATE);
    }
  }

  // Comment start state
  //------------------------------------------------------------------
  [COMMENT_START_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = COMMENT_START_DASH_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.abruptClosingOfEmptyComment);
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else {
      this._reconsumeInState(COMMENT_STATE);
    }
  }

  // Comment start dash state
  //------------------------------------------------------------------
  [COMMENT_START_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = COMMENT_END_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.abruptClosingOfEmptyComment);
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInComment);
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.data += '-';
      this._reconsumeInState(COMMENT_STATE);
    }
  }

  // Comment state
  //------------------------------------------------------------------
  [COMMENT_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = COMMENT_END_DASH_STATE;
    } else if (cp === $.LESS_THAN_SIGN) {
      this.currentToken.data += '<';
      this.state = COMMENT_LESS_THAN_SIGN_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInComment);
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.data += toChar(cp);
    }
  }

  // Comment less-than sign state
  //------------------------------------------------------------------
  [COMMENT_LESS_THAN_SIGN_STATE](cp) {
    if (cp === $.EXCLAMATION_MARK) {
      this.currentToken.data += '!';
      this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
    } else if (cp === $.LESS_THAN_SIGN) {
      this.currentToken.data += '!';
    } else {
      this._reconsumeInState(COMMENT_STATE);
    }
  }

  // Comment less-than sign bang state
  //------------------------------------------------------------------
  [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
    } else {
      this._reconsumeInState(COMMENT_STATE);
    }
  }

  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
    } else {
      this._reconsumeInState(COMMENT_END_DASH_STATE);
    }
  }

  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
    if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {
      this._err(ERR.nestedComment);
    }
    this._reconsumeInState(COMMENT_END_STATE);
  }

  // Comment end dash state
  //------------------------------------------------------------------
  [COMMENT_END_DASH_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.state = COMMENT_END_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInComment);
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.data += '-';
      this._reconsumeInState(COMMENT_STATE);
    }
  }

  // Comment end state
  //------------------------------------------------------------------
  [COMMENT_END_STATE](cp) {
    if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EXCLAMATION_MARK) {
      this.state = COMMENT_END_BANG_STATE;
    } else if (cp === $.HYPHEN_MINUS) {
      this.currentToken.data += '-';
    } else if (cp === $.EOF) {
      this._err(ERR.eofInComment);
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.data += '--';
      this._reconsumeInState(COMMENT_STATE);
    }
  }

  // Comment end bang state
  //------------------------------------------------------------------
  [COMMENT_END_BANG_STATE](cp) {
    if (cp === $.HYPHEN_MINUS) {
      this.currentToken.data += '--!';
      this.state = COMMENT_END_DASH_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.incorrectlyClosedComment);
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInComment);
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.data += '--!';
      this._reconsumeInState(COMMENT_STATE);
    }
  }

  // DOCTYPE state
  //------------------------------------------------------------------
  [DOCTYPE_STATE](cp) {
    if (isWhitespace(cp)) {
      this.state = BEFORE_DOCTYPE_NAME_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this._createDoctypeToken(null);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.missingWhitespaceBeforeDoctypeName);
      this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
    }
  }

  // Before DOCTYPE name state
  //------------------------------------------------------------------
  [BEFORE_DOCTYPE_NAME_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(toAsciiLowerChar(cp));
      this.state = DOCTYPE_NAME_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this._createDoctypeToken(unicode.REPLACEMENT_CHARACTER);
      this.state = DOCTYPE_NAME_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.missingDoctypeName);
      this._createDoctypeToken(null);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this._createDoctypeToken(null);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._createDoctypeToken(toChar(cp));
      this.state = DOCTYPE_NAME_STATE;
    }
  }

  // DOCTYPE name state
  //------------------------------------------------------------------
  [DOCTYPE_NAME_STATE](cp) {
    if (isWhitespace(cp)) {
      this.state = AFTER_DOCTYPE_NAME_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (isAsciiUpper(cp)) {
      this.currentToken.name += toAsciiLowerChar(cp);
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.name += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.name += toChar(cp);
    }
  }

  // After DOCTYPE name state
  //------------------------------------------------------------------
  [AFTER_DOCTYPE_NAME_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
      this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
    } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
      this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
    }
    //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
    //results are no longer valid and we will need to start over.
    else if (!this._ensureHibernation()) {
      this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
      this.currentToken.forceQuirks = true;
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
    if (isWhitespace(cp)) {
      this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
    } else if (cp === $.QUOTATION_MARK) {
      this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
      this.currentToken.publicId = '';
      this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
    } else if (cp === $.APOSTROPHE) {
      this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
      this.currentToken.publicId = '';
      this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.missingDoctypePublicIdentifier);
      this.currentToken.forceQuirks = true;
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
      this.currentToken.forceQuirks = true;
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.QUOTATION_MARK) {
      this.currentToken.publicId = '';
      this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
    } else if (cp === $.APOSTROPHE) {
      this.currentToken.publicId = '';
      this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.missingDoctypePublicIdentifier);
      this.currentToken.forceQuirks = true;
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
      this.currentToken.forceQuirks = true;
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
    if (cp === $.QUOTATION_MARK) {
      this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.abruptDoctypePublicIdentifier);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.publicId += toChar(cp);
    }
  }

  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
    if (cp === $.APOSTROPHE) {
      this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.abruptDoctypePublicIdentifier);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.publicId += toChar(cp);
    }
  }

  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
    if (isWhitespace(cp)) {
      this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.QUOTATION_MARK) {
      this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    } else if (cp === $.APOSTROPHE) {
      this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.GREATER_THAN_SIGN) {
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.QUOTATION_MARK) {
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    } else if (cp === $.APOSTROPHE) {
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
    if (isWhitespace(cp)) {
      this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
    } else if (cp === $.QUOTATION_MARK) {
      this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    } else if (cp === $.APOSTROPHE) {
      this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.missingDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.QUOTATION_MARK) {
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
    } else if (cp === $.APOSTROPHE) {
      this.currentToken.systemId = '';
      this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.missingDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this.state = DATA_STATE;
      this._emitCurrentToken();
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
    if (cp === $.QUOTATION_MARK) {
      this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.abruptDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.systemId += toChar(cp);
    }
  }

  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
    if (cp === $.APOSTROPHE) {
      this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
      this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
    } else if (cp === $.GREATER_THAN_SIGN) {
      this._err(ERR.abruptDoctypeSystemIdentifier);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this.currentToken.systemId += toChar(cp);
    }
  }

  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
    if (isWhitespace(cp)) {
      return;
    }
    if (cp === $.GREATER_THAN_SIGN) {
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInDoctype);
      this.currentToken.forceQuirks = true;
      this._emitCurrentToken();
      this._emitEOFToken();
    } else {
      this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
      this._reconsumeInState(BOGUS_DOCTYPE_STATE);
    }
  }

  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  [BOGUS_DOCTYPE_STATE](cp) {
    if (cp === $.GREATER_THAN_SIGN) {
      this._emitCurrentToken();
      this.state = DATA_STATE;
    } else if (cp === $.NULL) {
      this._err(ERR.unexpectedNullCharacter);
    } else if (cp === $.EOF) {
      this._emitCurrentToken();
      this._emitEOFToken();
    }
  }

  // CDATA section state
  //------------------------------------------------------------------
  [CDATA_SECTION_STATE](cp) {
    if (cp === $.RIGHT_SQUARE_BRACKET) {
      this.state = CDATA_SECTION_BRACKET_STATE;
    } else if (cp === $.EOF) {
      this._err(ERR.eofInCdata);
      this._emitEOFToken();
    } else {
      this._emitCodePoint(cp);
    }
  }

  // CDATA section bracket state
  //------------------------------------------------------------------
  [CDATA_SECTION_BRACKET_STATE](cp) {
    if (cp === $.RIGHT_SQUARE_BRACKET) {
      this.state = CDATA_SECTION_END_STATE;
    } else {
      this._emitChars(']');
      this._reconsumeInState(CDATA_SECTION_STATE);
    }
  }

  // CDATA section end state
  //------------------------------------------------------------------
  [CDATA_SECTION_END_STATE](cp) {
    if (cp === $.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
    } else if (cp === $.RIGHT_SQUARE_BRACKET) {
      this._emitChars(']');
    } else {
      this._emitChars(']]');
      this._reconsumeInState(CDATA_SECTION_STATE);
    }
  }

  // Character reference state
  //------------------------------------------------------------------
  [CHARACTER_REFERENCE_STATE](cp) {
    this.tempBuff = [$.AMPERSAND];
    if (cp === $.NUMBER_SIGN) {
      this.tempBuff.push(cp);
      this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
    } else if (isAsciiAlphaNumeric(cp)) {
      this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
    } else {
      this._flushCodePointsConsumedAsCharacterReference();
      this._reconsumeInState(this.returnState);
    }
  }

  // Named character reference state
  //------------------------------------------------------------------
  [NAMED_CHARACTER_REFERENCE_STATE](cp) {
    const matchResult = this._matchNamedCharacterReference(cp);

    //NOTE: matching can be abrupted by hibernation. In that case match
    //results are no longer valid and we will need to start over.
    if (this._ensureHibernation()) {
      this.tempBuff = [$.AMPERSAND];
    } else if (matchResult) {
      const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $.SEMICOLON;
      if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
        if (!withSemicolon) {
          this._errOnNextCodePoint(ERR.missingSemicolonAfterCharacterReference);
        }
        this.tempBuff = matchResult;
      }
      this._flushCodePointsConsumedAsCharacterReference();
      this.state = this.returnState;
    } else {
      this._flushCodePointsConsumedAsCharacterReference();
      this.state = AMBIGUOUS_AMPERSAND_STATE;
    }
  }

  // Ambiguos ampersand state
  //------------------------------------------------------------------
  [AMBIGUOUS_AMPERSAND_STATE](cp) {
    if (isAsciiAlphaNumeric(cp)) {
      if (this._isCharacterReferenceInAttribute()) {
        this.currentAttr.value += toChar(cp);
      } else {
        this._emitCodePoint(cp);
      }
    } else {
      if (cp === $.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState);
    }
  }

  // Numeric character reference state
  //------------------------------------------------------------------
  [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
    this.charRefCode = 0;
    if (cp === $.LATIN_SMALL_X || cp === $.LATIN_CAPITAL_X) {
      this.tempBuff.push(cp);
      this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
    } else {
      this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
    }
  }

  // Hexademical character reference start state
  //------------------------------------------------------------------
  [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
    if (isAsciiHexDigit(cp)) {
      this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointsConsumedAsCharacterReference();
      this._reconsumeInState(this.returnState);
    }
  }

  // Decimal character reference start state
  //------------------------------------------------------------------
  [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
    if (isAsciiDigit(cp)) {
      this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointsConsumedAsCharacterReference();
      this._reconsumeInState(this.returnState);
    }
  }

  // Hexademical character reference state
  //------------------------------------------------------------------
  [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 0x37;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 0x57;
    } else if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 0x30;
    } else if (cp === $.SEMICOLON) {
      this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
    }
  }

  // Decimal character reference state
  //------------------------------------------------------------------
  [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
    if (isAsciiDigit(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 0x30;
    } else if (cp === $.SEMICOLON) {
      this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
    }
  }

  // Numeric character reference end state
  //------------------------------------------------------------------
  [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
    if (this.charRefCode === $.NULL) {
      this._err(ERR.nullCharacterReference);
      this.charRefCode = $.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 0x10ffff) {
      this._err(ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = $.REPLACEMENT_CHARACTER;
    } else if (unicode.isSurrogate(this.charRefCode)) {
      this._err(ERR.surrogateCharacterReference);
      this.charRefCode = $.REPLACEMENT_CHARACTER;
    } else if (unicode.isUndefinedCodePoint(this.charRefCode)) {
      this._err(ERR.noncharacterCharacterReference);
    } else if (unicode.isControlCodePoint(this.charRefCode) || this.charRefCode === $.CARRIAGE_RETURN) {
      this._err(ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];
      if (replacement) {
        this.charRefCode = replacement;
      }
    }
    this.tempBuff = [this.charRefCode];
    this._flushCodePointsConsumedAsCharacterReference();
    this._reconsumeInState(this.returnState);
  }
}

//Token types
Tokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
Tokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
Tokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
Tokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';
Tokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';
Tokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';
Tokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
Tokenizer.EOF_TOKEN = 'EOF_TOKEN';
Tokenizer.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';

//Tokenizer initial states for different modes
Tokenizer.MODE = {
  DATA: DATA_STATE,
  RCDATA: RCDATA_STATE,
  RAWTEXT: RAWTEXT_STATE,
  SCRIPT_DATA: SCRIPT_DATA_STATE,
  PLAINTEXT: PLAINTEXT_STATE
};

//Static
Tokenizer.getTokenAttr = function (token, attrName) {
  for (let i = token.attrs.length - 1; i >= 0; i--) {
    if (token.attrs[i].name === attrName) {
      return token.attrs[i].value;
    }
  }
  return null;
};
module.exports = Tokenizer;

/***/ }),

/***/ 22555:
/*!**************************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/tokenizer/named-entity-data.js ***!
  \**************************************************************************************/
/***/ (function(module) {

"use strict";


//NOTE: this file contains auto-generated array mapped radix tree that is used for the named entity references consumption
//(details: https://github.com/inikulin/parse5/tree/master/scripts/generate-named-entity-data/README.md)
module.exports = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4000, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 10000, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13000, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);

/***/ }),

/***/ 43938:
/*!*********************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/tokenizer/preprocessor.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const unicode = __webpack_require__(/*! ../common/unicode */ 84382);
const ERR = __webpack_require__(/*! ../common/error-codes */ 63136);

//Aliases
const $ = unicode.CODE_POINTS;

//Const
const DEFAULT_BUFFER_WATERLINE = 1 << 16;

//Preprocessor
//NOTE: HTML input preprocessing
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
class Preprocessor {
  constructor() {
    this.html = null;
    this.pos = -1;
    this.lastGapPos = -1;
    this.lastCharPos = -1;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
  }
  _err() {
    // NOTE: err reporting is noop by default. Enabled by mixin.
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    //NOTE: try to peek a surrogate pair
    if (this.pos !== this.lastCharPos) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (unicode.isSurrogatePair(nextCp)) {
        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
        this.pos++;

        //NOTE: add gap that should be avoided during retreat
        this._addGap();
        return unicode.getSurrogatePairCodePoint(cp, nextCp);
      }
    }

    //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.
    else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return $.EOF;
    }

    //NOTE: isolated surrogate
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  dropParsedChunk() {
    if (this.pos > this.bufferWaterline) {
      this.lastCharPos -= this.pos;
      this.html = this.html.substring(this.pos);
      this.pos = 0;
      this.lastGapPos = -1;
      this.gapStack = [];
    }
  }
  write(chunk, isLastChunk) {
    if (this.html) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.lastCharPos = this.html.length - 1;
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);
    this.lastCharPos = this.html.length - 1;
    this.endOfChunkHit = false;
  }
  advance() {
    this.pos++;
    if (this.pos > this.lastCharPos) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return $.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);

    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
    //must be ignored.
    if (this.skipNextNewLine && cp === $.LINE_FEED) {
      this.skipNextNewLine = false;
      this._addGap();
      return this.advance();
    }

    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
    if (cp === $.CARRIAGE_RETURN) {
      this.skipNextNewLine = true;
      return $.LINE_FEED;
    }
    this.skipNextNewLine = false;
    if (unicode.isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }

    //OPTIMIZATION: first check if code point is in the common allowed
    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
    //before going into detailed performance cost validation.
    const isCommonValidRange = cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 0xfdd0;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (unicode.isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (unicode.isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat() {
    if (this.pos === this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.pos--;
  }
}
module.exports = Preprocessor;

/***/ }),

/***/ 80382:
/*!********************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/tree-adapters/default.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


const {
  DOCUMENT_MODE
} = __webpack_require__(/*! ../common/html */ 39604);

//Node construction
exports.createDocument = function () {
  return {
    nodeName: '#document',
    mode: DOCUMENT_MODE.NO_QUIRKS,
    childNodes: []
  };
};
exports.createDocumentFragment = function () {
  return {
    nodeName: '#document-fragment',
    childNodes: []
  };
};
exports.createElement = function (tagName, namespaceURI, attrs) {
  return {
    nodeName: tagName,
    tagName: tagName,
    attrs: attrs,
    namespaceURI: namespaceURI,
    childNodes: [],
    parentNode: null
  };
};
exports.createCommentNode = function (data) {
  return {
    nodeName: '#comment',
    data: data,
    parentNode: null
  };
};
const createTextNode = function (value) {
  return {
    nodeName: '#text',
    value: value,
    parentNode: null
  };
};

//Tree mutation
const appendChild = exports.appendChild = function (parentNode, newNode) {
  parentNode.childNodes.push(newNode);
  newNode.parentNode = parentNode;
};
const insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {
  const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
  parentNode.childNodes.splice(insertionIdx, 0, newNode);
  newNode.parentNode = parentNode;
};
exports.setTemplateContent = function (templateElement, contentElement) {
  templateElement.content = contentElement;
};
exports.getTemplateContent = function (templateElement) {
  return templateElement.content;
};
exports.setDocumentType = function (document, name, publicId, systemId) {
  let doctypeNode = null;
  for (let i = 0; i < document.childNodes.length; i++) {
    if (document.childNodes[i].nodeName === '#documentType') {
      doctypeNode = document.childNodes[i];
      break;
    }
  }
  if (doctypeNode) {
    doctypeNode.name = name;
    doctypeNode.publicId = publicId;
    doctypeNode.systemId = systemId;
  } else {
    appendChild(document, {
      nodeName: '#documentType',
      name: name,
      publicId: publicId,
      systemId: systemId
    });
  }
};
exports.setDocumentMode = function (document, mode) {
  document.mode = mode;
};
exports.getDocumentMode = function (document) {
  return document.mode;
};
exports.detachNode = function (node) {
  if (node.parentNode) {
    const idx = node.parentNode.childNodes.indexOf(node);
    node.parentNode.childNodes.splice(idx, 1);
    node.parentNode = null;
  }
};
exports.insertText = function (parentNode, text) {
  if (parentNode.childNodes.length) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
    if (prevNode.nodeName === '#text') {
      prevNode.value += text;
      return;
    }
  }
  appendChild(parentNode, createTextNode(text));
};
exports.insertTextBefore = function (parentNode, text, referenceNode) {
  const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
  if (prevNode && prevNode.nodeName === '#text') {
    prevNode.value += text;
  } else {
    insertBefore(parentNode, createTextNode(text), referenceNode);
  }
};
exports.adoptAttributes = function (recipient, attrs) {
  const recipientAttrsMap = [];
  for (let i = 0; i < recipient.attrs.length; i++) {
    recipientAttrsMap.push(recipient.attrs[i].name);
  }
  for (let j = 0; j < attrs.length; j++) {
    if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
      recipient.attrs.push(attrs[j]);
    }
  }
};

//Tree traversing
exports.getFirstChild = function (node) {
  return node.childNodes[0];
};
exports.getChildNodes = function (node) {
  return node.childNodes;
};
exports.getParentNode = function (node) {
  return node.parentNode;
};
exports.getAttrList = function (element) {
  return element.attrs;
};

//Node data
exports.getTagName = function (element) {
  return element.tagName;
};
exports.getNamespaceURI = function (element) {
  return element.namespaceURI;
};
exports.getTextNodeContent = function (textNode) {
  return textNode.value;
};
exports.getCommentNodeContent = function (commentNode) {
  return commentNode.data;
};
exports.getDocumentTypeNodeName = function (doctypeNode) {
  return doctypeNode.name;
};
exports.getDocumentTypeNodePublicId = function (doctypeNode) {
  return doctypeNode.publicId;
};
exports.getDocumentTypeNodeSystemId = function (doctypeNode) {
  return doctypeNode.systemId;
};

//Node types
exports.isTextNode = function (node) {
  return node.nodeName === '#text';
};
exports.isCommentNode = function (node) {
  return node.nodeName === '#comment';
};
exports.isDocumentTypeNode = function (node) {
  return node.nodeName === '#documentType';
};
exports.isElementNode = function (node) {
  return !!node.tagName;
};

// Source code location
exports.setNodeSourceCodeLocation = function (node, location) {
  node.sourceCodeLocation = location;
};
exports.getNodeSourceCodeLocation = function (node) {
  return node.sourceCodeLocation;
};
exports.updateNodeSourceCodeLocation = function (node, endLocation) {
  node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
};

/***/ }),

/***/ 34378:
/*!******************************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/utils/merge-options.js ***!
  \******************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = function mergeOptions(defaults, options) {
  options = options || Object.create(null);
  return [defaults, options].reduce((merged, optObj) => {
    Object.keys(optObj).forEach(key => {
      merged[key] = optObj[key];
    });
    return merged;
  }, Object.create(null));
};

/***/ }),

/***/ 7596:
/*!**********************************************************************!*\
  !*** ./node_modules/critters/node_modules/parse5/lib/utils/mixin.js ***!
  \**********************************************************************/
/***/ (function(module) {

"use strict";


class Mixin {
  constructor(host) {
    const originalMethods = {};
    const overriddenMethods = this._getOverriddenMethods(this, originalMethods);
    for (const key of Object.keys(overriddenMethods)) {
      if (typeof overriddenMethods[key] === 'function') {
        originalMethods[key] = host[key];
        host[key] = overriddenMethods[key];
      }
    }
  }
  _getOverriddenMethods() {
    throw new Error('Not implemented');
  }
}
Mixin.install = function (host, Ctor, opts) {
  if (!host.__mixins) {
    host.__mixins = [];
  }
  for (let i = 0; i < host.__mixins.length; i++) {
    if (host.__mixins[i].constructor === Ctor) {
      return host.__mixins[i];
    }
  }
  const mixin = new Ctor(host, opts);
  host.__mixins.push(mixin);
  return mixin;
};
module.exports = Mixin;

/***/ }),

/***/ 9618:
/*!***************************************************!*\
  !*** ./node_modules/css-select/lib/attributes.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.attributeRules = void 0;
var boolbase_1 = __webpack_require__(/*! boolbase */ 37424);
/**
 * All reserved characters in a regex, used for escaping.
 *
 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
 */
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
/**
 * Attributes that are case-insensitive in HTML.
 *
 * @private
 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
 */
var caseInsensitiveAttributes = new Set(["accept", "accept-charset", "align", "alink", "axis", "bgcolor", "charset", "checked", "clear", "codetype", "color", "compact", "declare", "defer", "dir", "direction", "disabled", "enctype", "face", "frame", "hreflang", "http-equiv", "lang", "language", "link", "media", "method", "multiple", "nohref", "noresize", "noshade", "nowrap", "readonly", "rel", "rev", "rules", "scope", "scrolling", "selected", "shape", "target", "text", "type", "valign", "valuetype", "vlink"]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
/**
 * Attribute selectors
 */
exports.attributeRules = {
  equals: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
      };
    }
    return function (elem) {
      return adapter.getAttributeValue(elem, name) === value && next(elem);
    };
  },
  hyphen: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    var len = value.length;
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function hyphen(elem) {
      var attr = adapter.getAttributeValue(elem, name);
      return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
    };
  },
  element: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name,
      value = data.value;
    if (/\s/.test(value)) {
      return boolbase_1.falseFunc;
    }
    var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
    return function element(elem) {
      var attr = adapter.getAttributeValue(elem, name);
      return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
    };
  },
  exists: function (next, _a, _b) {
    var name = _a.name;
    var adapter = _b.adapter;
    return function (elem) {
      return adapter.hasAttrib(elem, name) && next(elem);
    };
  },
  start: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    var len = value.length;
    if (len === 0) {
      return boolbase_1.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function (elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
    };
  },
  end: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    var len = -value.length;
    if (len === 0) {
      return boolbase_1.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var _a;
        return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
      };
    }
    return function (elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
    };
  },
  any: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name,
      value = data.value;
    if (value === "") {
      return boolbase_1.falseFunc;
    }
    if (shouldIgnoreCase(data, options)) {
      var regex_1 = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
      };
    }
    return function (elem) {
      var _a;
      return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
    };
  },
  not: function (next, data, options) {
    var adapter = options.adapter;
    var name = data.name;
    var value = data.value;
    if (value === "") {
      return function (elem) {
        return !!adapter.getAttributeValue(elem, name) && next(elem);
      };
    } else if (shouldIgnoreCase(data, options)) {
      value = value.toLowerCase();
      return function (elem) {
        var attr = adapter.getAttributeValue(elem, name);
        return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
      };
    }
    return function (elem) {
      return adapter.getAttributeValue(elem, name) !== value && next(elem);
    };
  }
};

/***/ }),

/***/ 63417:
/*!************************************************!*\
  !*** ./node_modules/css-select/lib/compile.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
var css_what_1 = __webpack_require__(/*! css-what */ 87922);
var boolbase_1 = __webpack_require__(/*! boolbase */ 37424);
var sort_1 = __importDefault(__webpack_require__(/*! ./sort */ 47179));
var procedure_1 = __webpack_require__(/*! ./procedure */ 3342);
var general_1 = __webpack_require__(/*! ./general */ 35855);
var subselects_1 = __webpack_require__(/*! ./pseudo-selectors/subselects */ 63202);
/**
 * Compiles a selector to an executable function.
 *
 * @param selector Selector to compile.
 * @param options Compilation options.
 * @param context Optional context for the selector.
 */
function compile(selector, options, context) {
  var next = compileUnsafe(selector, options, context);
  return (0, subselects_1.ensureIsTag)(next, options.adapter);
}
exports.compile = compile;
function compileUnsafe(selector, options, context) {
  var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
  return compileToken(token, options, context);
}
exports.compileUnsafe = compileUnsafe;
function includesScopePseudo(t) {
  return t.type === "pseudo" && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function (data) {
    return data.some(includesScopePseudo);
  }));
}
var DESCENDANT_TOKEN = {
  type: css_what_1.SelectorType.Descendant
};
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: css_what_1.SelectorType.Pseudo,
  name: "scope",
  data: null
};
/*
 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
 * http://www.w3.org/TR/selectors4/#absolutizing
 */
function absolutize(token, _a, context) {
  var adapter = _a.adapter;
  // TODO Use better check if the context is a document
  var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
    var parent = adapter.isTag(e) && adapter.getParent(e);
    return e === subselects_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
  }));
  for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
    var t = token_1[_i];
    if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") {
      // Don't continue in else branch
    } else if (hasContext && !t.some(includesScopePseudo)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, context) {
  var _a;
  token = token.filter(function (t) {
    return t.length > 0;
  });
  token.forEach(sort_1.default);
  context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
  var isArrayContext = Array.isArray(context);
  var finalContext = context && (Array.isArray(context) ? context : [context]);
  absolutize(token, options, finalContext);
  var shouldTestNextSiblings = false;
  var query = token.map(function (rules) {
    if (rules.length >= 2) {
      var first = rules[0],
        second = rules[1];
      if (first.type !== "pseudo" || first.name !== "scope") {
        // Ignore
      } else if (isArrayContext && second.type === "descendant") {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === "adjacent" || second.type === "sibling") {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules(rules, options, finalContext);
  }).reduce(reduceRules, boolbase_1.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
exports.compileToken = compileToken;
function compileRules(rules, options, context) {
  var _a;
  return rules.reduce(function (previous, rule) {
    return previous === boolbase_1.falseFunc ? boolbase_1.falseFunc : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
  }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
}
function reduceRules(a, b) {
  if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
    return a;
  }
  if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}

/***/ }),

/***/ 35855:
/*!************************************************!*\
  !*** ./node_modules/css-select/lib/general.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.compileGeneralSelector = void 0;
var attributes_1 = __webpack_require__(/*! ./attributes */ 9618);
var pseudo_selectors_1 = __webpack_require__(/*! ./pseudo-selectors */ 55425);
var css_what_1 = __webpack_require__(/*! css-what */ 87922);
/*
 * All available rules
 */
function compileGeneralSelector(next, selector, options, context, compileToken) {
  var adapter = options.adapter,
    equals = options.equals;
  switch (selector.type) {
    case css_what_1.SelectorType.PseudoElement:
      {
        throw new Error("Pseudo-elements are not supported by css-select");
      }
    case css_what_1.SelectorType.ColumnCombinator:
      {
        throw new Error("Column combinators are not yet supported by css-select");
      }
    case css_what_1.SelectorType.Attribute:
      {
        if (selector.namespace != null) {
          throw new Error("Namespaced attributes are not yet supported by css-select");
        }
        if (!options.xmlMode || options.lowerCaseAttributeNames) {
          selector.name = selector.name.toLowerCase();
        }
        return attributes_1.attributeRules[selector.action](next, selector, options);
      }
    case css_what_1.SelectorType.Pseudo:
      {
        return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
      }
    // Tags
    case css_what_1.SelectorType.Tag:
      {
        if (selector.namespace != null) {
          throw new Error("Namespaced tag names are not yet supported by css-select");
        }
        var name_1 = selector.name;
        if (!options.xmlMode || options.lowerCaseTags) {
          name_1 = name_1.toLowerCase();
        }
        return function tag(elem) {
          return adapter.getName(elem) === name_1 && next(elem);
        };
      }
    // Traversal
    case css_what_1.SelectorType.Descendant:
      {
        if (options.cacheResults === false || typeof WeakSet === "undefined") {
          return function descendant(elem) {
            var current = elem;
            while (current = adapter.getParent(current)) {
              if (adapter.isTag(current) && next(current)) {
                return true;
              }
            }
            return false;
          };
        }
        // @ts-expect-error `ElementNode` is not extending object
        var isFalseCache_1 = new WeakSet();
        return function cachedDescendant(elem) {
          var current = elem;
          while (current = adapter.getParent(current)) {
            if (!isFalseCache_1.has(current)) {
              if (adapter.isTag(current) && next(current)) {
                return true;
              }
              isFalseCache_1.add(current);
            }
          }
          return false;
        };
      }
    case "_flexibleDescendant":
      {
        // Include element itself, only used while querying an array
        return function flexibleDescendant(elem) {
          var current = elem;
          do {
            if (adapter.isTag(current) && next(current)) return true;
          } while (current = adapter.getParent(current));
          return false;
        };
      }
    case css_what_1.SelectorType.Parent:
      {
        return function parent(elem) {
          return adapter.getChildren(elem).some(function (elem) {
            return adapter.isTag(elem) && next(elem);
          });
        };
      }
    case css_what_1.SelectorType.Child:
      {
        return function child(elem) {
          var parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(parent);
        };
      }
    case css_what_1.SelectorType.Sibling:
      {
        return function sibling(elem) {
          var siblings = adapter.getSiblings(elem);
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling)) break;
            if (adapter.isTag(currentSibling) && next(currentSibling)) {
              return true;
            }
          }
          return false;
        };
      }
    case css_what_1.SelectorType.Adjacent:
      {
        if (adapter.prevElementSibling) {
          return function adjacent(elem) {
            var previous = adapter.prevElementSibling(elem);
            return previous != null && next(previous);
          };
        }
        return function adjacent(elem) {
          var siblings = adapter.getSiblings(elem);
          var lastElement;
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling)) break;
            if (adapter.isTag(currentSibling)) {
              lastElement = currentSibling;
            }
          }
          return !!lastElement && next(lastElement);
        };
      }
    case css_what_1.SelectorType.Universal:
      {
        if (selector.namespace != null && selector.namespace !== "*") {
          throw new Error("Namespaced universal selectors are not yet supported by css-select");
        }
        return next;
      }
  }
}
exports.compileGeneralSelector = compileGeneralSelector;

/***/ }),

/***/ 18219:
/*!**********************************************!*\
  !*** ./node_modules/css-select/lib/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
var DomUtils = __importStar(__webpack_require__(/*! domutils */ 63624));
var boolbase_1 = __webpack_require__(/*! boolbase */ 37424);
var compile_1 = __webpack_require__(/*! ./compile */ 63417);
var subselects_1 = __webpack_require__(/*! ./pseudo-selectors/subselects */ 63202);
var defaultEquals = function (a, b) {
  return a === b;
};
var defaultOptions = {
  adapter: DomUtils,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  var _a, _b, _c, _d;
  /*
   * We force one format of options to the other one.
   */
  // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
  var opts = options !== null && options !== void 0 ? options : defaultOptions;
  // @ts-expect-error Same as above.
  (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
  // @ts-expect-error `equals` does not exist on `Options`
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options, context) {
    var opts = convertOptionFormats(options);
    return func(selector, opts, context);
  };
}
/**
 * Compiles the query, returns a function.
 */
exports.compile = wrapCompile(compile_1.compile);
exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
exports._compileToken = wrapCompile(compile_1.compileToken);
function getSelectorFunc(searchFunc) {
  return function select(query, elements, options) {
    var opts = convertOptionFormats(options);
    if (typeof query !== "function") {
      query = (0, compile_1.compileUnsafe)(query, opts, elements);
    }
    var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
    return searchFunc(query, filteredElements, opts);
  };
}
function prepareContext(elems, adapter, shouldTestNextSiblings) {
  if (shouldTestNextSiblings === void 0) {
    shouldTestNextSiblings = false;
  }
  /*
   * Add siblings if the query requires them.
   * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
   */
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter);
  }
  return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
}
exports.prepareContext = prepareContext;
function appendNextSiblings(elem, adapter) {
  // Order matters because jQuery seems to check the children before the siblings
  var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  var elemsLength = elems.length;
  for (var i = 0; i < elemsLength; i++) {
    var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
    elems.push.apply(elems, nextSiblings);
  }
  return elems;
}
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns All matching elements.
 *
 */
exports.selectAll = getSelectorFunc(function (query, elems, options) {
  return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
});
/**
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elems Elements to query. If it is an element, its children will be queried..
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns the first match, or null if there was no match.
 */
exports.selectOne = getSelectorFunc(function (query, elems, options) {
  return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
});
/**
 * Tests whether or not an element is matched by query.
 *
 * @template Node The generic Node type for the DOM adapter being used.
 * @template ElementNode The Node type for elements for the DOM adapter being used.
 * @param elem The element to test if it matches the query.
 * @param query can be either a CSS selector string or a compiled query function.
 * @param [options] options for querying the document.
 * @see compile for supported selector queries.
 * @returns
 */
function is(elem, query, options) {
  var opts = convertOptionFormats(options);
  return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
}
exports.is = is;
/**
 * Alias for selectAll(query, elems, options).
 * @see [compile] for supported selector queries.
 */
exports["default"] = exports.selectAll;
// Export filters, pseudos and aliases to allow users to supply their own.
var pseudo_selectors_1 = __webpack_require__(/*! ./pseudo-selectors */ 55425);
Object.defineProperty(exports, "filters", ({
  enumerable: true,
  get: function () {
    return pseudo_selectors_1.filters;
  }
}));
Object.defineProperty(exports, "pseudos", ({
  enumerable: true,
  get: function () {
    return pseudo_selectors_1.pseudos;
  }
}));
Object.defineProperty(exports, "aliases", ({
  enumerable: true,
  get: function () {
    return pseudo_selectors_1.aliases;
  }
}));

/***/ }),

/***/ 3342:
/*!**************************************************!*\
  !*** ./node_modules/css-select/lib/procedure.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isTraversal = exports.procedure = void 0;
exports.procedure = {
  universal: 50,
  tag: 30,
  attribute: 1,
  pseudo: 0,
  "pseudo-element": 0,
  "column-combinator": -1,
  descendant: -1,
  child: -1,
  parent: -1,
  sibling: -1,
  adjacent: -1,
  _flexibleDescendant: -1
};
function isTraversal(t) {
  return exports.procedure[t.type] < 0;
}
exports.isTraversal = isTraversal;

/***/ }),

/***/ 74729:
/*!*****************************************************************!*\
  !*** ./node_modules/css-select/lib/pseudo-selectors/aliases.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.aliases = void 0;
/**
 * Aliases are pseudos that are expressed as selectors.
 */
exports.aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};

/***/ }),

/***/ 63366:
/*!*****************************************************************!*\
  !*** ./node_modules/css-select/lib/pseudo-selectors/filters.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.filters = void 0;
var nth_check_1 = __importDefault(__webpack_require__(/*! nth-check */ 3268));
var boolbase_1 = __webpack_require__(/*! boolbase */ 37424);
function getChildFunc(next, adapter) {
  return function (elem) {
    var parent = adapter.getParent(elem);
    return parent != null && adapter.isTag(parent) && next(elem);
  };
}
exports.filters = {
  contains: function (next, text, _a) {
    var adapter = _a.adapter;
    return function contains(elem) {
      return next(elem) && adapter.getText(elem).includes(text);
    };
  },
  icontains: function (next, text, _a) {
    var adapter = _a.adapter;
    var itext = text.toLowerCase();
    return function icontains(elem) {
      return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child": function (next, rule, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var func = (0, nth_check_1.default)(rule);
    if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
    if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
    return function nthChild(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = 0; i < siblings.length; i++) {
        if (equals(elem, siblings[i])) break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-child": function (next, rule, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var func = (0, nth_check_1.default)(rule);
    if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
    if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
    return function nthLastChild(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = siblings.length - 1; i >= 0; i--) {
        if (equals(elem, siblings[i])) break;
        if (adapter.isTag(siblings[i])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-of-type": function (next, rule, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var func = (0, nth_check_1.default)(rule);
    if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
    if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
    return function nthOfType(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = 0; i < siblings.length; i++) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling)) break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-of-type": function (next, rule, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var func = (0, nth_check_1.default)(rule);
    if (func === boolbase_1.falseFunc) return boolbase_1.falseFunc;
    if (func === boolbase_1.trueFunc) return getChildFunc(next, adapter);
    return function nthLastOfType(elem) {
      var siblings = adapter.getSiblings(elem);
      var pos = 0;
      for (var i = siblings.length - 1; i >= 0; i--) {
        var currentSibling = siblings[i];
        if (equals(elem, currentSibling)) break;
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  // TODO determine the actual root element
  root: function (next, _rule, _a) {
    var adapter = _a.adapter;
    return function (elem) {
      var parent = adapter.getParent(elem);
      return (parent == null || !adapter.isTag(parent)) && next(elem);
    };
  },
  scope: function (next, rule, options, context) {
    var equals = options.equals;
    if (!context || context.length === 0) {
      // Equivalent to :root
      return exports.filters.root(next, rule, options);
    }
    if (context.length === 1) {
      // NOTE: can't be unpacked, as :has uses this for side-effects
      return function (elem) {
        return equals(context[0], elem) && next(elem);
      };
    }
    return function (elem) {
      return context.includes(elem) && next(elem);
    };
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
/**
 * Dynamic state pseudos. These depend on optional Adapter methods.
 *
 * @param name The name of the adapter method to call.
 * @returns Pseudo for the `filters` object.
 */
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next, _rule, _a) {
    var adapter = _a.adapter;
    var func = adapter[name];
    if (typeof func !== "function") {
      return boolbase_1.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next(elem);
    };
  };
}

/***/ }),

/***/ 55425:
/*!***************************************************************!*\
  !*** ./node_modules/css-select/lib/pseudo-selectors/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
/*
 * Pseudo selectors
 *
 * Pseudo selectors are available in three forms:
 *
 * 1. Filters are called when the selector is compiled and return a function
 *  that has to return either false, or the results of `next()`.
 * 2. Pseudos are called on execution. They have to return a boolean.
 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
 *
 * Filters are great if you want to do some pre-processing, or change the call order
 * of `next()` and your code.
 * Pseudos should be used to implement simple checks.
 */
var boolbase_1 = __webpack_require__(/*! boolbase */ 37424);
var css_what_1 = __webpack_require__(/*! css-what */ 87922);
var filters_1 = __webpack_require__(/*! ./filters */ 63366);
Object.defineProperty(exports, "filters", ({
  enumerable: true,
  get: function () {
    return filters_1.filters;
  }
}));
var pseudos_1 = __webpack_require__(/*! ./pseudos */ 55802);
Object.defineProperty(exports, "pseudos", ({
  enumerable: true,
  get: function () {
    return pseudos_1.pseudos;
  }
}));
var aliases_1 = __webpack_require__(/*! ./aliases */ 74729);
Object.defineProperty(exports, "aliases", ({
  enumerable: true,
  get: function () {
    return aliases_1.aliases;
  }
}));
var subselects_1 = __webpack_require__(/*! ./subselects */ 63202);
function compilePseudoSelector(next, selector, options, context, compileToken) {
  var name = selector.name,
    data = selector.data;
  if (Array.isArray(data)) {
    return subselects_1.subselects[name](next, data, options, context, compileToken);
  }
  if (name in aliases_1.aliases) {
    if (data != null) {
      throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
    }
    // The alias has to be parsed here, to make sure options are respected.
    var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
    return subselects_1.subselects.is(next, alias, options, context, compileToken);
  }
  if (name in filters_1.filters) {
    return filters_1.filters[name](next, data, options, context);
  }
  if (name in pseudos_1.pseudos) {
    var pseudo_1 = pseudos_1.pseudos[name];
    (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
    return pseudo_1 === boolbase_1.falseFunc ? boolbase_1.falseFunc : next === boolbase_1.trueFunc ? function (elem) {
      return pseudo_1(elem, options, data);
    } : function (elem) {
      return pseudo_1(elem, options, data) && next(elem);
    };
  }
  throw new Error("unmatched pseudo-class :".concat(name));
}
exports.compilePseudoSelector = compilePseudoSelector;

/***/ }),

/***/ 55802:
/*!*****************************************************************!*\
  !*** ./node_modules/css-select/lib/pseudo-selectors/pseudos.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.verifyPseudoArgs = exports.pseudos = void 0;
// While filters are precompiled, pseudos get called when they are needed
exports.pseudos = {
  empty: function (elem, _a) {
    var adapter = _a.adapter;
    return !adapter.getChildren(elem).some(function (elem) {
      // FIXME: `getText` call is potentially expensive.
      return adapter.isTag(elem) || adapter.getText(elem) !== "";
    });
  },
  "first-child": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var firstChild = adapter.getSiblings(elem).find(function (elem) {
      return adapter.isTag(elem);
    });
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var siblings = adapter.getSiblings(elem);
    for (var i = siblings.length - 1; i >= 0; i--) {
      if (equals(elem, siblings[i])) return true;
      if (adapter.isTag(siblings[i])) break;
    }
    return false;
  },
  "first-of-type": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var siblings = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i = 0; i < siblings.length; i++) {
      var currentSibling = siblings[i];
      if (equals(elem, currentSibling)) return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var siblings = adapter.getSiblings(elem);
    var elemName = adapter.getName(elem);
    for (var i = siblings.length - 1; i >= 0; i--) {
      var currentSibling = siblings[i];
      if (equals(elem, currentSibling)) return true;
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    var elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every(function (sibling) {
      return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
    });
  },
  "only-child": function (elem, _a) {
    var adapter = _a.adapter,
      equals = _a.equals;
    return adapter.getSiblings(elem).every(function (sibling) {
      return equals(elem, sibling) || !adapter.isTag(sibling);
    });
  }
};
function verifyPseudoArgs(func, name, subselect) {
  if (subselect === null) {
    if (func.length > 2) {
      throw new Error("pseudo-selector :".concat(name, " requires an argument"));
    }
  } else if (func.length === 2) {
    throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
  }
}
exports.verifyPseudoArgs = verifyPseudoArgs;

/***/ }),

/***/ 63202:
/*!********************************************************************!*\
  !*** ./node_modules/css-select/lib/pseudo-selectors/subselects.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
var boolbase_1 = __webpack_require__(/*! boolbase */ 37424);
var procedure_1 = __webpack_require__(/*! ../procedure */ 3342);
/** Used as a placeholder for :has. Will be replaced with the actual element. */
exports.PLACEHOLDER_ELEMENT = {};
function ensureIsTag(next, adapter) {
  if (next === boolbase_1.falseFunc) return boolbase_1.falseFunc;
  return function (elem) {
    return adapter.isTag(elem) && next(elem);
  };
}
exports.ensureIsTag = ensureIsTag;
function getNextSiblings(elem, adapter) {
  var siblings = adapter.getSiblings(elem);
  if (siblings.length <= 1) return [];
  var elemIndex = siblings.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];
  return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
exports.getNextSiblings = getNextSiblings;
var is = function (next, token, options, context, compileToken) {
  var opts = {
    xmlMode: !!options.xmlMode,
    adapter: options.adapter,
    equals: options.equals
  };
  var func = compileToken(token, opts, context);
  return function (elem) {
    return func(elem) && next(elem);
  };
};
/*
 * :not, :has, :is, :matches and :where have to compile selectors
 * doing this in src/pseudos.ts would lead to circular dependencies,
 * so we add them here
 */
exports.subselects = {
  is: is,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is,
  where: is,
  not: function (next, token, options, context, compileToken) {
    var opts = {
      xmlMode: !!options.xmlMode,
      adapter: options.adapter,
      equals: options.equals
    };
    var func = compileToken(token, opts, context);
    if (func === boolbase_1.falseFunc) return next;
    if (func === boolbase_1.trueFunc) return boolbase_1.falseFunc;
    return function not(elem) {
      return !func(elem) && next(elem);
    };
  },
  has: function (next, subselect, options, _context, compileToken) {
    var adapter = options.adapter;
    var opts = {
      xmlMode: !!options.xmlMode,
      adapter: adapter,
      equals: options.equals
    };
    // @ts-expect-error Uses an array as a pointer to the current element (side effects)
    var context = subselect.some(function (s) {
      return s.some(procedure_1.isTraversal);
    }) ? [exports.PLACEHOLDER_ELEMENT] : undefined;
    var compiled = compileToken(subselect, opts, context);
    if (compiled === boolbase_1.falseFunc) return boolbase_1.falseFunc;
    if (compiled === boolbase_1.trueFunc) {
      return function (elem) {
        return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
      };
    }
    var hasElement = ensureIsTag(compiled, adapter);
    var _a = compiled.shouldTestNextSiblings,
      shouldTestNextSiblings = _a === void 0 ? false : _a;
    /*
     * `shouldTestNextSiblings` will only be true if the query starts with
     * a traversal (sibling or adjacent). That means we will always have a context.
     */
    if (context) {
      return function (elem) {
        context[0] = elem;
        var childs = adapter.getChildren(elem);
        var nextElements = shouldTestNextSiblings ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
        return next(elem) && adapter.existsOne(hasElement, nextElements);
      };
    }
    return function (elem) {
      return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
    };
  }
};

/***/ }),

/***/ 47179:
/*!*********************************************!*\
  !*** ./node_modules/css-select/lib/sort.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var css_what_1 = __webpack_require__(/*! css-what */ 87922);
var procedure_1 = __webpack_require__(/*! ./procedure */ 3342);
var attributes = {
  exists: 10,
  equals: 8,
  not: 7,
  start: 6,
  end: 6,
  any: 5,
  hyphen: 4,
  element: 4
};
/**
 * Sort the parts of the passed selector,
 * as there is potential for optimization
 * (some types of selectors are faster than others)
 *
 * @param arr Selector to sort
 */
function sortByProcedure(arr) {
  var procs = arr.map(getProcedure);
  for (var i = 1; i < arr.length; i++) {
    var procNew = procs[i];
    if (procNew < 0) continue;
    for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
      var token = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = token;
      procs[j + 1] = procs[j];
      procs[j] = procNew;
    }
  }
}
exports["default"] = sortByProcedure;
function getProcedure(token) {
  var proc = procedure_1.procedure[token.type];
  if (token.type === css_what_1.SelectorType.Attribute) {
    proc = attributes[token.action];
    if (proc === attributes.equals && token.name === "id") {
      // Prefer ID selectors (eg. #ID)
      proc = 9;
    }
    if (token.ignoreCase) {
      /*
       * IgnoreCase adds some overhead, prefer "normal" token
       * this is a binary operation, to ensure it's still an int
       */
      proc >>= 1;
    }
  } else if (token.type === css_what_1.SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0; // Expensive in any case
    } else if (Array.isArray(token.data)) {
      // "matches" and "not"
      proc = 0;
      for (var i = 0; i < token.data.length; i++) {
        // TODO better handling of complex selectors
        if (token.data[i].length !== 1) continue;
        var cur = getProcedure(token.data[i][0]);
        // Avoid executing :has or :contains
        if (cur === 0) {
          proc = 0;
          break;
        }
        if (cur > proc) proc = cur;
      }
      if (token.data.length > 1 && proc > 0) proc -= 1;
    } else {
      proc = 1;
    }
  }
  return proc;
}

/***/ }),

/***/ 87922:
/*!***********************************************!*\
  !*** ./node_modules/css-what/lib/es/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeAction: function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction; },
/* harmony export */   IgnoreCaseMode: function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.IgnoreCaseMode; },
/* harmony export */   SelectorType: function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType; },
/* harmony export */   isTraversal: function() { return /* reexport safe */ _parse__WEBPACK_IMPORTED_MODULE_1__.isTraversal; },
/* harmony export */   parse: function() { return /* reexport safe */ _parse__WEBPACK_IMPORTED_MODULE_1__.parse; },
/* harmony export */   stringify: function() { return /* reexport safe */ _stringify__WEBPACK_IMPORTED_MODULE_2__.stringify; }
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ 51695);
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse */ 70161);
/* harmony import */ var _stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify */ 66479);




/***/ }),

/***/ 70161:
/*!***********************************************!*\
  !*** ./node_modules/css-what/lib/es/parse.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isTraversal: function() { return /* binding */ isTraversal; },
/* harmony export */   parse: function() { return /* binding */ parse; }
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ 51695);

const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = new Map([[126 /* Tilde */, _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Element], [94 /* Circumflex */, _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Start], [36 /* Dollar */, _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.End], [42 /* Asterisk */, _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Any], [33 /* ExclamationMark */, _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Not], [124 /* Pipe */, _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Hyphen]]);
// Pseudos, whose data property is parsed as well.
const unpackPseudos = new Set(["has", "not", "matches", "is", "where", "host", "host-context"]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
  switch (selector.type) {
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Adjacent:
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Child:
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Descendant:
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Parent:
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Sibling:
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 0x10000;
  // NaN means non-codepoint
  return high !== high || escapedWhitespace ? escaped : high < 0 ?
  // BMP codepoint
  String.fromCharCode(high + 0x10000) :
  // Supplemental Plane codepoint (surrogate pair)
  String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c) {
  return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
}

function isWhitespace(c) {
  return c === 32 /* Space */ || c === 9 /* Tab */ || c === 10 /* NewLine */ || c === 12 /* FormFeed */ || c === 13 /* CarriageReturn */;
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */ && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 /* RightParenthesis */ && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92 /* BackSlash */) slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({
      type
    });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  /**
   * We have finished parsing the current part of the selector.
   *
   * Remove descendant tokens at the end if they exist,
   * and return the last index, so that parsing can be
   * picked up from here.
   */
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case 32 /* Space */:
      case 9 /* Tab */:
      case 10 /* NewLine */:
      case 12 /* FormFeed */:
      case 13 /* CarriageReturn */:
        {
          if (tokens.length === 0 || tokens[0].type !== _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({
              type: _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Descendant
            });
          }
          stripWhitespace(1);
          break;
        }
      // Traversals
      case 62 /* GreaterThan */:
        {
          addTraversal(_types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Child);
          stripWhitespace(1);
          break;
        }
      case 60 /* LessThan */:
        {
          addTraversal(_types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
      case 126 /* Tilde */:
        {
          addTraversal(_types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
      case 43 /* Plus */:
        {
          addTraversal(_types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
      // Special attribute selectors: .class, #id
      case 46 /* Period */:
        {
          addSpecialAttribute("class", _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Element);
          break;
        }
      case 35 /* Hash */:
        {
          addSpecialAttribute("id", _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Equals);
          break;
        }
      case 91 /* LeftSquareBracket */:
        {
          stripWhitespace(1);
          // Determine attribute name and namespace
          let name;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
            // Equivalent to no namespace
            name = getName(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name = getName(2);
          } else {
            name = getName(0);
            if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ && selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */) {
              namespace = name;
              name = getName(1);
            }
          }
          stripWhitespace(0);
          // Determine comparison operation
          let action = _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61 /* Equal */) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
            action = _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Equals;
            stripWhitespace(1);
          }
          // Determine value
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 /* RightSquareBracket */ || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            // See if we have a force ignore flag
            const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
            // If the forceIgnore flag is set (either `i` or `s`), use that value
            if (forceIgnore === 115 /* LowerS */) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105 /* LowerI */) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93 /* RightSquareBracket */) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Attribute,
            name,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
      case 58 /* Colon */:
        {
          if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
            tokens.push({
              type: _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.PseudoElement,
              name: getName(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */ ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name = getName(1).toLowerCase();
          let data = null;
          if (selector.charCodeAt(selectorIndex) === 40 /* LeftParenthesis */) {
            if (unpackPseudos.has(name)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name} cannot be quoted`);
              }
              data = [];
              selectorIndex = parseSelector(data, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41 /* RightParenthesis */) {
                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name)) {
                const quot = data.charCodeAt(0);
                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                  data = data.slice(1, -1);
                }
              }
              data = unescapeCSS(data);
            }
          }
          tokens.push({
            type: _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Pseudo,
            name,
            data
          });
          break;
        }
      case 44 /* Comma */:
        {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
      default:
        {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            // Remove leading whitespace
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name;
          if (firstChar === 42 /* Asterisk */) {
            selectorIndex += 1;
            name = "*";
          } else if (firstChar === 124 /* Pipe */) {
            name = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
              addTraversal(_types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name = getName(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ && selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
            namespace = name;
            if (selector.charCodeAt(selectorIndex + 1) === 42 /* Asterisk */) {
              name = "*";
              selectorIndex += 2;
            } else {
              name = getName(1);
            }
          }
          tokens.push(name === "*" ? {
            type: _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Universal,
            namespace
          } : {
            type: _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Tag,
            name,
            namespace
          });
        }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}

/***/ }),

/***/ 66479:
/*!***************************************************!*\
  !*** ./node_modules/css-what/lib/es/stringify.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stringify: function() { return /* binding */ stringify; }
/* harmony export */ });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ 51695);

const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(attribValChars.map(c => c.charCodeAt(0)));
const charsToEscapeInPseudoValue = new Set(pseudoValChars.map(c => c.charCodeAt(0)));
const charsToEscapeInName = new Set([...pseudoValChars, "~", "^", "$", "*", "+", "!", "|", ":", "[", "]", " ", "."].map(c => c.charCodeAt(0)));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
  return selector.map(token => token.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token, index, arr) {
  switch (token.type) {
    // Simple types
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Child:
      return index === 0 ? "> " : " > ";
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Parent:
      return index === 0 ? "< " : " < ";
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Sibling:
      return index === 0 ? "~ " : " ~ ";
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Adjacent:
      return index === 0 ? "+ " : " + ";
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Descendant:
      return " ";
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.ColumnCombinator:
      return index === 0 ? "|| " : " || ";
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Universal:
      // Return an empty string if the selector isn't needed.
      return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : `${getNamespace(token.namespace)}*`;
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Tag:
      return getNamespacedName(token);
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.PseudoElement:
      return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Pseudo:
      return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data)})`}`;
    case _types__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Attribute:
      {
        if (token.name === "id" && token.action === _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
          return `#${escapeName(token.value, charsToEscapeInName)}`;
        }
        if (token.name === "class" && token.action === _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
          return `.${escapeName(token.value, charsToEscapeInName)}`;
        }
        const name = getNamespacedName(token);
        if (token.action === _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Exists) {
          return `[${name}]`;
        }
        return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
      }
  }
}
function getActionValue(action) {
  switch (action) {
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Equals:
      return "";
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Element:
      return "~";
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Start:
      return "^";
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.End:
      return "$";
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Any:
      return "*";
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Not:
      return "!";
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Hyphen:
      return "|";
    case _types__WEBPACK_IMPORTED_MODULE_0__.AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token) {
  return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
  return namespace !== null ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|` : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i = 0; i < str.length; i++) {
    if (charsToEscape.has(str.charCodeAt(i))) {
      ret += `${str.slice(lastIdx, i)}\\${str.charAt(i)}`;
      lastIdx = i + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}

/***/ }),

/***/ 51695:
/*!***********************************************!*\
  !*** ./node_modules/css-what/lib/es/types.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeAction: function() { return /* binding */ AttributeAction; },
/* harmony export */   IgnoreCaseMode: function() { return /* binding */ IgnoreCaseMode; },
/* harmony export */   SelectorType: function() { return /* binding */ SelectorType; }
/* harmony export */ });
var SelectorType;
(function (SelectorType) {
  SelectorType["Attribute"] = "attribute";
  SelectorType["Pseudo"] = "pseudo";
  SelectorType["PseudoElement"] = "pseudo-element";
  SelectorType["Tag"] = "tag";
  SelectorType["Universal"] = "universal";
  // Traversals
  SelectorType["Adjacent"] = "adjacent";
  SelectorType["Child"] = "child";
  SelectorType["Descendant"] = "descendant";
  SelectorType["Parent"] = "parent";
  SelectorType["Sibling"] = "sibling";
  SelectorType["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
/**
 * Modes for ignore case.
 *
 * This could be updated to an enum, and the object is
 * the current stand-in that will allow code to be updated
 * without big changes.
 */
const IgnoreCaseMode = {
  Unknown: null,
  QuirksMode: "quirks",
  IgnoreCase: true,
  CaseSensitive: false
};
var AttributeAction;
(function (AttributeAction) {
  AttributeAction["Any"] = "any";
  AttributeAction["Element"] = "element";
  AttributeAction["End"] = "end";
  AttributeAction["Equals"] = "equals";
  AttributeAction["Exists"] = "exists";
  AttributeAction["Hyphen"] = "hyphen";
  AttributeAction["Not"] = "not";
  AttributeAction["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

/***/ }),

/***/ 97180:
/*!*********************************************************!*\
  !*** ./node_modules/dom-serializer/lib/foreignNames.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([["altglyph", "altGlyph"], ["altglyphdef", "altGlyphDef"], ["altglyphitem", "altGlyphItem"], ["animatecolor", "animateColor"], ["animatemotion", "animateMotion"], ["animatetransform", "animateTransform"], ["clippath", "clipPath"], ["feblend", "feBlend"], ["fecolormatrix", "feColorMatrix"], ["fecomponenttransfer", "feComponentTransfer"], ["fecomposite", "feComposite"], ["feconvolvematrix", "feConvolveMatrix"], ["fediffuselighting", "feDiffuseLighting"], ["fedisplacementmap", "feDisplacementMap"], ["fedistantlight", "feDistantLight"], ["fedropshadow", "feDropShadow"], ["feflood", "feFlood"], ["fefunca", "feFuncA"], ["fefuncb", "feFuncB"], ["fefuncg", "feFuncG"], ["fefuncr", "feFuncR"], ["fegaussianblur", "feGaussianBlur"], ["feimage", "feImage"], ["femerge", "feMerge"], ["femergenode", "feMergeNode"], ["femorphology", "feMorphology"], ["feoffset", "feOffset"], ["fepointlight", "fePointLight"], ["fespecularlighting", "feSpecularLighting"], ["fespotlight", "feSpotLight"], ["fetile", "feTile"], ["feturbulence", "feTurbulence"], ["foreignobject", "foreignObject"], ["glyphref", "glyphRef"], ["lineargradient", "linearGradient"], ["radialgradient", "radialGradient"], ["textpath", "textPath"]]);
exports.attributeNames = new Map([["definitionurl", "definitionURL"], ["attributename", "attributeName"], ["attributetype", "attributeType"], ["basefrequency", "baseFrequency"], ["baseprofile", "baseProfile"], ["calcmode", "calcMode"], ["clippathunits", "clipPathUnits"], ["diffuseconstant", "diffuseConstant"], ["edgemode", "edgeMode"], ["filterunits", "filterUnits"], ["glyphref", "glyphRef"], ["gradienttransform", "gradientTransform"], ["gradientunits", "gradientUnits"], ["kernelmatrix", "kernelMatrix"], ["kernelunitlength", "kernelUnitLength"], ["keypoints", "keyPoints"], ["keysplines", "keySplines"], ["keytimes", "keyTimes"], ["lengthadjust", "lengthAdjust"], ["limitingconeangle", "limitingConeAngle"], ["markerheight", "markerHeight"], ["markerunits", "markerUnits"], ["markerwidth", "markerWidth"], ["maskcontentunits", "maskContentUnits"], ["maskunits", "maskUnits"], ["numoctaves", "numOctaves"], ["pathlength", "pathLength"], ["patterncontentunits", "patternContentUnits"], ["patterntransform", "patternTransform"], ["patternunits", "patternUnits"], ["pointsatx", "pointsAtX"], ["pointsaty", "pointsAtY"], ["pointsatz", "pointsAtZ"], ["preservealpha", "preserveAlpha"], ["preserveaspectratio", "preserveAspectRatio"], ["primitiveunits", "primitiveUnits"], ["refx", "refX"], ["refy", "refY"], ["repeatcount", "repeatCount"], ["repeatdur", "repeatDur"], ["requiredextensions", "requiredExtensions"], ["requiredfeatures", "requiredFeatures"], ["specularconstant", "specularConstant"], ["specularexponent", "specularExponent"], ["spreadmethod", "spreadMethod"], ["startoffset", "startOffset"], ["stddeviation", "stdDeviation"], ["stitchtiles", "stitchTiles"], ["surfacescale", "surfaceScale"], ["systemlanguage", "systemLanguage"], ["tablevalues", "tableValues"], ["targetx", "targetX"], ["targety", "targetY"], ["textlength", "textLength"], ["viewbox", "viewBox"], ["viewtarget", "viewTarget"], ["xchannelselector", "xChannelSelector"], ["ychannelselector", "yChannelSelector"], ["zoomandpan", "zoomAndPan"]]);

/***/ }),

/***/ 98382:
/*!**************************************************!*\
  !*** ./node_modules/dom-serializer/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
/*
 * Module dependencies
 */
var ElementType = __importStar(__webpack_require__(/*! domelementtype */ 96485));
var entities_1 = __webpack_require__(/*! entities */ 23194);
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = __webpack_require__(/*! ./foreignNames */ 97180);
var unencodedElements = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
  if (!attributes) return;
  return Object.keys(attributes).map(function (key) {
    var _a, _b;
    var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
    if (opts.xmlMode === "foreign") {
      /* Fix up mixed-case attribute names */
      key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return key + "=\"" + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + "\"";
  }).join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
  if (options === void 0) {
    options = {};
  }
  var nodes = "length" in node ? node : [node];
  var output = "";
  for (var i = 0; i < nodes.length; i++) {
    output += renderNode(nodes[i], options);
  }
  return output;
}
exports["default"] = render;
function renderNode(node, options) {
  switch (node.type) {
    case ElementType.Root:
      return render(node.children, options);
    case ElementType.Directive:
    case ElementType.Doctype:
      return renderDirective(node);
    case ElementType.Comment:
      return renderComment(node);
    case ElementType.CDATA:
      return renderCdata(node);
    case ElementType.Script:
    case ElementType.Style:
    case ElementType.Tag:
      return renderTag(node, options);
    case ElementType.Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a;
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === "foreign") {
    /* Fix up mixed-case element names */
    elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
    /* Exit foreign mode at integration points */
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = __assign(__assign({}, opts), {
        xmlMode: false
      });
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = __assign(__assign({}, opts), {
      xmlMode: "foreign"
    });
  }
  var tag = "<" + elem.name;
  var attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag += " " + attribs;
  }
  if (elem.children.length === 0 && (opts.xmlMode ?
  // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
  opts.selfClosingTags !== false :
  // User explicitly asked for self-closing tags, even in HTML mode
  opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode) tag += " ";
    tag += "/>";
  } else {
    tag += ">";
    if (elem.children.length > 0) {
      tag += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag += "</" + elem.name + ">";
    }
  }
  return tag;
}
function renderDirective(elem) {
  return "<" + elem.data + ">";
}
function renderText(elem, opts) {
  var data = elem.data || "";
  // If entities weren't decoded, no need to encode them back
  if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = entities_1.encodeXML(data);
  }
  return data;
}
function renderCdata(elem) {
  return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
  return "<!--" + elem.data + "-->";
}

/***/ }),

/***/ 96485:
/*!**************************************************!*\
  !*** ./node_modules/domelementtype/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
  /** Type for the root element of a document */
  ElementType["Root"] = "root";
  /** Type for Text */
  ElementType["Text"] = "text";
  /** Type for <? ... ?> */
  ElementType["Directive"] = "directive";
  /** Type for <!-- ... --> */
  ElementType["Comment"] = "comment";
  /** Type for <script> tags */
  ElementType["Script"] = "script";
  /** Type for <style> tags */
  ElementType["Style"] = "style";
  /** Type for Any tag */
  ElementType["Tag"] = "tag";
  /** Type for <![CDATA[ ... ]]> */
  ElementType["CDATA"] = "cdata";
  /** Type for <!doctype ...> */
  ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;

/***/ }),

/***/ 68405:
/*!**********************************************!*\
  !*** ./node_modules/domhandler/lib/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DomHandler = void 0;
var domelementtype_1 = __webpack_require__(/*! domelementtype */ 96485);
var node_1 = __webpack_require__(/*! ./node */ 45021);
__exportStar(__webpack_require__(/*! ./node */ 45021), exports);
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
  normalizeWhitespace: false,
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var DomHandler = /** @class */function () {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  function DomHandler(callback, options, elementCB) {
    /** The elements of the DOM */
    this.dom = [];
    /** The root element for the DOM */
    this.root = new node_1.Document(this.dom);
    /** Indicated whether parsing has been completed. */
    this.done = false;
    /** Stack of open tags. */
    this.tagStack = [this.root];
    /** A data node that is still being written to. */
    this.lastNode = null;
    /** Reference to the parser instance. Used for location information. */
    this.parser = null;
    // Make it possible to skip arguments, for backwards-compatibility
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options !== null && options !== void 0 ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  DomHandler.prototype.onparserinit = function (parser) {
    this.parser = parser;
  };
  // Resets the handler back to starting state
  DomHandler.prototype.onreset = function () {
    this.dom = [];
    this.root = new node_1.Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  };
  // Signals the handler that parsing is done
  DomHandler.prototype.onend = function () {
    if (this.done) return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  };
  DomHandler.prototype.onerror = function (error) {
    this.handleCallback(error);
  };
  DomHandler.prototype.onclosetag = function () {
    this.lastNode = null;
    var elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB) this.elementCB(elem);
  };
  DomHandler.prototype.onopentag = function (name, attribs) {
    var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
    var element = new node_1.Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  };
  DomHandler.prototype.ontext = function (data) {
    var normalizeWhitespace = this.options.normalizeWhitespace;
    var lastNode = this.lastNode;
    if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
      if (normalizeWhitespace) {
        lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
      } else {
        lastNode.data += data;
      }
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      if (normalizeWhitespace) {
        data = data.replace(reWhitespace, " ");
      }
      var node = new node_1.Text(data);
      this.addNode(node);
      this.lastNode = node;
    }
  };
  DomHandler.prototype.oncomment = function (data) {
    if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    var node = new node_1.Comment(data);
    this.addNode(node);
    this.lastNode = node;
  };
  DomHandler.prototype.oncommentend = function () {
    this.lastNode = null;
  };
  DomHandler.prototype.oncdatastart = function () {
    var text = new node_1.Text("");
    var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
    this.addNode(node);
    text.parent = node;
    this.lastNode = text;
  };
  DomHandler.prototype.oncdataend = function () {
    this.lastNode = null;
  };
  DomHandler.prototype.onprocessinginstruction = function (name, data) {
    var node = new node_1.ProcessingInstruction(name, data);
    this.addNode(node);
  };
  DomHandler.prototype.handleCallback = function (error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  };
  DomHandler.prototype.addNode = function (node) {
    var parent = this.tagStack[this.tagStack.length - 1];
    var previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node.endIndex = this.parser.endIndex;
    }
    parent.children.push(node);
    if (previousSibling) {
      node.prev = previousSibling;
      previousSibling.next = node;
    }
    node.parent = parent;
    this.lastNode = null;
  };
  return DomHandler;
}();
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;

/***/ }),

/***/ 45021:
/*!*********************************************!*\
  !*** ./node_modules/domhandler/lib/node.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __extends = this && this.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __webpack_require__(/*! domelementtype */ 96485);
var nodeTypes = new Map([[domelementtype_1.ElementType.Tag, 1], [domelementtype_1.ElementType.Script, 1], [domelementtype_1.ElementType.Style, 1], [domelementtype_1.ElementType.Directive, 1], [domelementtype_1.ElementType.Text, 3], [domelementtype_1.ElementType.CDATA, 4], [domelementtype_1.ElementType.Comment, 8], [domelementtype_1.ElementType.Root, 9]]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */function () {
  /**
   *
   * @param type The type of the node.
   */
  function Node(type) {
    this.type = type;
    /** Parent of the node */
    this.parent = null;
    /** Previous sibling */
    this.prev = null;
    /** Next sibling */
    this.next = null;
    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
    this.startIndex = null;
    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
    this.endIndex = null;
  }
  Object.defineProperty(Node.prototype, "nodeType", {
    // Read-only aliases
    /**
     * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
     * node {@link type}.
     */
    get: function () {
      var _a;
      return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "parentNode", {
    // Read-write aliases for properties
    /**
     * Same as {@link parent}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.parent;
    },
    set: function (parent) {
      this.parent = parent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "previousSibling", {
    /**
     * Same as {@link prev}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.prev;
    },
    set: function (prev) {
      this.prev = prev;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node.prototype, "nextSibling", {
    /**
     * Same as {@link next}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.next;
    },
    set: function (next) {
      this.next = next;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  Node.prototype.cloneNode = function (recursive) {
    if (recursive === void 0) {
      recursive = false;
    }
    return cloneNode(this, recursive);
  };
  return Node;
}();
exports.Node = Node;
/**
 * A node that contains some data.
 */
var DataNode = /** @class */function (_super) {
  __extends(DataNode, _super);
  /**
   * @param type The type of the node
   * @param data The content of the data node
   */
  function DataNode(type, data) {
    var _this = _super.call(this, type) || this;
    _this.data = data;
    return _this;
  }
  Object.defineProperty(DataNode.prototype, "nodeValue", {
    /**
     * Same as {@link data}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.data;
    },
    set: function (data) {
      this.data = data;
    },
    enumerable: false,
    configurable: true
  });
  return DataNode;
}(Node);
exports.DataNode = DataNode;
/**
 * Text within the document.
 */
var Text = /** @class */function (_super) {
  __extends(Text, _super);
  function Text(data) {
    return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
  }
  return Text;
}(DataNode);
exports.Text = Text;
/**
 * Comments within the document.
 */
var Comment = /** @class */function (_super) {
  __extends(Comment, _super);
  function Comment(data) {
    return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
  }
  return Comment;
}(DataNode);
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction = /** @class */function (_super) {
  __extends(ProcessingInstruction, _super);
  function ProcessingInstruction(name, data) {
    var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
    _this.name = name;
    return _this;
  }
  return ProcessingInstruction;
}(DataNode);
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */function (_super) {
  __extends(NodeWithChildren, _super);
  /**
   * @param type Type of the node.
   * @param children Children of the node. Only certain node types can have children.
   */
  function NodeWithChildren(type, children) {
    var _this = _super.call(this, type) || this;
    _this.children = children;
    return _this;
  }
  Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
    // Aliases
    /** First child of the node. */
    get: function () {
      var _a;
      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
    /** Last child of the node. */
    get: function () {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
    /**
     * Same as {@link children}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.children;
    },
    set: function (children) {
      this.children = children;
    },
    enumerable: false,
    configurable: true
  });
  return NodeWithChildren;
}(Node);
exports.NodeWithChildren = NodeWithChildren;
/**
 * The root node of the document.
 */
var Document = /** @class */function (_super) {
  __extends(Document, _super);
  function Document(children) {
    return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
  }
  return Document;
}(NodeWithChildren);
exports.Document = Document;
/**
 * An element within the DOM.
 */
var Element = /** @class */function (_super) {
  __extends(Element, _super);
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  function Element(name, attribs, children, type) {
    if (children === void 0) {
      children = [];
    }
    if (type === void 0) {
      type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
    }
    var _this = _super.call(this, type, children) || this;
    _this.name = name;
    _this.attribs = attribs;
    return _this;
  }
  Object.defineProperty(Element.prototype, "tagName", {
    // DOM Level 1 aliases
    /**
     * Same as {@link name}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get: function () {
      return this.name;
    },
    set: function (name) {
      this.name = name;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Element.prototype, "attributes", {
    get: function () {
      var _this = this;
      return Object.keys(this.attribs).map(function (name) {
        var _a, _b;
        return {
          name: name,
          value: _this.attribs[name],
          namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
          prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
        };
      });
    },
    enumerable: false,
    configurable: true
  });
  return Element;
}(NodeWithChildren);
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
  return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
  return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
  return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
  return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
  return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
  return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
  if (recursive === void 0) {
    recursive = false;
  }
  var result;
  if (isText(node)) {
    result = new Text(node.data);
  } else if (isComment(node)) {
    result = new Comment(node.data);
  } else if (isTag(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
    children.forEach(function (child) {
      return child.parent = clone_1;
    });
    if (node.namespace != null) {
      clone_1.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
    }
    if (node["x-attribsPrefix"]) {
      clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
    }
    result = clone_1;
  } else if (isCDATA(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
    children.forEach(function (child) {
      return child.parent = clone_2;
    });
    result = clone_2;
  } else if (isDocument(node)) {
    var children = recursive ? cloneChildren(node.children) : [];
    var clone_3 = new Document(children);
    children.forEach(function (child) {
      return child.parent = clone_3;
    });
    if (node["x-mode"]) {
      clone_3["x-mode"] = node["x-mode"];
    }
    result = clone_3;
  } else if (isDirective(node)) {
    var instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error("Not implemented yet: ".concat(node.type));
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
  var children = childs.map(function (child) {
    return cloneNode(child, true);
  });
  for (var i = 1; i < children.length; i++) {
    children[i].prev = children[i - 1];
    children[i - 1].next = children[i];
  }
  return children;
}

/***/ }),

/***/ 41125:
/*!********************************************!*\
  !*** ./node_modules/domutils/lib/feeds.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFeed = void 0;
var stringify_1 = __webpack_require__(/*! ./stringify */ 69253);
var legacy_1 = __webpack_require__(/*! ./legacy */ 16585);
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
  var feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
exports.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
  var _a;
  var childs = feedRoot.children;
  var feed = {
    type: "atom",
    items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function (item) {
      var _a;
      var children = item.children;
      var entry = {
        media: getMediaElements(children)
      };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
      if (href) {
        entry.link = href;
      }
      var description = fetch("summary", children) || fetch("content", children);
      if (description) {
        entry.description = description;
      }
      var pubDate = fetch("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  var updated = fetch("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
  var _a, _b;
  var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
  var feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
      var children = item.children;
      var entry = {
        media: getMediaElements(children)
      };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      var pubDate = fetch("pubDate", children);
      if (pubDate) entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  var updated = fetch("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = ["fileSize", "bitrate", "framerate", "samplingrate", "channels", "duration", "height", "width"];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
  return (0, legacy_1.getElementsByTagName)("media:content", where).map(function (elem) {
    var attribs = elem.attribs;
    var media = {
      medium: attribs.medium,
      isDefault: !!attribs.isDefault
    };
    for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
      var attrib = MEDIA_KEYS_STRING_1[_i];
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
      var attrib = MEDIA_KEYS_INT_1[_a];
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs.expression) {
      media.expression = attribs.expression;
    }
    return media;
  });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
  return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where  Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch(tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse) {
  if (recurse === void 0) {
    recurse = false;
  }
  var val = fetch(tagName, where, recurse);
  if (val) obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}

/***/ }),

/***/ 22933:
/*!**********************************************!*\
  !*** ./node_modules/domutils/lib/helpers.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ 68405);
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets(nodes) {
  var idx = nodes.length;
  /*
   * Check if each node (or one of its ancestors) is already contained in the
   * array.
   */
  while (--idx >= 0) {
    var node = nodes[idx];
    /*
     * Remove the node if it is not unique.
     * We are going through the array from the end, so we only
     * have to check nodes that preceed the node under consideration in the array.
     */
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
  var aParents = [];
  var bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  var maxIdx = Math.min(aParents.length, bParents.length);
  var idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return 1 /* DISCONNECTED */;
  }

  var sharedParent = aParents[idx - 1];
  var siblings = sharedParent.children;
  var aSibling = aParents[idx];
  var bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
    }

    return 4 /* FOLLOWING */;
  }

  if (sharedParent === nodeA) {
    return 2 /* PRECEDING */ | 8 /* CONTAINS */;
  }

  return 2 /* PRECEDING */;
}

exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
  nodes = nodes.filter(function (node, i, arr) {
    return !arr.includes(node, i + 1);
  });
  nodes.sort(function (a, b) {
    var relative = compareDocumentPosition(a, b);
    if (relative & 2 /* PRECEDING */) {
      return -1;
    } else if (relative & 4 /* FOLLOWING */) {
      return 1;
    }
    return 0;
  });
  return nodes;
}
exports.uniqueSort = uniqueSort;

/***/ }),

/***/ 63624:
/*!********************************************!*\
  !*** ./node_modules/domutils/lib/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__webpack_require__(/*! ./stringify */ 69253), exports);
__exportStar(__webpack_require__(/*! ./traversal */ 26410), exports);
__exportStar(__webpack_require__(/*! ./manipulation */ 71419), exports);
__exportStar(__webpack_require__(/*! ./querying */ 3646), exports);
__exportStar(__webpack_require__(/*! ./legacy */ 16585), exports);
__exportStar(__webpack_require__(/*! ./helpers */ 22933), exports);
__exportStar(__webpack_require__(/*! ./feeds */ 41125), exports);
/** @deprecated Use these methods from `domhandler` directly. */
var domhandler_1 = __webpack_require__(/*! domhandler */ 68405);
Object.defineProperty(exports, "isTag", ({
  enumerable: true,
  get: function () {
    return domhandler_1.isTag;
  }
}));
Object.defineProperty(exports, "isCDATA", ({
  enumerable: true,
  get: function () {
    return domhandler_1.isCDATA;
  }
}));
Object.defineProperty(exports, "isText", ({
  enumerable: true,
  get: function () {
    return domhandler_1.isText;
  }
}));
Object.defineProperty(exports, "isComment", ({
  enumerable: true,
  get: function () {
    return domhandler_1.isComment;
  }
}));
Object.defineProperty(exports, "isDocument", ({
  enumerable: true,
  get: function () {
    return domhandler_1.isDocument;
  }
}));
Object.defineProperty(exports, "hasChildren", ({
  enumerable: true,
  get: function () {
    return domhandler_1.hasChildren;
  }
}));

/***/ }),

/***/ 16585:
/*!*********************************************!*\
  !*** ./node_modules/domutils/lib/legacy.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ 68405);
var querying_1 = __webpack_require__(/*! ./querying */ 3646);
var Checks = {
  tag_name: function (name) {
    if (typeof name === "function") {
      return function (elem) {
        return (0, domhandler_1.isTag)(elem) && name(elem.name);
      };
    } else if (name === "*") {
      return domhandler_1.isTag;
    }
    return function (elem) {
      return (0, domhandler_1.isTag)(elem) && elem.name === name;
    };
  },
  tag_type: function (type) {
    if (typeof type === "function") {
      return function (elem) {
        return type(elem.type);
      };
    }
    return function (elem) {
      return elem.type === type;
    };
  },
  tag_contains: function (data) {
    if (typeof data === "function") {
      return function (elem) {
        return (0, domhandler_1.isText)(elem) && data(elem.data);
      };
    }
    return function (elem) {
      return (0, domhandler_1.isText)(elem) && elem.data === data;
    };
  }
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function (elem) {
      return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
    };
  }
  return function (elem) {
    return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
  };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
  return function (elem) {
    return a(elem) || b(elem);
  };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
  var funcs = Object.keys(options).map(function (key) {
    var value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
  var test = compileTest(options);
  return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
  if (limit === void 0) {
    limit = Infinity;
  }
  var test = compileTest(options);
  return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (!Array.isArray(nodes)) nodes = [nodes];
  return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType;

/***/ }),

/***/ 71419:
/*!***************************************************!*\
  !*** ./node_modules/domutils/lib/manipulation.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
  if (elem.prev) elem.prev.next = elem.next;
  if (elem.next) elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    childs.splice(childs.lastIndexOf(elem), 1);
  }
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
  }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(elem, child) {
  removeElement(child);
  child.next = null;
  child.parent = elem;
  if (elem.children.push(child) > 1) {
    var sibling = elem.children[elem.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append(elem, next) {
  removeElement(next);
  var parent = elem.parent;
  var currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
  removeElement(child);
  child.parent = elem;
  child.prev = null;
  if (elem.children.unshift(child) !== 1) {
    var sibling = elem.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
  removeElement(prev);
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
exports.prepend = prepend;

/***/ }),

/***/ 3646:
/*!***********************************************!*\
  !*** ./node_modules/domutils/lib/querying.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ 68405);
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse, limit) {
  if (recurse === void 0) {
    recurse = true;
  }
  if (limit === void 0) {
    limit = Infinity;
  }
  if (!Array.isArray(node)) node = [node];
  return find(test, node, recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
  var result = [];
  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var elem = nodes_1[_i];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0) break;
    }
    if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
      var children = find(test, elem.children, recurse, limit);
      result.push.apply(result, children);
      limit -= children.length;
      if (limit <= 0) break;
    }
  }
  return result;
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
  return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne(test, nodes, recurse) {
  if (recurse === void 0) {
    recurse = true;
  }
  var elem = null;
  for (var i = 0; i < nodes.length && !elem; i++) {
    var checked = nodes[i];
    if (!(0, domhandler_1.isTag)(checked)) {
      continue;
    } else if (test(checked)) {
      elem = checked;
    } else if (recurse && checked.children.length > 0) {
      elem = findOne(test, checked.children);
    }
  }
  return elem;
}
exports.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne(test, nodes) {
  return nodes.some(function (checked) {
    return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
  });
}
exports.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
  var _a;
  var result = [];
  var stack = nodes.filter(domhandler_1.isTag);
  var elem;
  while (elem = stack.shift()) {
    var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
    if (children && children.length > 0) {
      stack.unshift.apply(stack, children);
    }
    if (test(elem)) result.push(elem);
  }
  return result;
}
exports.findAll = findAll;

/***/ }),

/***/ 69253:
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/stringify.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ 68405);
var dom_serializer_1 = __importDefault(__webpack_require__(/*! dom-serializer */ 98382));
var domelementtype_1 = __webpack_require__(/*! domelementtype */ 96485);
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
  return (0, dom_serializer_1.default)(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
  return (0, domhandler_1.hasChildren)(node) ? node.children.map(function (node) {
    return getOuterHTML(node, options);
  }).join("") : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
  if (Array.isArray(node)) return node.map(getText).join("");
  if ((0, domhandler_1.isTag)(node)) return node.name === "br" ? "\n" : getText(node.children);
  if ((0, domhandler_1.isCDATA)(node)) return getText(node.children);
  if ((0, domhandler_1.isText)(node)) return node.data;
  return "";
}
exports.getText = getText;
/**
 * Get a node's text content.
 *
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
  if (Array.isArray(node)) return node.map(textContent).join("");
  if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
    return textContent(node.children);
  }
  if ((0, domhandler_1.isText)(node)) return node.data;
  return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
  if (Array.isArray(node)) return node.map(innerText).join("");
  if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
    return innerText(node.children);
  }
  if ((0, domhandler_1.isText)(node)) return node.data;
  return "";
}
exports.innerText = innerText;

/***/ }),

/***/ 26410:
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/traversal.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __webpack_require__(/*! domhandler */ 68405);
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
  var _a;
  return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent(elem) {
  return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings(elem) {
  var _a, _b;
  var parent = getParent(elem);
  if (parent != null) return getChildren(parent);
  var siblings = [elem];
  var prev = elem.prev,
    next = elem.next;
  while (prev != null) {
    siblings.unshift(prev);
    _a = prev, prev = _a.prev;
  }
  while (next != null) {
    siblings.push(next);
    _b = next, next = _b.next;
  }
  return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
  var _a;
  return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
  return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
  var _a;
  var next = elem.next;
  while (next !== null && !(0, domhandler_1.isTag)(next)) _a = next, next = _a.next;
  return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
  var _a;
  var prev = elem.prev;
  while (prev !== null && !(0, domhandler_1.isTag)(prev)) _a = prev, prev = _a.prev;
  return prev;
}
exports.prevElementSibling = prevElementSibling;

/***/ }),

/***/ 47366:
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/decode.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ 94374));
var legacy_json_1 = __importDefault(__webpack_require__(/*! ./maps/legacy.json */ 51554));
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ 57178));
var decode_codepoint_1 = __importDefault(__webpack_require__(/*! ./decode_codepoint */ 23128));
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
  var replace = getReplacer(map);
  return function (str) {
    return String(str).replace(strictEntityRe, replace);
  };
}
var sorter = function (a, b) {
  return a < b ? 1 : -1;
};
exports.decodeHTML = function () {
  var legacy = Object.keys(legacy_json_1.default).sort(sorter);
  var keys = Object.keys(entities_json_1.default).sort(sorter);
  for (var i = 0, j = 0; i < keys.length; i++) {
    if (legacy[j] === keys[i]) {
      keys[i] += ";?";
      j++;
    } else {
      keys[i] += ";";
    }
  }
  var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
  var replace = getReplacer(entities_json_1.default);
  function replacer(str) {
    if (str.substr(-1) !== ";") str += ";";
    return replace(str);
  }
  // TODO consider creating a merged map
  return function (str) {
    return String(str).replace(re, replacer);
  };
}();
function getReplacer(map) {
  return function replace(str) {
    if (str.charAt(1) === "#") {
      var secondChar = str.charAt(2);
      if (secondChar === "X" || secondChar === "x") {
        return decode_codepoint_1.default(parseInt(str.substr(3), 16));
      }
      return decode_codepoint_1.default(parseInt(str.substr(2), 10));
    }
    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
    return map[str.slice(1, -1)] || str;
  };
}

/***/ }),

/***/ 23128:
/*!*******************************************************!*\
  !*** ./node_modules/entities/lib/decode_codepoint.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var decode_json_1 = __importDefault(__webpack_require__(/*! ./maps/decode.json */ 2559));
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint || function (codePoint) {
  var output = "";
  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function decodeCodePoint(codePoint) {
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }
  if (codePoint in decode_json_1.default) {
    codePoint = decode_json_1.default[codePoint];
  }
  return fromCodePoint(codePoint);
}
exports["default"] = decodeCodePoint;

/***/ }),

/***/ 32362:
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/encode.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ 57178));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ 94374));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
  return Object.keys(obj).sort().reduce(function (inverse, name) {
    inverse[obj[name]] = "&" + name + ";";
    return inverse;
  }, {});
}
function getInverseReplacer(inverse) {
  var single = [];
  var multiple = [];
  for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
    var k = _a[_i];
    if (k.length === 1) {
      // Add value to single array
      single.push("\\" + k);
    } else {
      // Add value to multiple array
      multiple.push(k);
    }
  }
  // Add ranges to single characters.
  single.sort();
  for (var start = 0; start < single.length - 1; start++) {
    // Find the end of a run of characters
    var end = start;
    while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
      end += 1;
    }
    var count = 1 + end - start;
    // We want to replace at least three characters
    if (count < 3) continue;
    single.splice(start, count, single[start] + "-" + single[end]);
  }
  multiple.unshift("[" + single.join("") + "]");
  return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null ?
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
function (str) {
  return str.codePointAt(0);
} :
// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
function (c) {
  return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;
};
function singleCharReplacer(c) {
  return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
  return function (data) {
    return data.replace(re, function (name) {
      return inverse[name];
    }).replace(reNonASCII, singleCharReplacer);
  };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape(data) {
  return data.replace(reEscapeChars, singleCharReplacer);
}
exports.escape = escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
  return data.replace(xmlReplacer, singleCharReplacer);
}
exports.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
  return function (data) {
    return data.replace(reEscapeChars, function (c) {
      return obj[c] || singleCharReplacer(c);
    });
  };
}

/***/ }),

/***/ 23194:
/*!********************************************!*\
  !*** ./node_modules/entities/lib/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __webpack_require__(/*! ./decode */ 47366);
var encode_1 = __webpack_require__(/*! ./encode */ 32362);
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode(data, level) {
  return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__(/*! ./encode */ 32362);
Object.defineProperty(exports, "encodeXML", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeXML;
  }
}));
Object.defineProperty(exports, "encodeHTML", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeHTML;
  }
}));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeNonAsciiHTML;
  }
}));
Object.defineProperty(exports, "escape", ({
  enumerable: true,
  get: function () {
    return encode_2.escape;
  }
}));
Object.defineProperty(exports, "escapeUTF8", ({
  enumerable: true,
  get: function () {
    return encode_2.escapeUTF8;
  }
}));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeHTML;
  }
}));
Object.defineProperty(exports, "encodeHTML5", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeHTML;
  }
}));
var decode_2 = __webpack_require__(/*! ./decode */ 47366);
Object.defineProperty(exports, "decodeXML", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeXML;
  }
}));
Object.defineProperty(exports, "decodeHTML", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTML;
  }
}));
Object.defineProperty(exports, "decodeHTMLStrict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTMLStrict;
  }
}));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTML;
  }
}));
Object.defineProperty(exports, "decodeHTML5", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTML;
  }
}));
Object.defineProperty(exports, "decodeHTML4Strict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTMLStrict;
  }
}));
Object.defineProperty(exports, "decodeHTML5Strict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTMLStrict;
  }
}));
Object.defineProperty(exports, "decodeXMLStrict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeXML;
  }
}));

/***/ }),

/***/ 77756:
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/***/ (function(module) {

"use strict";


module.exports = (flag, argv = process.argv) => {
  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf('--');
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};

/***/ }),

/***/ 73373:
/*!***********************************************!*\
  !*** ./node_modules/nth-check/lib/compile.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.generate = exports.compile = void 0;
var boolbase_1 = __importDefault(__webpack_require__(/*! boolbase */ 37424));
/**
 * Returns a function that checks if an elements index matches the given rule
 * highly optimized to return the fastest solution.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A highly optimized function that returns whether an index matches the nth-check.
 * @example
 *
 * ```js
 * const check = nthCheck.compile([2, 3]);
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 * ```
 */
function compile(parsed) {
  var a = parsed[0];
  // Subtract 1 from `b`, to convert from one- to zero-indexed.
  var b = parsed[1] - 1;
  /*
   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
   * Besides, the specification states that no elements are
   * matched when `a` and `b` are 0.
   *
   * `b < 0` here as we subtracted 1 from `b` above.
   */
  if (b < 0 && a <= 0) return boolbase_1.default.falseFunc;
  // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
  if (a === -1) return function (index) {
    return index <= b;
  };
  if (a === 0) return function (index) {
    return index === b;
  };
  // When `b <= 0` and `a === 1`, they match any element.
  if (a === 1) return b < 0 ? boolbase_1.default.trueFunc : function (index) {
    return index >= b;
  };
  /*
   * Otherwise, modulo can be used to check if there is a match.
   *
   * Modulo doesn't care about the sign, so let's use `a`s absolute value.
   */
  var absA = Math.abs(a);
  // Get `b mod a`, + a if this is negative.
  var bMod = (b % absA + absA) % absA;
  return a > 1 ? function (index) {
    return index >= b && index % absA === bMod;
  } : function (index) {
    return index <= b && index % absA === bMod;
  };
}
exports.compile = compile;
/**
 * Returns a function that produces a monotonously increasing sequence of indices.
 *
 * If the sequence has an end, the returned function will return `null` after
 * the last index in the sequence.
 *
 * @param parsed A tuple [a, b], as returned by `parse`.
 * @returns A function that produces a sequence of indices.
 * @example <caption>Always increasing (2n+3)</caption>
 *
 * ```js
 * const gen = nthCheck.generate([2, 3])
 *
 * gen() // `1`
 * gen() // `3`
 * gen() // `5`
 * gen() // `8`
 * gen() // `11`
 * ```
 *
 * @example <caption>With end value (-2n+10)</caption>
 *
 * ```js
 *
 * const gen = nthCheck.generate([-2, 5]);
 *
 * gen() // 0
 * gen() // 2
 * gen() // 4
 * gen() // null
 * ```
 */
function generate(parsed) {
  var a = parsed[0];
  // Subtract 1 from `b`, to convert from one- to zero-indexed.
  var b = parsed[1] - 1;
  var n = 0;
  // Make sure to always return an increasing sequence
  if (a < 0) {
    var aPos_1 = -a;
    // Get `b mod a`
    var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
    return function () {
      var val = minValue_1 + aPos_1 * n++;
      return val > b ? null : val;
    };
  }
  if (a === 0) return b < 0 ?
  // There are no result â€” always return `null`
  function () {
    return null;
  } :
  // Return `b` exactly once
  function () {
    return n++ === 0 ? b : null;
  };
  if (b < 0) {
    b += a * Math.ceil(-b / a);
  }
  return function () {
    return a * n++ + b;
  };
}
exports.generate = generate;

/***/ }),

/***/ 3268:
/*!*********************************************!*\
  !*** ./node_modules/nth-check/lib/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
var parse_js_1 = __webpack_require__(/*! ./parse.js */ 4871);
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return parse_js_1.parse;
  }
}));
var compile_js_1 = __webpack_require__(/*! ./compile.js */ 73373);
Object.defineProperty(exports, "compile", ({
  enumerable: true,
  get: function () {
    return compile_js_1.compile;
  }
}));
Object.defineProperty(exports, "generate", ({
  enumerable: true,
  get: function () {
    return compile_js_1.generate;
  }
}));
/**
 * Parses and compiles a formula to a highly optimized function.
 * Combination of {@link parse} and {@link compile}.
 *
 * If the formula doesn't match any elements,
 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
 * Otherwise, a function accepting an _index_ is returned, which returns
 * whether or not the passed _index_ matches the formula.
 *
 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
 *
 * @param formula The formula to compile.
 * @example
 * const check = nthCheck("2n+3");
 *
 * check(0); // `false`
 * check(1); // `false`
 * check(2); // `true`
 * check(3); // `false`
 * check(4); // `true`
 * check(5); // `false`
 * check(6); // `true`
 */
function nthCheck(formula) {
  return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
}
exports["default"] = nthCheck;
/**
 * Parses and compiles a formula to a generator that produces a sequence of indices.
 * Combination of {@link parse} and {@link generate}.
 *
 * @param formula The formula to compile.
 * @returns A function that produces a sequence of indices.
 * @example <caption>Always increasing</caption>
 *
 * ```js
 * const gen = nthCheck.sequence('2n+3')
 *
 * gen() // `1`
 * gen() // `3`
 * gen() // `5`
 * gen() // `8`
 * gen() // `11`
 * ```
 *
 * @example <caption>With end value</caption>
 *
 * ```js
 *
 * const gen = nthCheck.sequence('-2n+5');
 *
 * gen() // 0
 * gen() // 2
 * gen() // 4
 * gen() // null
 * ```
 */
function sequence(formula) {
  return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
}
exports.sequence = sequence;

/***/ }),

/***/ 4871:
/*!*********************************************!*\
  !*** ./node_modules/nth-check/lib/parse.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parse = void 0;
// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
var whitespace = new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
/**
 * Parses an expression.
 *
 * @throws An `Error` if parsing fails.
 * @returns An array containing the integer step size and the integer offset of the nth rule.
 * @example nthCheck.parse("2n+3"); // returns [2, 3]
 */
function parse(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
  var idx = 0;
  var a = 0;
  var sign = readSign();
  var number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  // Throw if there is anything else
  if (number === null || idx < formula.length) {
    throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    var start = idx;
    var value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    // Return `null` if we didn't read anything.
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
exports.parse = parse;

/***/ }),

/***/ 27319:
/*!*******************************************************************!*\
  !*** ./node_modules/parse5-htmlparser2-tree-adapter/lib/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


const doctype = __webpack_require__(/*! parse5/lib/common/doctype */ 74361);
const {
  DOCUMENT_MODE
} = __webpack_require__(/*! parse5/lib/common/html */ 20825);

//Conversion tables for DOM Level1 structure emulation
const nodeTypes = {
  element: 1,
  text: 3,
  cdata: 4,
  comment: 8
};
const nodePropertyShorthands = {
  tagName: 'name',
  childNodes: 'children',
  parentNode: 'parent',
  previousSibling: 'prev',
  nextSibling: 'next',
  nodeValue: 'data'
};

//Node
class Node {
  constructor(props) {
    for (const key of Object.keys(props)) {
      this[key] = props[key];
    }
  }
  get firstChild() {
    const children = this.children;
    return children && children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children && children[children.length - 1] || null;
  }
  get nodeType() {
    return nodeTypes[this.type] || nodeTypes.element;
  }
}
Object.keys(nodePropertyShorthands).forEach(key => {
  const shorthand = nodePropertyShorthands[key];
  Object.defineProperty(Node.prototype, key, {
    get: function () {
      return this[shorthand] || null;
    },
    set: function (val) {
      this[shorthand] = val;
      return val;
    }
  });
});

//Node construction
exports.createDocument = function () {
  return new Node({
    type: 'root',
    name: 'root',
    parent: null,
    prev: null,
    next: null,
    children: [],
    'x-mode': DOCUMENT_MODE.NO_QUIRKS
  });
};
exports.createDocumentFragment = function () {
  return new Node({
    type: 'root',
    name: 'root',
    parent: null,
    prev: null,
    next: null,
    children: []
  });
};
exports.createElement = function (tagName, namespaceURI, attrs) {
  const attribs = Object.create(null);
  const attribsNamespace = Object.create(null);
  const attribsPrefix = Object.create(null);
  for (let i = 0; i < attrs.length; i++) {
    const attrName = attrs[i].name;
    attribs[attrName] = attrs[i].value;
    attribsNamespace[attrName] = attrs[i].namespace;
    attribsPrefix[attrName] = attrs[i].prefix;
  }
  return new Node({
    type: tagName === 'script' || tagName === 'style' ? tagName : 'tag',
    name: tagName,
    namespace: namespaceURI,
    attribs: attribs,
    'x-attribsNamespace': attribsNamespace,
    'x-attribsPrefix': attribsPrefix,
    children: [],
    parent: null,
    prev: null,
    next: null
  });
};
exports.createCommentNode = function (data) {
  return new Node({
    type: 'comment',
    data: data,
    parent: null,
    prev: null,
    next: null
  });
};
const createTextNode = function (value) {
  return new Node({
    type: 'text',
    data: value,
    parent: null,
    prev: null,
    next: null
  });
};

//Tree mutation
const appendChild = exports.appendChild = function (parentNode, newNode) {
  const prev = parentNode.children[parentNode.children.length - 1];
  if (prev) {
    prev.next = newNode;
    newNode.prev = prev;
  }
  parentNode.children.push(newNode);
  newNode.parent = parentNode;
};
const insertBefore = exports.insertBefore = function (parentNode, newNode, referenceNode) {
  const insertionIdx = parentNode.children.indexOf(referenceNode);
  const prev = referenceNode.prev;
  if (prev) {
    prev.next = newNode;
    newNode.prev = prev;
  }
  referenceNode.prev = newNode;
  newNode.next = referenceNode;
  parentNode.children.splice(insertionIdx, 0, newNode);
  newNode.parent = parentNode;
};
exports.setTemplateContent = function (templateElement, contentElement) {
  appendChild(templateElement, contentElement);
};
exports.getTemplateContent = function (templateElement) {
  return templateElement.children[0];
};
exports.setDocumentType = function (document, name, publicId, systemId) {
  const data = doctype.serializeContent(name, publicId, systemId);
  let doctypeNode = null;
  for (let i = 0; i < document.children.length; i++) {
    if (document.children[i].type === 'directive' && document.children[i].name === '!doctype') {
      doctypeNode = document.children[i];
      break;
    }
  }
  if (doctypeNode) {
    doctypeNode.data = data;
    doctypeNode['x-name'] = name;
    doctypeNode['x-publicId'] = publicId;
    doctypeNode['x-systemId'] = systemId;
  } else {
    appendChild(document, new Node({
      type: 'directive',
      name: '!doctype',
      data: data,
      'x-name': name,
      'x-publicId': publicId,
      'x-systemId': systemId
    }));
  }
};
exports.setDocumentMode = function (document, mode) {
  document['x-mode'] = mode;
};
exports.getDocumentMode = function (document) {
  return document['x-mode'];
};
exports.detachNode = function (node) {
  if (node.parent) {
    const idx = node.parent.children.indexOf(node);
    const prev = node.prev;
    const next = node.next;
    node.prev = null;
    node.next = null;
    if (prev) {
      prev.next = next;
    }
    if (next) {
      next.prev = prev;
    }
    node.parent.children.splice(idx, 1);
    node.parent = null;
  }
};
exports.insertText = function (parentNode, text) {
  const lastChild = parentNode.children[parentNode.children.length - 1];
  if (lastChild && lastChild.type === 'text') {
    lastChild.data += text;
  } else {
    appendChild(parentNode, createTextNode(text));
  }
};
exports.insertTextBefore = function (parentNode, text, referenceNode) {
  const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
  if (prevNode && prevNode.type === 'text') {
    prevNode.data += text;
  } else {
    insertBefore(parentNode, createTextNode(text), referenceNode);
  }
};
exports.adoptAttributes = function (recipient, attrs) {
  for (let i = 0; i < attrs.length; i++) {
    const attrName = attrs[i].name;
    if (typeof recipient.attribs[attrName] === 'undefined') {
      recipient.attribs[attrName] = attrs[i].value;
      recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;
      recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;
    }
  }
};

//Tree traversing
exports.getFirstChild = function (node) {
  return node.children[0];
};
exports.getChildNodes = function (node) {
  return node.children;
};
exports.getParentNode = function (node) {
  return node.parent;
};
exports.getAttrList = function (element) {
  const attrList = [];
  for (const name in element.attribs) {
    attrList.push({
      name: name,
      value: element.attribs[name],
      namespace: element['x-attribsNamespace'][name],
      prefix: element['x-attribsPrefix'][name]
    });
  }
  return attrList;
};

//Node data
exports.getTagName = function (element) {
  return element.name;
};
exports.getNamespaceURI = function (element) {
  return element.namespace;
};
exports.getTextNodeContent = function (textNode) {
  return textNode.data;
};
exports.getCommentNodeContent = function (commentNode) {
  return commentNode.data;
};
exports.getDocumentTypeNodeName = function (doctypeNode) {
  return doctypeNode['x-name'];
};
exports.getDocumentTypeNodePublicId = function (doctypeNode) {
  return doctypeNode['x-publicId'];
};
exports.getDocumentTypeNodeSystemId = function (doctypeNode) {
  return doctypeNode['x-systemId'];
};

//Node types
exports.isTextNode = function (node) {
  return node.type === 'text';
};
exports.isCommentNode = function (node) {
  return node.type === 'comment';
};
exports.isDocumentTypeNode = function (node) {
  return node.type === 'directive' && node.name === '!doctype';
};
exports.isElementNode = function (node) {
  return !!node.attribs;
};

// Source code location
exports.setNodeSourceCodeLocation = function (node, location) {
  node.sourceCodeLocation = location;
};
exports.getNodeSourceCodeLocation = function (node) {
  return node.sourceCodeLocation;
};
exports.updateNodeSourceCodeLocation = function (node, endLocation) {
  node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
};

/***/ }),

/***/ 74361:
/*!************************************************************************************************!*\
  !*** ./node_modules/parse5-htmlparser2-tree-adapter/node_modules/parse5/lib/common/doctype.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


const {
  DOCUMENT_MODE
} = __webpack_require__(/*! ./html */ 20825);

//Const
const VALID_DOCTYPE_NAME = 'html';
const VALID_SYSTEM_ID = 'about:legacy-compat';
const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
const QUIRKS_MODE_PUBLIC_ID_PREFIXES = ['+//silmaril//dtd html pro v0r11 19970101//', '-//as//dtd html 3.0 aswedit + extensions//', '-//advasoft ltd//dtd html 3.0 aswedit + extensions//', '-//ietf//dtd html 2.0 level 1//', '-//ietf//dtd html 2.0 level 2//', '-//ietf//dtd html 2.0 strict level 1//', '-//ietf//dtd html 2.0 strict level 2//', '-//ietf//dtd html 2.0 strict//', '-//ietf//dtd html 2.0//', '-//ietf//dtd html 2.1e//', '-//ietf//dtd html 3.0//', '-//ietf//dtd html 3.2 final//', '-//ietf//dtd html 3.2//', '-//ietf//dtd html 3//', '-//ietf//dtd html level 0//', '-//ietf//dtd html level 1//', '-//ietf//dtd html level 2//', '-//ietf//dtd html level 3//', '-//ietf//dtd html strict level 0//', '-//ietf//dtd html strict level 1//', '-//ietf//dtd html strict level 2//', '-//ietf//dtd html strict level 3//', '-//ietf//dtd html strict//', '-//ietf//dtd html//', '-//metrius//dtd metrius presentational//', '-//microsoft//dtd internet explorer 2.0 html strict//', '-//microsoft//dtd internet explorer 2.0 html//', '-//microsoft//dtd internet explorer 2.0 tables//', '-//microsoft//dtd internet explorer 3.0 html strict//', '-//microsoft//dtd internet explorer 3.0 html//', '-//microsoft//dtd internet explorer 3.0 tables//', '-//netscape comm. corp.//dtd html//', '-//netscape comm. corp.//dtd strict html//', "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", '-//sq//dtd html 2.0 hotmetal + extensions//', '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//', '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//', '-//spyglass//dtd html 2.0 extended//', '-//sun microsystems corp.//dtd hotjava html//', '-//sun microsystems corp.//dtd hotjava strict html//', '-//w3c//dtd html 3 1995-03-24//', '-//w3c//dtd html 3.2 draft//', '-//w3c//dtd html 3.2 final//', '-//w3c//dtd html 3.2//', '-//w3c//dtd html 3.2s draft//', '-//w3c//dtd html 4.0 frameset//', '-//w3c//dtd html 4.0 transitional//', '-//w3c//dtd html experimental 19960712//', '-//w3c//dtd html experimental 970421//', '-//w3c//dtd w3 html//', '-//w3o//dtd w3 html 3.0//', '-//webtechs//dtd mozilla html 2.0//', '-//webtechs//dtd mozilla html//'];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat(['-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']);
const QUIRKS_MODE_PUBLIC_IDS = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'];
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat(['-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']);

//Utils
function enquoteDoctypeId(id) {
  const quote = id.indexOf('"') !== -1 ? "'" : '"';
  return quote + id + quote;
}
function hasPrefix(publicId, prefixes) {
  for (let i = 0; i < prefixes.length; i++) {
    if (publicId.indexOf(prefixes[i]) === 0) {
      return true;
    }
  }
  return false;
}

//API
exports.isConforming = function (token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
};
exports.getDocumentMode = function (token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const systemId = token.systemId;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let publicId = token.publicId;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
};
exports.serializeContent = function (name, publicId, systemId) {
  let str = '!DOCTYPE ';
  if (name) {
    str += name;
  }
  if (publicId) {
    str += ' PUBLIC ' + enquoteDoctypeId(publicId);
  } else if (systemId) {
    str += ' SYSTEM';
  }
  if (systemId !== null) {
    str += ' ' + enquoteDoctypeId(systemId);
  }
  return str;
};

/***/ }),

/***/ 20825:
/*!*********************************************************************************************!*\
  !*** ./node_modules/parse5-htmlparser2-tree-adapter/node_modules/parse5/lib/common/html.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


const NS = exports.NAMESPACES = {
  HTML: 'http://www.w3.org/1999/xhtml',
  MATHML: 'http://www.w3.org/1998/Math/MathML',
  SVG: 'http://www.w3.org/2000/svg',
  XLINK: 'http://www.w3.org/1999/xlink',
  XML: 'http://www.w3.org/XML/1998/namespace',
  XMLNS: 'http://www.w3.org/2000/xmlns/'
};
exports.ATTRS = {
  TYPE: 'type',
  ACTION: 'action',
  ENCODING: 'encoding',
  PROMPT: 'prompt',
  NAME: 'name',
  COLOR: 'color',
  FACE: 'face',
  SIZE: 'size'
};
exports.DOCUMENT_MODE = {
  NO_QUIRKS: 'no-quirks',
  QUIRKS: 'quirks',
  LIMITED_QUIRKS: 'limited-quirks'
};
const $ = exports.TAG_NAMES = {
  A: 'a',
  ADDRESS: 'address',
  ANNOTATION_XML: 'annotation-xml',
  APPLET: 'applet',
  AREA: 'area',
  ARTICLE: 'article',
  ASIDE: 'aside',
  B: 'b',
  BASE: 'base',
  BASEFONT: 'basefont',
  BGSOUND: 'bgsound',
  BIG: 'big',
  BLOCKQUOTE: 'blockquote',
  BODY: 'body',
  BR: 'br',
  BUTTON: 'button',
  CAPTION: 'caption',
  CENTER: 'center',
  CODE: 'code',
  COL: 'col',
  COLGROUP: 'colgroup',
  DD: 'dd',
  DESC: 'desc',
  DETAILS: 'details',
  DIALOG: 'dialog',
  DIR: 'dir',
  DIV: 'div',
  DL: 'dl',
  DT: 'dt',
  EM: 'em',
  EMBED: 'embed',
  FIELDSET: 'fieldset',
  FIGCAPTION: 'figcaption',
  FIGURE: 'figure',
  FONT: 'font',
  FOOTER: 'footer',
  FOREIGN_OBJECT: 'foreignObject',
  FORM: 'form',
  FRAME: 'frame',
  FRAMESET: 'frameset',
  H1: 'h1',
  H2: 'h2',
  H3: 'h3',
  H4: 'h4',
  H5: 'h5',
  H6: 'h6',
  HEAD: 'head',
  HEADER: 'header',
  HGROUP: 'hgroup',
  HR: 'hr',
  HTML: 'html',
  I: 'i',
  IMG: 'img',
  IMAGE: 'image',
  INPUT: 'input',
  IFRAME: 'iframe',
  KEYGEN: 'keygen',
  LABEL: 'label',
  LI: 'li',
  LINK: 'link',
  LISTING: 'listing',
  MAIN: 'main',
  MALIGNMARK: 'malignmark',
  MARQUEE: 'marquee',
  MATH: 'math',
  MENU: 'menu',
  META: 'meta',
  MGLYPH: 'mglyph',
  MI: 'mi',
  MO: 'mo',
  MN: 'mn',
  MS: 'ms',
  MTEXT: 'mtext',
  NAV: 'nav',
  NOBR: 'nobr',
  NOFRAMES: 'noframes',
  NOEMBED: 'noembed',
  NOSCRIPT: 'noscript',
  OBJECT: 'object',
  OL: 'ol',
  OPTGROUP: 'optgroup',
  OPTION: 'option',
  P: 'p',
  PARAM: 'param',
  PLAINTEXT: 'plaintext',
  PRE: 'pre',
  RB: 'rb',
  RP: 'rp',
  RT: 'rt',
  RTC: 'rtc',
  RUBY: 'ruby',
  S: 's',
  SCRIPT: 'script',
  SECTION: 'section',
  SELECT: 'select',
  SOURCE: 'source',
  SMALL: 'small',
  SPAN: 'span',
  STRIKE: 'strike',
  STRONG: 'strong',
  STYLE: 'style',
  SUB: 'sub',
  SUMMARY: 'summary',
  SUP: 'sup',
  TABLE: 'table',
  TBODY: 'tbody',
  TEMPLATE: 'template',
  TEXTAREA: 'textarea',
  TFOOT: 'tfoot',
  TD: 'td',
  TH: 'th',
  THEAD: 'thead',
  TITLE: 'title',
  TR: 'tr',
  TRACK: 'track',
  TT: 'tt',
  U: 'u',
  UL: 'ul',
  SVG: 'svg',
  VAR: 'var',
  WBR: 'wbr',
  XMP: 'xmp'
};
exports.SPECIAL_ELEMENTS = {
  [NS.HTML]: {
    [$.ADDRESS]: true,
    [$.APPLET]: true,
    [$.AREA]: true,
    [$.ARTICLE]: true,
    [$.ASIDE]: true,
    [$.BASE]: true,
    [$.BASEFONT]: true,
    [$.BGSOUND]: true,
    [$.BLOCKQUOTE]: true,
    [$.BODY]: true,
    [$.BR]: true,
    [$.BUTTON]: true,
    [$.CAPTION]: true,
    [$.CENTER]: true,
    [$.COL]: true,
    [$.COLGROUP]: true,
    [$.DD]: true,
    [$.DETAILS]: true,
    [$.DIR]: true,
    [$.DIV]: true,
    [$.DL]: true,
    [$.DT]: true,
    [$.EMBED]: true,
    [$.FIELDSET]: true,
    [$.FIGCAPTION]: true,
    [$.FIGURE]: true,
    [$.FOOTER]: true,
    [$.FORM]: true,
    [$.FRAME]: true,
    [$.FRAMESET]: true,
    [$.H1]: true,
    [$.H2]: true,
    [$.H3]: true,
    [$.H4]: true,
    [$.H5]: true,
    [$.H6]: true,
    [$.HEAD]: true,
    [$.HEADER]: true,
    [$.HGROUP]: true,
    [$.HR]: true,
    [$.HTML]: true,
    [$.IFRAME]: true,
    [$.IMG]: true,
    [$.INPUT]: true,
    [$.LI]: true,
    [$.LINK]: true,
    [$.LISTING]: true,
    [$.MAIN]: true,
    [$.MARQUEE]: true,
    [$.MENU]: true,
    [$.META]: true,
    [$.NAV]: true,
    [$.NOEMBED]: true,
    [$.NOFRAMES]: true,
    [$.NOSCRIPT]: true,
    [$.OBJECT]: true,
    [$.OL]: true,
    [$.P]: true,
    [$.PARAM]: true,
    [$.PLAINTEXT]: true,
    [$.PRE]: true,
    [$.SCRIPT]: true,
    [$.SECTION]: true,
    [$.SELECT]: true,
    [$.SOURCE]: true,
    [$.STYLE]: true,
    [$.SUMMARY]: true,
    [$.TABLE]: true,
    [$.TBODY]: true,
    [$.TD]: true,
    [$.TEMPLATE]: true,
    [$.TEXTAREA]: true,
    [$.TFOOT]: true,
    [$.TH]: true,
    [$.THEAD]: true,
    [$.TITLE]: true,
    [$.TR]: true,
    [$.TRACK]: true,
    [$.UL]: true,
    [$.WBR]: true,
    [$.XMP]: true
  },
  [NS.MATHML]: {
    [$.MI]: true,
    [$.MO]: true,
    [$.MN]: true,
    [$.MS]: true,
    [$.MTEXT]: true,
    [$.ANNOTATION_XML]: true
  },
  [NS.SVG]: {
    [$.TITLE]: true,
    [$.FOREIGN_OBJECT]: true,
    [$.DESC]: true
  }
};

/***/ }),

/***/ 33135:
/*!***********************************************!*\
  !*** ./node_modules/picocolors/picocolors.js ***!
  \***********************************************/
/***/ (function(module) {

let p = process || {},
  argv = p.argv || [],
  env = p.env || {};
let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
let formatter = (open, close, replace = open) => input => {
  let string = "" + input,
    index = string.indexOf(close, open.length);
  return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
};
let replaceClose = (string, close, replace, index) => {
  let result = "",
    cursor = 0;
  do {
    result += string.substring(cursor, index) + replace;
    cursor = index + close.length;
    index = string.indexOf(close, cursor);
  } while (~index);
  return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported) => {
  let f = enabled ? formatter : () => String;
  return {
    isColorSupported: enabled,
    reset: f("\x1b[0m", "\x1b[0m"),
    bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
    dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
    italic: f("\x1b[3m", "\x1b[23m"),
    underline: f("\x1b[4m", "\x1b[24m"),
    inverse: f("\x1b[7m", "\x1b[27m"),
    hidden: f("\x1b[8m", "\x1b[28m"),
    strikethrough: f("\x1b[9m", "\x1b[29m"),
    black: f("\x1b[30m", "\x1b[39m"),
    red: f("\x1b[31m", "\x1b[39m"),
    green: f("\x1b[32m", "\x1b[39m"),
    yellow: f("\x1b[33m", "\x1b[39m"),
    blue: f("\x1b[34m", "\x1b[39m"),
    magenta: f("\x1b[35m", "\x1b[39m"),
    cyan: f("\x1b[36m", "\x1b[39m"),
    white: f("\x1b[37m", "\x1b[39m"),
    gray: f("\x1b[90m", "\x1b[39m"),
    bgBlack: f("\x1b[40m", "\x1b[49m"),
    bgRed: f("\x1b[41m", "\x1b[49m"),
    bgGreen: f("\x1b[42m", "\x1b[49m"),
    bgYellow: f("\x1b[43m", "\x1b[49m"),
    bgBlue: f("\x1b[44m", "\x1b[49m"),
    bgMagenta: f("\x1b[45m", "\x1b[49m"),
    bgCyan: f("\x1b[46m", "\x1b[49m"),
    bgWhite: f("\x1b[47m", "\x1b[49m"),
    blackBright: f("\x1b[90m", "\x1b[39m"),
    redBright: f("\x1b[91m", "\x1b[39m"),
    greenBright: f("\x1b[92m", "\x1b[39m"),
    yellowBright: f("\x1b[93m", "\x1b[39m"),
    blueBright: f("\x1b[94m", "\x1b[39m"),
    magentaBright: f("\x1b[95m", "\x1b[39m"),
    cyanBright: f("\x1b[96m", "\x1b[39m"),
    whiteBright: f("\x1b[97m", "\x1b[39m"),
    bgBlackBright: f("\x1b[100m", "\x1b[49m"),
    bgRedBright: f("\x1b[101m", "\x1b[49m"),
    bgGreenBright: f("\x1b[102m", "\x1b[49m"),
    bgYellowBright: f("\x1b[103m", "\x1b[49m"),
    bgBlueBright: f("\x1b[104m", "\x1b[49m"),
    bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
    bgCyanBright: f("\x1b[106m", "\x1b[49m"),
    bgWhiteBright: f("\x1b[107m", "\x1b[49m")
  };
};
module.exports = createColors();
module.exports.createColors = createColors;

/***/ }),

/***/ 97804:
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/at-rule.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Container = __webpack_require__(/*! ./container */ 59553);
class AtRule extends Container {
  constructor(defaults) {
    super(defaults);
    this.type = 'atrule';
  }
  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.append(...children);
  }
  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = [];
    return super.prepend(...children);
  }
}
module.exports = AtRule;
AtRule.default = AtRule;
Container.registerAtRule(AtRule);

/***/ }),

/***/ 88091:
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/comment.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Node = __webpack_require__(/*! ./node */ 63344);
class Comment extends Node {
  constructor(defaults) {
    super(defaults);
    this.type = 'comment';
  }
}
module.exports = Comment;
Comment.default = Comment;

/***/ }),

/***/ 59553:
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/container.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Comment = __webpack_require__(/*! ./comment */ 88091);
let Declaration = __webpack_require__(/*! ./declaration */ 65350);
let Node = __webpack_require__(/*! ./node */ 63344);
let {
  isClean,
  my
} = __webpack_require__(/*! ./symbols */ 56119);
let AtRule, parse, Root, Rule;
function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes);
    delete i.source;
    return i;
  });
}
function markTreeDirty(node) {
  node[isClean] = false;
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markTreeDirty(i);
    }
  }
}
class Container extends Node {
  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last);
      for (let node of nodes) this.proxyOf.nodes.push(node);
    }
    this.markDirty();
    return this;
  }
  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween);
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween);
    }
  }
  each(callback) {
    if (!this.proxyOf.nodes) return undefined;
    let iterator = this.getIterator();
    let index, result;
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator];
      result = callback(this.proxyOf.nodes[index], index);
      if (result === false) break;
      this.indexes[iterator] += 1;
    }
    delete this.indexes[iterator];
    return result;
  }
  every(condition) {
    return this.nodes.every(condition);
  }
  getIterator() {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};
    this.lastEach += 1;
    let iterator = this.lastEach;
    this.indexes[iterator] = 0;
    return iterator;
  }
  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node;
        } else if (!node[prop]) {
          return node[prop];
        } else if (prop === 'each' || typeof prop === 'string' && prop.startsWith('walk')) {
          return (...args) => {
            return node[prop](...args.map(i => {
              if (typeof i === 'function') {
                return (child, index) => i(child.toProxy(), index);
              } else {
                return i;
              }
            }));
          };
        } else if (prop === 'every' || prop === 'some') {
          return cb => {
            return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
          };
        } else if (prop === 'root') {
          return () => node.root().toProxy();
        } else if (prop === 'nodes') {
          return node.nodes.map(i => i.toProxy());
        } else if (prop === 'first' || prop === 'last') {
          return node[prop].toProxy();
        } else {
          return node[prop];
        }
      },
      set(node, prop, value) {
        if (node[prop] === value) return true;
        node[prop] = value;
        if (prop === 'name' || prop === 'params' || prop === 'selector') {
          node.markDirty();
        }
        return true;
      }
    };
  }
  index(child) {
    if (typeof child === 'number') return child;
    if (child.proxyOf) child = child.proxyOf;
    return this.proxyOf.nodes.indexOf(child);
  }
  insertAfter(exist, add) {
    let existIndex = this.index(exist);
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
    existIndex = this.index(exist);
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  insertBefore(exist, add) {
    let existIndex = this.index(exist);
    let type = existIndex === 0 ? 'prepend' : false;
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
    existIndex = this.index(exist);
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  normalize(nodes, sample) {
    if (typeof nodes === 'string') {
      nodes = cleanSource(parse(nodes).nodes);
    } else if (typeof nodes === 'undefined') {
      nodes = [];
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0);
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore');
      }
    } else if (nodes.type === 'root' && this.type !== 'document') {
      nodes = nodes.nodes.slice(0);
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore');
      }
    } else if (nodes.type) {
      nodes = [nodes];
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation');
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value);
      }
      nodes = [new Declaration(nodes)];
    } else if (nodes.selector || nodes.selectors) {
      nodes = [new Rule(nodes)];
    } else if (nodes.name) {
      nodes = [new AtRule(nodes)];
    } else if (nodes.text) {
      nodes = [new Comment(nodes)];
    } else {
      throw new Error('Unknown node type in node creation');
    }
    let processed = nodes.map(i => {
      /* c8 ignore next */
      if (!i[my]) Container.rebuild(i);
      i = i.proxyOf;
      if (i.parent) i.parent.removeChild(i);
      if (i[isClean]) markTreeDirty(i);
      if (!i.raws) i.raws = {};
      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/\S/g, '');
        }
      }
      i.parent = this.proxyOf;
      return i;
    });
    return processed;
  }
  prepend(...children) {
    children = children.reverse();
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse();
      for (let node of nodes) this.proxyOf.nodes.unshift(node);
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length;
      }
    }
    this.markDirty();
    return this;
  }
  push(child) {
    child.parent = this;
    this.proxyOf.nodes.push(child);
    return this;
  }
  removeAll() {
    for (let node of this.proxyOf.nodes) node.parent = undefined;
    this.proxyOf.nodes = [];
    this.markDirty();
    return this;
  }
  removeChild(child) {
    child = this.index(child);
    this.proxyOf.nodes[child].parent = undefined;
    this.proxyOf.nodes.splice(child, 1);
    let index;
    for (let id in this.indexes) {
      index = this.indexes[id];
      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }
    this.markDirty();
    return this;
  }
  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = {};
    }
    this.walkDecls(decl => {
      if (opts.props && !opts.props.includes(decl.prop)) return;
      if (opts.fast && !decl.value.includes(opts.fast)) return;
      decl.value = decl.value.replace(pattern, callback);
    });
    this.markDirty();
    return this;
  }
  some(condition) {
    return this.nodes.some(condition);
  }
  walk(callback) {
    return this.each((child, i) => {
      let result;
      try {
        result = callback(child, i);
      } catch (e) {
        throw child.addToError(e);
      }
      if (result !== false && child.walk) {
        result = child.walk(callback);
      }
      return result;
    });
  }
  walkAtRules(name, callback) {
    if (!callback) {
      callback = name;
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i);
        }
      });
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i);
        }
      });
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i);
      }
    });
  }
  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i);
      }
    });
  }
  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop;
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i);
        }
      });
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i);
        }
      });
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i);
      }
    });
  }
  walkRules(selector, callback) {
    if (!callback) {
      callback = selector;
      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i);
        }
      });
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i);
        }
      });
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i);
      }
    });
  }
  get first() {
    if (!this.proxyOf.nodes) return undefined;
    return this.proxyOf.nodes[0];
  }
  get last() {
    if (!this.proxyOf.nodes) return undefined;
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
}
Container.registerParse = dependant => {
  parse = dependant;
};
Container.registerRule = dependant => {
  Rule = dependant;
};
Container.registerAtRule = dependant => {
  AtRule = dependant;
};
Container.registerRoot = dependant => {
  Root = dependant;
};
module.exports = Container;
Container.default = Container;

/* c8 ignore start */
Container.rebuild = node => {
  if (node.type === 'atrule') {
    Object.setPrototypeOf(node, AtRule.prototype);
  } else if (node.type === 'rule') {
    Object.setPrototypeOf(node, Rule.prototype);
  } else if (node.type === 'decl') {
    Object.setPrototypeOf(node, Declaration.prototype);
  } else if (node.type === 'comment') {
    Object.setPrototypeOf(node, Comment.prototype);
  } else if (node.type === 'root') {
    Object.setPrototypeOf(node, Root.prototype);
  }
  node[my] = true;
  if (node.nodes) {
    node.nodes.forEach(child => {
      Container.rebuild(child);
    });
  }
};
/* c8 ignore stop */

/***/ }),

/***/ 71118:
/*!******************************************************!*\
  !*** ./node_modules/postcss/lib/css-syntax-error.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let pico = __webpack_require__(/*! picocolors */ 33135);
let terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ 46837);
class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message);
    this.name = 'CssSyntaxError';
    this.reason = message;
    if (file) {
      this.file = file;
    }
    if (source) {
      this.source = source;
    }
    if (plugin) {
      this.plugin = plugin;
    }
    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      if (typeof line === 'number') {
        this.line = line;
        this.column = column;
      } else {
        this.line = line.line;
        this.column = line.column;
        this.endLine = column.line;
        this.endColumn = column.column;
      }
    }
    this.setMessage();
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError);
    }
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ': ' : '';
    this.message += this.file ? this.file : '<css input>';
    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column;
    }
    this.message += ': ' + this.reason;
  }
  showSourceCode(color) {
    if (!this.source) return '';
    let css = this.source;
    if (color == null) color = pico.isColorSupported;
    let aside = text => text;
    let mark = text => text;
    let highlight = text => text;
    if (color) {
      let {
        bold,
        gray,
        red
      } = pico.createColors(true);
      mark = text => bold(red(text));
      aside = text => gray(text);
      if (terminalHighlight) {
        highlight = text => terminalHighlight(text);
      }
    }
    let lines = css.split(/\r?\n/);
    let start = Math.max(this.line - 3, 0);
    let end = Math.min(this.line + 2, lines.length);
    let maxWidth = String(end).length;
    return lines.slice(start, end).map((line, index) => {
      let number = start + 1 + index;
      let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';
      if (number === this.line) {
        if (line.length > 160) {
          let padding = 20;
          let subLineStart = Math.max(0, this.column - padding);
          let subLineEnd = Math.max(this.column + padding, this.endColumn + padding);
          let subLine = line.slice(subLineStart, subLineEnd);
          let spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, ' ');
          return mark('>') + aside(gutter) + highlight(subLine) + '\n ' + spacing + mark('^');
        }
        let spacing = aside(gutter.replace(/\d/g, ' ')) + line.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
        return mark('>') + aside(gutter) + highlight(line) + '\n ' + spacing + mark('^');
      }
      return ' ' + aside(gutter) + highlight(line);
    }).join('\n');
  }
  toString() {
    let code = this.showSourceCode();
    if (code) {
      code = '\n\n' + code + '\n';
    }
    return this.name + ': ' + this.message + code;
  }
}
module.exports = CssSyntaxError;
CssSyntaxError.default = CssSyntaxError;

/***/ }),

/***/ 65350:
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/declaration.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Node = __webpack_require__(/*! ./node */ 63344);
class Declaration extends Node {
  constructor(defaults) {
    if (defaults && typeof defaults.value !== 'undefined' && typeof defaults.value !== 'string') {
      defaults = {
        ...defaults,
        value: String(defaults.value)
      };
    }
    super(defaults);
    this.type = 'decl';
  }
  get variable() {
    return this.prop.startsWith('--') || this.prop[0] === '$';
  }
}
module.exports = Declaration;
Declaration.default = Declaration;

/***/ }),

/***/ 97617:
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/document.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Container = __webpack_require__(/*! ./container */ 59553);
let LazyResult, Processor;
class Document extends Container {
  constructor(defaults) {
    // type needs to be passed to super, otherwise child roots won't be normalized correctly
    super({
      type: 'document',
      ...defaults
    });
    if (!this.nodes) {
      this.nodes = [];
    }
  }
  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts);
    return lazy.stringify();
  }
}
Document.registerLazyResult = dependant => {
  LazyResult = dependant;
};
Document.registerProcessor = dependant => {
  Processor = dependant;
};
module.exports = Document;
Document.default = Document;

/***/ }),

/***/ 53758:
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/fromJSON.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let AtRule = __webpack_require__(/*! ./at-rule */ 97804);
let Comment = __webpack_require__(/*! ./comment */ 88091);
let Declaration = __webpack_require__(/*! ./declaration */ 65350);
let Input = __webpack_require__(/*! ./input */ 68946);
let PreviousMap = __webpack_require__(/*! ./previous-map */ 72758);
let Root = __webpack_require__(/*! ./root */ 74412);
let Rule = __webpack_require__(/*! ./rule */ 10302);
function fromJSON(json, inputs) {
  if (Array.isArray(json)) return json.map(n => fromJSON(n));
  let {
    inputs: ownInputs,
    ...defaults
  } = json;
  if (ownInputs) {
    inputs = [];
    for (let input of ownInputs) {
      let inputHydrated = {
        ...input,
        __proto__: Input.prototype
      };
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap.prototype
        };
      }
      inputs.push(inputHydrated);
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));
  }
  if (defaults.source) {
    let {
      inputId,
      ...source
    } = defaults.source;
    defaults.source = source;
    if (inputId != null) {
      defaults.source.input = inputs[inputId];
    }
  }
  if (defaults.type === 'root') {
    return new Root(defaults);
  } else if (defaults.type === 'decl') {
    return new Declaration(defaults);
  } else if (defaults.type === 'rule') {
    return new Rule(defaults);
  } else if (defaults.type === 'comment') {
    return new Comment(defaults);
  } else if (defaults.type === 'atrule') {
    return new AtRule(defaults);
  } else {
    throw new Error('Unknown node type: ' + json.type);
  }
}
module.exports = fromJSON;
fromJSON.default = fromJSON;

/***/ }),

/***/ 68946:
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/input.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let {
  nanoid
} = __webpack_require__(/*! nanoid/non-secure */ 19169);
let {
  isAbsolute,
  resolve
} = __webpack_require__(/*! path */ 16928);
let {
  SourceMapConsumer,
  SourceMapGenerator
} = __webpack_require__(/*! source-map-js */ 34755);
let {
  fileURLToPath,
  pathToFileURL
} = __webpack_require__(/*! url */ 87016);
let CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ 71118);
let PreviousMap = __webpack_require__(/*! ./previous-map */ 72758);
let terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ 46837);
let fromOffsetCache = Symbol('fromOffsetCache');
let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
let pathAvailable = Boolean(resolve && isAbsolute);
class Input {
  constructor(css, opts = {}) {
    if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {
      throw new Error(`PostCSS received ${css} instead of CSS string`);
    }
    this.css = css.toString();
    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true;
      this.css = this.css.slice(1);
    } else {
      this.hasBOM = false;
    }
    this.document = this.css;
    if (opts.document) this.document = opts.document.toString();
    if (opts.from) {
      if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
        this.file = opts.from;
      } else {
        this.file = resolve(opts.from);
      }
    }
    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts);
      if (map.text) {
        this.map = map;
        let file = map.consumer().file;
        if (!this.file && file) this.file = this.mapResolve(file);
      }
    }
    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>';
    }
    if (this.map) this.map.file = this.from;
  }
  error(message, line, column, opts = {}) {
    let endColumn, endLine, result;
    if (line && typeof line === 'object') {
      let start = line;
      let end = column;
      if (typeof start.offset === 'number') {
        let pos = this.fromOffset(start.offset);
        line = pos.line;
        column = pos.col;
      } else {
        line = start.line;
        column = start.column;
      }
      if (typeof end.offset === 'number') {
        let pos = this.fromOffset(end.offset);
        endLine = pos.line;
        endColumn = pos.col;
      } else {
        endLine = end.line;
        endColumn = end.column;
      }
    } else if (!column) {
      let pos = this.fromOffset(line);
      line = pos.line;
      column = pos.col;
    }
    let origin = this.origin(line, column, endLine, endColumn);
    if (origin) {
      result = new CssSyntaxError(message, origin.endLine === undefined ? origin.line : {
        column: origin.column,
        line: origin.line
      }, origin.endLine === undefined ? origin.column : {
        column: origin.endColumn,
        line: origin.endLine
      }, origin.source, origin.file, opts.plugin);
    } else {
      result = new CssSyntaxError(message, endLine === undefined ? line : {
        column,
        line
      }, endLine === undefined ? column : {
        column: endColumn,
        line: endLine
      }, this.css, this.file, opts.plugin);
    }
    result.input = {
      column,
      endColumn,
      endLine,
      line,
      source: this.css
    };
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString();
      }
      result.input.file = this.file;
    }
    return result;
  }
  fromOffset(offset) {
    let lastLine, lineToIndex;
    if (!this[fromOffsetCache]) {
      let lines = this.css.split('\n');
      lineToIndex = new Array(lines.length);
      let prevIndex = 0;
      for (let i = 0, l = lines.length; i < l; i++) {
        lineToIndex[i] = prevIndex;
        prevIndex += lines[i].length + 1;
      }
      this[fromOffsetCache] = lineToIndex;
    } else {
      lineToIndex = this[fromOffsetCache];
    }
    lastLine = lineToIndex[lineToIndex.length - 1];
    let min = 0;
    if (offset >= lastLine) {
      min = lineToIndex.length - 1;
    } else {
      let max = lineToIndex.length - 2;
      let mid;
      while (min < max) {
        mid = min + (max - min >> 1);
        if (offset < lineToIndex[mid]) {
          max = mid - 1;
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1;
        } else {
          min = mid;
          break;
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    };
  }
  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file;
    }
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file);
  }
  origin(line, column, endLine, endColumn) {
    if (!this.map) return false;
    let consumer = this.map.consumer();
    let from = consumer.originalPositionFor({
      column,
      line
    });
    if (!from.source) return false;
    let to;
    if (typeof endLine === 'number') {
      to = consumer.originalPositionFor({
        column: endColumn,
        line: endLine
      });
    }
    let fromUrl;
    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source);
    } else {
      fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile));
    }
    let result = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    };
    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl);
      } else {
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`);
      }
    }
    let source = consumer.sourceContentFor(from.source);
    if (source) result.source = source;
    return result;
  }
  toJSON() {
    let json = {};
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name];
      }
    }
    if (this.map) {
      json.map = {
        ...this.map
      };
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined;
      }
    }
    return json;
  }
  get from() {
    return this.file || this.id;
  }
}
module.exports = Input;
Input.default = Input;
if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input);
}

/***/ }),

/***/ 19750:
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/lazy-result.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _asyncToGenerator = (__webpack_require__(/*! ./node_modules/@babel/runtime/helpers/asyncToGenerator.js */ 95386)["default"]);
let Container = __webpack_require__(/*! ./container */ 59553);
let Document = __webpack_require__(/*! ./document */ 97617);
let MapGenerator = __webpack_require__(/*! ./map-generator */ 87428);
let parse = __webpack_require__(/*! ./parse */ 85513);
let Result = __webpack_require__(/*! ./result */ 20629);
let Root = __webpack_require__(/*! ./root */ 74412);
let stringify = __webpack_require__(/*! ./stringify */ 17767);
let {
  isClean,
  my
} = __webpack_require__(/*! ./symbols */ 56119);
let warnOnce = __webpack_require__(/*! ./warn-once */ 82924);
const TYPE_TO_CLASS_NAME = {
  atrule: 'AtRule',
  comment: 'Comment',
  decl: 'Declaration',
  document: 'Document',
  root: 'Root',
  rule: 'Rule'
};
const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
};
const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
};
const CHILDREN = 0;
function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function';
}
function getEvents(node) {
  let key = false;
  let type = TYPE_TO_CLASS_NAME[node.type];
  if (node.type === 'decl') {
    key = node.prop.toLowerCase();
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase();
  }
  if (key && node.append) {
    return [type, type + '-' + key, CHILDREN, type + 'Exit', type + 'Exit-' + key];
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key];
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit'];
  } else {
    return [type, type + 'Exit'];
  }
}
function toStack(node) {
  let events;
  if (node.type === 'document') {
    events = ['Document', CHILDREN, 'DocumentExit'];
  } else if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit'];
  } else {
    events = getEvents(node);
  }
  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node,
    visitorIndex: 0,
    visitors: []
  };
}
function cleanMarks(node) {
  node[isClean] = false;
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i));
  return node;
}
let postcss = {};
class LazyResult {
  constructor(processor, css, opts) {
    this.stringified = false;
    this.processed = false;
    let root;
    if (typeof css === 'object' && css !== null && (css.type === 'root' || css.type === 'document')) {
      root = cleanMarks(css);
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root);
      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {};
        if (!opts.map.inline) opts.map.inline = false;
        opts.map.prev = css.map;
      }
    } else {
      let parser = parse;
      if (opts.syntax) parser = opts.syntax.parse;
      if (opts.parser) parser = opts.parser;
      if (parser.parse) parser = parser.parse;
      try {
        root = parser(css, opts);
      } catch (error) {
        this.processed = true;
        this.error = error;
      }
      if (root && !root[my]) {
        /* c8 ignore next 2 */
        Container.rebuild(root);
      }
    }
    this.result = new Result(processor, root, opts);
    this.helpers = {
      ...postcss,
      postcss,
      result: this.result
    };
    this.plugins = this.processor.plugins.map(plugin => {
      if (typeof plugin === 'object' && plugin.prepare) {
        return {
          ...plugin,
          ...plugin.prepare(this.result)
        };
      } else {
        return plugin;
      }
    });
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    if (this.processed) return Promise.resolve(this.result);
    if (!this.processing) {
      this.processing = this.runAsync();
    }
    return this.processing;
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  getAsyncError() {
    throw new Error('Use process(css).then(cb) to work with async plugins');
  }
  handleError(error, node) {
    let plugin = this.result.lastPlugin;
    try {
      if (node) node.addToError(error);
      this.error = error;
      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin;
        error.setMessage();
      } else if (plugin.postcssVersion) {
        if (true) {
          let pluginName = plugin.postcssPlugin;
          let pluginVer = plugin.postcssVersion;
          let runtimeVer = this.result.processor.version;
          let a = pluginVer.split('.');
          let b = runtimeVer.split('.');
          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            // eslint-disable-next-line no-console
            console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');
          }
        }
      }
    } catch (err) {
      /* c8 ignore next 3 */
      // eslint-disable-next-line no-console
      if (console && console.error) console.error(err);
    }
    return error;
  }
  prepareVisitors() {
    this.listeners = {};
    let add = (plugin, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = [];
      this.listeners[type].push([plugin, cb]);
    };
    for (let plugin of this.plugins) {
      if (typeof plugin === 'object') {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(`Unknown event ${event} in ${plugin.postcssPlugin}. ` + `Try to update PostCSS (${this.processor.version} now).`);
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === 'object') {
              for (let filter in plugin[event]) {
                if (filter === '*') {
                  add(plugin, event, plugin[event][filter]);
                } else {
                  add(plugin, event + '-' + filter.toLowerCase(), plugin[event][filter]);
                }
              }
            } else if (typeof plugin[event] === 'function') {
              add(plugin, event, plugin[event]);
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  runAsync() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.plugin = 0;
      for (let i = 0; i < _this.plugins.length; i++) {
        let plugin = _this.plugins[i];
        let promise = _this.runOnRoot(plugin);
        if (isPromise(promise)) {
          try {
            yield promise;
          } catch (error) {
            throw _this.handleError(error);
          }
        }
      }
      _this.prepareVisitors();
      if (_this.hasListener) {
        let root = _this.result.root;
        while (!root[isClean]) {
          root[isClean] = true;
          let stack = [toStack(root)];
          while (stack.length > 0) {
            let promise = _this.visitTick(stack);
            if (isPromise(promise)) {
              try {
                yield promise;
              } catch (e) {
                let node = stack[stack.length - 1].node;
                throw _this.handleError(e, node);
              }
            }
          }
        }
        if (_this.listeners.OnceExit) {
          for (let [plugin, visitor] of _this.listeners.OnceExit) {
            _this.result.lastPlugin = plugin;
            try {
              if (root.type === 'document') {
                let roots = root.nodes.map(subRoot => visitor(subRoot, _this.helpers));
                yield Promise.all(roots);
              } else {
                yield visitor(root, _this.helpers);
              }
            } catch (e) {
              throw _this.handleError(e);
            }
          }
        }
      }
      _this.processed = true;
      return _this.stringify();
    })();
  }
  runOnRoot(plugin) {
    this.result.lastPlugin = plugin;
    try {
      if (typeof plugin === 'object' && plugin.Once) {
        if (this.result.root.type === 'document') {
          let roots = this.result.root.nodes.map(root => plugin.Once(root, this.helpers));
          if (isPromise(roots[0])) {
            return Promise.all(roots);
          }
          return roots;
        }
        return plugin.Once(this.result.root, this.helpers);
      } else if (typeof plugin === 'function') {
        return plugin(this.result.root, this.result);
      }
    } catch (error) {
      throw this.handleError(error);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true;
    this.sync();
    let opts = this.result.opts;
    let str = stringify;
    if (opts.syntax) str = opts.syntax.stringify;
    if (opts.stringifier) str = opts.stringifier;
    if (str.stringify) str = str.stringify;
    let map = new MapGenerator(str, this.result.root, this.result.opts);
    let data = map.generate();
    this.result.css = data[0];
    this.result.map = data[1];
    return this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    this.processed = true;
    if (this.processing) {
      throw this.getAsyncError();
    }
    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin);
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
    this.prepareVisitors();
    if (this.hasListener) {
      let root = this.result.root;
      while (!root[isClean]) {
        root[isClean] = true;
        this.walkSync(root);
      }
      if (this.listeners.OnceExit) {
        if (root.type === 'document') {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot);
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root);
        }
      }
    }
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!('from' in this.opts)) {
        warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this.css;
  }
  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin;
      let promise;
      try {
        promise = visitor(node, this.helpers);
      } catch (e) {
        throw this.handleError(e, node.proxyOf);
      }
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        return true;
      }
      if (isPromise(promise)) {
        throw this.getAsyncError();
      }
    }
  }
  visitTick(stack) {
    let visit = stack[stack.length - 1];
    let {
      node,
      visitors
    } = visit;
    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
      stack.pop();
      return;
    }
    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex];
      visit.visitorIndex += 1;
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = [];
        visit.visitorIndex = 0;
      }
      this.result.lastPlugin = plugin;
      try {
        return visitor(node.toProxy(), this.helpers);
      } catch (e) {
        throw this.handleError(e, node);
      }
    }
    if (visit.iterator !== 0) {
      let iterator = visit.iterator;
      let child;
      while (child = node.nodes[node.indexes[iterator]]) {
        node.indexes[iterator] += 1;
        if (!child[isClean]) {
          child[isClean] = true;
          stack.push(toStack(child));
          return;
        }
      }
      visit.iterator = 0;
      delete node.indexes[iterator];
    }
    let events = visit.events;
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex];
      visit.eventIndex += 1;
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true;
          visit.iterator = node.getIterator();
        }
        return;
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event];
        return;
      }
    }
    stack.pop();
  }
  walkSync(node) {
    node[isClean] = true;
    let events = getEvents(node);
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each(child => {
            if (!child[isClean]) this.walkSync(child);
          });
        }
      } else {
        let visitors = this.listeners[event];
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy())) return;
        }
      }
    }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return 'LazyResult';
  }
}
LazyResult.registerPostcss = dependant => {
  postcss = dependant;
};
module.exports = LazyResult;
LazyResult.default = LazyResult;
Root.registerLazyResult(LazyResult);
Document.registerLazyResult(LazyResult);

/***/ }),

/***/ 53272:
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/list.js ***!
  \******************************************/
/***/ (function(module) {

"use strict";


let list = {
  comma(string) {
    return list.split(string, [','], true);
  },
  space(string) {
    let spaces = [' ', '\n', '\t'];
    return list.split(string, spaces);
  },
  split(string, separators, last) {
    let array = [];
    let current = '';
    let split = false;
    let func = 0;
    let inQuote = false;
    let prevQuote = '';
    let escape = false;
    for (let letter of string) {
      if (escape) {
        escape = false;
      } else if (letter === '\\') {
        escape = true;
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false;
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true;
        prevQuote = letter;
      } else if (letter === '(') {
        func += 1;
      } else if (letter === ')') {
        if (func > 0) func -= 1;
      } else if (func === 0) {
        if (separators.includes(letter)) split = true;
      }
      if (split) {
        if (current !== '') array.push(current.trim());
        current = '';
        split = false;
      } else {
        current += letter;
      }
    }
    if (last || current !== '') array.push(current.trim());
    return array;
  }
};
module.exports = list;
list.default = list;

/***/ }),

/***/ 87428:
/*!***************************************************!*\
  !*** ./node_modules/postcss/lib/map-generator.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let {
  dirname,
  relative,
  resolve,
  sep
} = __webpack_require__(/*! path */ 16928);
let {
  SourceMapConsumer,
  SourceMapGenerator
} = __webpack_require__(/*! source-map-js */ 34755);
let {
  pathToFileURL
} = __webpack_require__(/*! url */ 87016);
let Input = __webpack_require__(/*! ./input */ 68946);
let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
let pathAvailable = Boolean(dirname && resolve && relative && sep);
class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify;
    this.mapOpts = opts.map || {};
    this.root = root;
    this.opts = opts;
    this.css = cssString;
    this.originalCSS = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = new Map();
    this.memoizedPaths = new Map();
    this.memoizedURLs = new Map();
  }
  addAnnotation() {
    let content;
    if (this.isInline()) {
      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation;
    } else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root);
    } else {
      content = this.outputFile() + '.map';
    }
    let eol = '\n';
    if (this.css.includes('\r\n')) eol = '\r\n';
    this.css += eol + '/*# sourceMappingURL=' + content + ' */';
  }
  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file));
      let root = prev.root || dirname(prev.file);
      let map;
      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text);
        if (map.sourcesContent) {
          map.sourcesContent = null;
        }
      } else {
        map = prev.consumer();
      }
      this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation === false) return;
    if (this.root) {
      let node;
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i];
        if (node.type !== 'comment') continue;
        if (node.text.startsWith('# sourceMappingURL=')) {
          this.root.removeChild(i);
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, '');
    }
  }
  generate() {
    this.clearAnnotation();
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap();
    } else {
      let result = '';
      this.stringify(this.root, i => {
        result += i;
      });
      return [result];
    }
  }
  generateMap() {
    if (this.root) {
      this.generateString();
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer();
      prev.file = this.outputFile();
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      });
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      this.map.addMapping({
        generated: {
          column: 0,
          line: 1
        },
        original: {
          column: 0,
          line: 1
        },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>'
      });
    }
    if (this.isSourcesContent()) this.setSourcesContent();
    if (this.root && this.previous().length > 0) this.applyPrevMaps();
    if (this.isAnnotation()) this.addAnnotation();
    if (this.isInline()) {
      return [this.css];
    } else {
      return [this.css, this.map];
    }
  }
  generateString() {
    this.css = '';
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    });
    let line = 1;
    let column = 1;
    let noSource = '<no source>';
    let mapping = {
      generated: {
        column: 0,
        line: 0
      },
      original: {
        column: 0,
        line: 0
      },
      source: ''
    };
    let last, lines;
    this.stringify(this.root, (str, node, type) => {
      this.css += str;
      if (node && type !== 'end') {
        mapping.generated.line = line;
        mapping.generated.column = column - 1;
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node);
          mapping.original.line = node.source.start.line;
          mapping.original.column = node.source.start.column - 1;
          this.map.addMapping(mapping);
        } else {
          mapping.source = noSource;
          mapping.original.line = 1;
          mapping.original.column = 0;
          this.map.addMapping(mapping);
        }
      }
      lines = str.match(/\n/g);
      if (lines) {
        line += lines.length;
        last = str.lastIndexOf('\n');
        column = str.length - last;
      } else {
        column += str.length;
      }
      if (node && type !== 'start') {
        let p = node.parent || {
          raws: {}
        };
        let childless = node.type === 'decl' || node.type === 'atrule' && !node.nodes;
        if (!childless || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node);
            mapping.original.line = node.source.end.line;
            mapping.original.column = node.source.end.column - 1;
            mapping.generated.line = line;
            mapping.generated.column = column - 2;
            this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            this.map.addMapping(mapping);
          }
        }
      }
    });
  }
  isAnnotation() {
    if (this.isInline()) {
      return true;
    }
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation;
    }
    if (this.previous().length) {
      return this.previous().some(i => i.annotation);
    }
    return true;
  }
  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline;
    }
    let annotation = this.mapOpts.annotation;
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false;
    }
    if (this.previous().length) {
      return this.previous().some(i => i.inline);
    }
    return true;
  }
  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map;
    }
    return this.previous().length > 0;
  }
  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent;
    }
    if (this.previous().length) {
      return this.previous().some(i => i.withContent());
    }
    return true;
  }
  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to);
    } else if (this.opts.from) {
      return this.path(this.opts.from);
    } else {
      return 'to.css';
    }
  }
  path(file) {
    if (this.mapOpts.absolute) return file;
    if (file.charCodeAt(0) === 60 /* `<` */) return file;
    if (/^\w+:\/\//.test(file)) return file;
    let cached = this.memoizedPaths.get(file);
    if (cached) return cached;
    let from = this.opts.to ? dirname(this.opts.to) : '.';
    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation));
    }
    let path = relative(from, file);
    this.memoizedPaths.set(file, path);
    return path;
  }
  previous() {
    if (!this.previousMaps) {
      this.previousMaps = [];
      if (this.root) {
        this.root.walk(node => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map;
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map);
            }
          }
        });
      } else {
        let input = new Input(this.originalCSS, this.opts);
        if (input.map) this.previousMaps.push(input.map);
      }
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let already = {};
    if (this.root) {
      this.root.walk(node => {
        if (node.source) {
          let from = node.source.input.from;
          if (from && !already[from]) {
            already[from] = true;
            let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
            this.map.setSourceContent(fromUrl, node.source.input.css);
          }
        }
      });
    } else if (this.css) {
      let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>';
      this.map.setSourceContent(from, this.css);
    }
  }
  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from);
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from);
    } else {
      return this.toUrl(this.path(node.source.input.from));
    }
  }
  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64');
    } else {
      return window.btoa(unescape(encodeURIComponent(str)));
    }
  }
  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path);
    if (cached) return cached;
    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString();
      this.memoizedFileURLs.set(path, fileURL);
      return fileURL;
    } else {
      throw new Error('`map.absolute` option is not available in this PostCSS build');
    }
  }
  toUrl(path) {
    let cached = this.memoizedURLs.get(path);
    if (cached) return cached;
    if (sep === '\\') {
      path = path.replace(/\\/g, '/');
    }
    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
    this.memoizedURLs.set(path, url);
    return url;
  }
}
module.exports = MapGenerator;

/***/ }),

/***/ 15219:
/*!****************************************************!*\
  !*** ./node_modules/postcss/lib/no-work-result.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let MapGenerator = __webpack_require__(/*! ./map-generator */ 87428);
let parse = __webpack_require__(/*! ./parse */ 85513);
const Result = __webpack_require__(/*! ./result */ 20629);
let stringify = __webpack_require__(/*! ./stringify */ 17767);
let warnOnce = __webpack_require__(/*! ./warn-once */ 82924);
class NoWorkResult {
  constructor(processor, css, opts) {
    css = css.toString();
    this.stringified = false;
    this._processor = processor;
    this._css = css;
    this._opts = opts;
    this._map = undefined;
    let root;
    let str = stringify;
    this.result = new Result(this._processor, root, this._opts);
    this.result.css = css;
    let self = this;
    Object.defineProperty(this.result, 'root', {
      get() {
        return self.root;
      }
    });
    let map = new MapGenerator(str, root, this._opts, css);
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate();
      if (generatedCSS) {
        this.result.css = generatedCSS;
      }
      if (generatedMap) {
        this.result.map = generatedMap;
      }
    } else {
      map.clearAnnotation();
      this.result.css = map.css;
    }
  }
  async() {
    if (this.error) return Promise.reject(this.error);
    return Promise.resolve(this.result);
  }
  catch(onRejected) {
    return this.async().catch(onRejected);
  }
  finally(onFinally) {
    return this.async().then(onFinally, onFinally);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(onFulfilled, onRejected) {
    if (true) {
      if (!('from' in this._opts)) {
        warnOnce('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');
      }
    }
    return this.async().then(onFulfilled, onRejected);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) {
      return this._root;
    }
    let root;
    let parser = parse;
    try {
      root = parser(this._css, this._opts);
    } catch (error) {
      this.error = error;
    }
    if (this.error) {
      throw this.error;
    } else {
      this._root = root;
      return root;
    }
  }
  get [Symbol.toStringTag]() {
    return 'NoWorkResult';
  }
}
module.exports = NoWorkResult;
NoWorkResult.default = NoWorkResult;

/***/ }),

/***/ 63344:
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/node.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ 71118);
let Stringifier = __webpack_require__(/*! ./stringifier */ 69716);
let stringify = __webpack_require__(/*! ./stringify */ 17767);
let {
  isClean,
  my
} = __webpack_require__(/*! ./symbols */ 56119);
function cloneNode(obj, parent) {
  let cloned = new obj.constructor();
  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue;
    }
    if (i === 'proxyCache') continue;
    let value = obj[i];
    let type = typeof value;
    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent;
    } else if (i === 'source') {
      cloned[i] = value;
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned));
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value);
      cloned[i] = value;
    }
  }
  return cloned;
}
function sourceOffset(inputCSS, position) {
  // Not all custom syntaxes support `offset` in `source.start` and `source.end`
  if (position && typeof position.offset !== 'undefined') {
    return position.offset;
  }
  let column = 1;
  let line = 1;
  let offset = 0;
  for (let i = 0; i < inputCSS.length; i++) {
    if (line === position.line && column === position.column) {
      offset = i;
      break;
    }
    if (inputCSS[i] === '\n') {
      column = 1;
      line += 1;
    } else {
      column += 1;
    }
  }
  return offset;
}
class Node {
  constructor(defaults = {}) {
    this.raws = {};
    this[isClean] = false;
    this[my] = true;
    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = [];
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone());
          } else {
            this.append(node);
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }
  addToError(error) {
    error.postcssNode = this;
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source;
      error.stack = error.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
    }
    return error;
  }
  after(add) {
    this.parent.insertAfter(this, add);
    return this;
  }
  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name];
    }
    return this;
  }
  before(add) {
    this.parent.insertBefore(this, add);
    return this;
  }
  cleanRaws(keepBetween) {
    delete this.raws.before;
    delete this.raws.after;
    if (!keepBetween) delete this.raws.between;
  }
  clone(overrides = {}) {
    let cloned = cloneNode(this);
    for (let name in overrides) {
      cloned[name] = overrides[name];
    }
    return cloned;
  }
  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertAfter(this, cloned);
    return cloned;
  }
  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides);
    this.parent.insertBefore(this, cloned);
    return cloned;
  }
  error(message, opts = {}) {
    if (this.source) {
      let {
        end,
        start
      } = this.rangeBy(opts);
      return this.source.input.error(message, {
        column: start.column,
        line: start.line
      }, {
        column: end.column,
        line: end.line
      }, opts);
    }
    return new CssSyntaxError(message);
  }
  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node;
        } else if (prop === 'root') {
          return () => node.root().toProxy();
        } else {
          return node[prop];
        }
      },
      set(node, prop, value) {
        if (node[prop] === value) return true;
        node[prop] = value;
        if (prop === 'prop' || prop === 'value' || prop === 'name' || prop === 'params' || prop === 'important' || /* c8 ignore next */
        prop === 'text') {
          node.markDirty();
        }
        return true;
      }
    };
  }

  /* c8 ignore next 3 */
  markClean() {
    this[isClean] = true;
  }
  markDirty() {
    if (this[isClean]) {
      this[isClean] = false;
      let next = this;
      while (next = next.parent) {
        next[isClean] = false;
      }
    }
  }
  next() {
    if (!this.parent) return undefined;
    let index = this.parent.index(this);
    return this.parent.nodes[index + 1];
  }
  positionBy(opts) {
    let pos = this.source.start;
    if (opts.index) {
      pos = this.positionInside(opts.index);
    } else if (opts.word) {
      let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;
      let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));
      let index = stringRepresentation.indexOf(opts.word);
      if (index !== -1) pos = this.positionInside(index);
    }
    return pos;
  }
  positionInside(index) {
    let column = this.source.start.column;
    let line = this.source.start.line;
    let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;
    let offset = sourceOffset(inputString, this.source.start);
    let end = offset + index;
    for (let i = offset; i < end; i++) {
      if (inputString[i] === '\n') {
        column = 1;
        line += 1;
      } else {
        column += 1;
      }
    }
    return {
      column,
      line
    };
  }
  prev() {
    if (!this.parent) return undefined;
    let index = this.parent.index(this);
    return this.parent.nodes[index - 1];
  }
  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    };
    let end = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: start.column + 1,
      line: start.line
    };
    if (opts.word) {
      let inputString = 'document' in this.source.input ? this.source.input.document : this.source.input.css;
      let stringRepresentation = inputString.slice(sourceOffset(inputString, this.source.start), sourceOffset(inputString, this.source.end));
      let index = stringRepresentation.indexOf(opts.word);
      if (index !== -1) {
        start = this.positionInside(index);
        end = this.positionInside(index + opts.word.length);
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        };
      } else if (opts.index) {
        start = this.positionInside(opts.index);
      }
      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        };
      } else if (typeof opts.endIndex === 'number') {
        end = this.positionInside(opts.endIndex);
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1);
      }
    }
    if (end.line < start.line || end.line === start.line && end.column <= start.column) {
      end = {
        column: start.column + 1,
        line: start.line
      };
    }
    return {
      end,
      start
    };
  }
  raw(prop, defaultType) {
    let str = new Stringifier();
    return str.raw(this, prop, defaultType);
  }
  remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.parent = undefined;
    return this;
  }
  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this;
      let foundSelf = false;
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true;
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node);
          bookmark = node;
        } else {
          this.parent.insertBefore(bookmark, node);
        }
      }
      if (!foundSelf) {
        this.remove();
      }
    }
    return this;
  }
  root() {
    let result = this;
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent;
    }
    return result;
  }
  toJSON(_, inputs) {
    let fixed = {};
    let emitInputs = inputs == null;
    inputs = inputs || new Map();
    let inputsNextIndex = 0;
    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        /* c8 ignore next 2 */
        continue;
      }
      if (name === 'parent' || name === 'proxyCache') continue;
      let value = this[name];
      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs);
          } else {
            return i;
          }
        });
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs);
      } else if (name === 'source') {
        let inputId = inputs.get(value.input);
        if (inputId == null) {
          inputId = inputsNextIndex;
          inputs.set(value.input, inputsNextIndex);
          inputsNextIndex++;
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        };
      } else {
        fixed[name] = value;
      }
    }
    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON());
    }
    return fixed;
  }
  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor());
    }
    return this.proxyCache;
  }
  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify;
    let result = '';
    stringifier(this, i => {
      result += i;
    });
    return result;
  }
  warn(result, text, opts) {
    let data = {
      node: this
    };
    for (let i in opts) data[i] = opts[i];
    return result.warn(text, data);
  }
  get proxyOf() {
    return this;
  }
}
module.exports = Node;
Node.default = Node;

/***/ }),

/***/ 85513:
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/parse.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Container = __webpack_require__(/*! ./container */ 59553);
let Input = __webpack_require__(/*! ./input */ 68946);
let Parser = __webpack_require__(/*! ./parser */ 14579);
function parse(css, opts) {
  let input = new Input(css, opts);
  let parser = new Parser(input);
  try {
    parser.parse();
  } catch (e) {
    if (true) {
      if (e.name === 'CssSyntaxError' && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e.message += '\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';
        } else if (/\.sass/i.test(opts.from)) {
          e.message += '\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';
        } else if (/\.less$/i.test(opts.from)) {
          e.message += '\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';
        }
      }
    }
    throw e;
  }
  return parser.root;
}
module.exports = parse;
parse.default = parse;
Container.registerParse(parse);

/***/ }),

/***/ 14579:
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/parser.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let AtRule = __webpack_require__(/*! ./at-rule */ 97804);
let Comment = __webpack_require__(/*! ./comment */ 88091);
let Declaration = __webpack_require__(/*! ./declaration */ 65350);
let Root = __webpack_require__(/*! ./root */ 74412);
let Rule = __webpack_require__(/*! ./rule */ 10302);
let tokenizer = __webpack_require__(/*! ./tokenize */ 76085);
const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
};
function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i >= 0; i--) {
    let token = tokens[i];
    let pos = token[3] || token[2];
    if (pos) return pos;
  }
}
class Parser {
  constructor(input) {
    this.input = input;
    this.root = new Root();
    this.current = this.root;
    this.spaces = '';
    this.semicolon = false;
    this.createTokenizer();
    this.root.source = {
      input,
      start: {
        column: 1,
        line: 1,
        offset: 0
      }
    };
  }
  atrule(token) {
    let node = new AtRule();
    node.name = token[1].slice(1);
    if (node.name === '') {
      this.unnamedAtrule(node, token);
    }
    this.init(node, token[2]);
    let type;
    let prev;
    let shift;
    let last = false;
    let open = false;
    let params = [];
    let brackets = [];
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      type = token[0];
      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']');
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}');
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
      }
      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2]);
          node.source.end.offset++;
          this.semicolon = true;
          break;
        } else if (type === '{') {
          open = true;
          break;
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1;
            prev = params[shift];
            while (prev && prev[0] === 'space') {
              prev = params[--shift];
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2]);
              node.source.end.offset++;
            }
          }
          this.end(token);
          break;
        } else {
          params.push(token);
        }
      } else {
        params.push(token);
      }
      if (this.tokenizer.endOfFile()) {
        last = true;
        break;
      }
    }
    node.raws.between = this.spacesAndCommentsFromEnd(params);
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params);
      this.raw(node, 'params', params);
      if (last) {
        token = params[params.length - 1];
        node.source.end = this.getPosition(token[3] || token[2]);
        node.source.end.offset++;
        this.spaces = node.raws.between;
        node.raws.between = '';
      }
    } else {
      node.raws.afterName = '';
      node.params = '';
    }
    if (open) {
      node.nodes = [];
      this.current = node;
    }
  }
  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens);
    if (colon === false) return;
    let founded = 0;
    let token;
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j];
      if (token[0] !== 'space') {
        founded += 1;
        if (founded === 2) break;
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);
  }
  colon(tokens) {
    let brackets = 0;
    let prev, token, type;
    for (let [i, element] of tokens.entries()) {
      token = element;
      type = token[0];
      if (type === '(') {
        brackets += 1;
      }
      if (type === ')') {
        brackets -= 1;
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token);
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue;
        } else {
          return i;
        }
      }
      prev = token;
    }
    return false;
  }
  comment(token) {
    let node = new Comment();
    this.init(node, token[2]);
    node.source.end = this.getPosition(token[3] || token[2]);
    node.source.end.offset++;
    let text = token[1].slice(2, -2);
    if (/^\s*$/.test(text)) {
      node.text = '';
      node.raws.left = text;
      node.raws.right = '';
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
      node.text = match[2];
      node.raws.left = match[1];
      node.raws.right = match[3];
    }
  }
  createTokenizer() {
    this.tokenizer = tokenizer(this.input);
  }
  decl(tokens, customProperty) {
    let node = new Declaration();
    this.init(node, tokens[0][2]);
    let last = tokens[tokens.length - 1];
    if (last[0] === ';') {
      this.semicolon = true;
      tokens.pop();
    }
    node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
    node.source.end.offset++;
    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens);
      node.raws.before += tokens.shift()[1];
    }
    node.source.start = this.getPosition(tokens[0][2]);
    node.prop = '';
    while (tokens.length) {
      let type = tokens[0][0];
      if (type === ':' || type === 'space' || type === 'comment') {
        break;
      }
      node.prop += tokens.shift()[1];
    }
    node.raws.between = '';
    let token;
    while (tokens.length) {
      token = tokens.shift();
      if (token[0] === ':') {
        node.raws.between += token[1];
        break;
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token]);
        }
        node.raws.between += token[1];
      }
    }
    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0];
      node.prop = node.prop.slice(1);
    }
    let firstSpaces = [];
    let next;
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== 'space' && next !== 'comment') break;
      firstSpaces.push(tokens.shift());
    }
    this.precheckMissedSemicolon(tokens);
    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];
      if (token[1].toLowerCase() === '!important') {
        node.important = true;
        let string = this.stringFrom(tokens, i);
        string = this.spacesFromEnd(tokens) + string;
        if (string !== ' !important') node.raws.important = string;
        break;
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0);
        let str = '';
        for (let j = i; j > 0; j--) {
          let type = cache[j][0];
          if (str.trim().startsWith('!') && type !== 'space') {
            break;
          }
          str = cache.pop()[1] + str;
        }
        if (str.trim().startsWith('!')) {
          node.important = true;
          node.raws.important = str;
          tokens = cache;
        }
      }
      if (token[0] !== 'space' && token[0] !== 'comment') {
        break;
      }
    }
    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');
    if (hasWord) {
      node.raws.between += firstSpaces.map(i => i[1]).join('');
      firstSpaces = [];
    }
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);
    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens);
    }
  }
  doubleColon(token) {
    throw this.input.error('Double colon', {
      offset: token[2]
    }, {
      offset: token[2] + token[1].length
    });
  }
  emptyRule(token) {
    let node = new Rule();
    this.init(node, token[2]);
    node.selector = '';
    node.raws.between = '';
    this.current = node;
  }
  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.semicolon = false;
    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    this.spaces = '';
    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2]);
      this.current.source.end.offset++;
      this.current = this.current.parent;
    } else {
      this.unexpectedClose(token);
    }
  }
  endFile() {
    if (this.current.parent) this.unclosedBlock();
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon;
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces;
    this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(token) {
    this.spaces += token[1];
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1];
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces;
        this.spaces = '';
        prev.source.end = this.getPosition(token[2]);
        prev.source.end.offset += prev.raws.ownSemicolon.length;
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset);
    return {
      column: pos.col,
      line: pos.line,
      offset
    };
  }
  init(node, offset) {
    this.current.push(node);
    node.source = {
      input: this.input,
      start: this.getPosition(offset)
    };
    node.raws.before = this.spaces;
    this.spaces = '';
    if (node.type !== 'comment') this.semicolon = false;
  }
  other(start) {
    let end = false;
    let type = null;
    let colon = false;
    let bracket = null;
    let brackets = [];
    let customProperty = start[1].startsWith('--');
    let tokens = [];
    let token = start;
    while (token) {
      type = token[0];
      tokens.push(token);
      if (type === '(' || type === '[') {
        if (!bracket) bracket = token;
        brackets.push(type === '(' ? ')' : ']');
      } else if (customProperty && colon && type === '{') {
        if (!bracket) bracket = token;
        brackets.push('}');
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens, customProperty);
            return;
          } else {
            break;
          }
        } else if (type === '{') {
          this.rule(tokens);
          return;
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop());
          end = true;
          break;
        } else if (type === ':') {
          colon = true;
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop();
        if (brackets.length === 0) bracket = null;
      }
      token = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile()) end = true;
    if (brackets.length > 0) this.unclosedBracket(bracket);
    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0];
          if (token !== 'space' && token !== 'comment') break;
          this.tokenizer.back(tokens.pop());
        }
      }
      this.decl(tokens, customProperty);
    } else {
      this.unknownWord(tokens);
    }
  }
  parse() {
    let token;
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken();
      switch (token[0]) {
        case 'space':
          this.spaces += token[1];
          break;
        case ';':
          this.freeSemicolon(token);
          break;
        case '}':
          this.end(token);
          break;
        case 'comment':
          this.comment(token);
          break;
        case 'at-word':
          this.atrule(token);
          break;
        case '{':
          this.emptyRule(token);
          break;
        default:
          this.other(token);
          break;
      }
    }
    this.endFile();
  }
  precheckMissedSemicolon( /* tokens */
  ) {
    // Hook for Safe Parser
  }
  raw(node, prop, tokens, customProperty) {
    let token, type;
    let length = tokens.length;
    let value = '';
    let clean = true;
    let next, prev;
    for (let i = 0; i < length; i += 1) {
      token = tokens[i];
      type = token[0];
      if (type === 'space' && i === length - 1 && !customProperty) {
        clean = false;
      } else if (type === 'comment') {
        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';
        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ',') {
            clean = false;
          } else {
            value += token[1];
          }
        } else {
          clean = false;
        }
      } else {
        value += token[1];
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) => all + i[1], '');
      node.raws[prop] = {
        raw,
        value
      };
    }
    node[prop] = value;
  }
  rule(tokens) {
    tokens.pop();
    let node = new Rule();
    this.init(node, tokens[0][2]);
    node.raws.between = this.spacesAndCommentsFromEnd(tokens);
    this.raw(node, 'selector', tokens);
    this.current = node;
  }
  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType;
    let spaces = '';
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }

  // Errors

  spacesAndCommentsFromStart(tokens) {
    let next;
    let spaces = '';
    while (tokens.length) {
      next = tokens[0][0];
      if (next !== 'space' && next !== 'comment') break;
      spaces += tokens.shift()[1];
    }
    return spaces;
  }
  spacesFromEnd(tokens) {
    let lastTokenType;
    let spaces = '';
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0];
      if (lastTokenType !== 'space') break;
      spaces = tokens.pop()[1] + spaces;
    }
    return spaces;
  }
  stringFrom(tokens, from) {
    let result = '';
    for (let i = from; i < tokens.length; i++) {
      result += tokens[i][1];
    }
    tokens.splice(from, tokens.length - from);
    return result;
  }
  unclosedBlock() {
    let pos = this.current.source.start;
    throw this.input.error('Unclosed block', pos.line, pos.column);
  }
  unclosedBracket(bracket) {
    throw this.input.error('Unclosed bracket', {
      offset: bracket[2]
    }, {
      offset: bracket[2] + 1
    });
  }
  unexpectedClose(token) {
    throw this.input.error('Unexpected }', {
      offset: token[2]
    }, {
      offset: token[2] + 1
    });
  }
  unknownWord(tokens) {
    throw this.input.error('Unknown word', {
      offset: tokens[0][2]
    }, {
      offset: tokens[0][2] + tokens[0][1].length
    });
  }
  unnamedAtrule(node, token) {
    throw this.input.error('At-rule without name', {
      offset: token[2]
    }, {
      offset: token[2] + token[1].length
    });
  }
}
module.exports = Parser;

/***/ }),

/***/ 34015:
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let AtRule = __webpack_require__(/*! ./at-rule */ 97804);
let Comment = __webpack_require__(/*! ./comment */ 88091);
let Container = __webpack_require__(/*! ./container */ 59553);
let CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ 71118);
let Declaration = __webpack_require__(/*! ./declaration */ 65350);
let Document = __webpack_require__(/*! ./document */ 97617);
let fromJSON = __webpack_require__(/*! ./fromJSON */ 53758);
let Input = __webpack_require__(/*! ./input */ 68946);
let LazyResult = __webpack_require__(/*! ./lazy-result */ 19750);
let list = __webpack_require__(/*! ./list */ 53272);
let Node = __webpack_require__(/*! ./node */ 63344);
let parse = __webpack_require__(/*! ./parse */ 85513);
let Processor = __webpack_require__(/*! ./processor */ 66766);
let Result = __webpack_require__(/*! ./result.js */ 20629);
let Root = __webpack_require__(/*! ./root */ 74412);
let Rule = __webpack_require__(/*! ./rule */ 10302);
let stringify = __webpack_require__(/*! ./stringify */ 17767);
let Warning = __webpack_require__(/*! ./warning */ 74214);
function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0];
  }
  return new Processor(plugins);
}
postcss.plugin = function plugin(name, initializer) {
  let warningPrinted = false;
  function creator(...args) {
    // eslint-disable-next-line no-console
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true;
      // eslint-disable-next-line no-console
      console.warn(name + ': postcss.plugin was deprecated. Migration guide:\n' + 'https://evilmartians.com/chronicles/postcss-8-plugin-migration');
      if (process.env.LANG && process.env.LANG.startsWith('cn')) {
        /* c8 ignore next 7 */
        // eslint-disable-next-line no-console
        console.warn(name + ': é‡Œé¢ postcss.plugin è¢«å¼ƒç”¨. è¿ç§»æŒ‡å—:\n' + 'https://www.w3ctech.com/topic/2226');
      }
    }
    let transformer = initializer(...args);
    transformer.postcssPlugin = name;
    transformer.postcssVersion = new Processor().version;
    return transformer;
  }
  let cache;
  Object.defineProperty(creator, 'postcss', {
    get() {
      if (!cache) cache = creator();
      return cache;
    }
  });
  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts);
  };
  return creator;
};
postcss.stringify = stringify;
postcss.parse = parse;
postcss.fromJSON = fromJSON;
postcss.list = list;
postcss.comment = defaults => new Comment(defaults);
postcss.atRule = defaults => new AtRule(defaults);
postcss.decl = defaults => new Declaration(defaults);
postcss.rule = defaults => new Rule(defaults);
postcss.root = defaults => new Root(defaults);
postcss.document = defaults => new Document(defaults);
postcss.CssSyntaxError = CssSyntaxError;
postcss.Declaration = Declaration;
postcss.Container = Container;
postcss.Processor = Processor;
postcss.Document = Document;
postcss.Comment = Comment;
postcss.Warning = Warning;
postcss.AtRule = AtRule;
postcss.Result = Result;
postcss.Input = Input;
postcss.Rule = Rule;
postcss.Root = Root;
postcss.Node = Node;
LazyResult.registerPostcss(postcss);
module.exports = postcss;
postcss.default = postcss;

/***/ }),

/***/ 72758:
/*!**************************************************!*\
  !*** ./node_modules/postcss/lib/previous-map.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let {
  existsSync,
  readFileSync
} = __webpack_require__(/*! fs */ 79896);
let {
  dirname,
  join
} = __webpack_require__(/*! path */ 16928);
let {
  SourceMapConsumer,
  SourceMapGenerator
} = __webpack_require__(/*! source-map-js */ 34755);
function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString();
  } else {
    /* c8 ignore next 2 */
    return window.atob(str);
  }
}
class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return;
    this.loadAnnotation(css);
    this.inline = this.startWith(this.annotation, 'data:');
    let prev = opts.map ? opts.map.prev : undefined;
    let text = this.loadMap(opts.from, prev);
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from;
    }
    if (this.mapFile) this.root = dirname(this.mapFile);
    if (text) this.text = text;
  }
  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer(this.text);
    }
    return this.consumerCache;
  }
  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
    let baseUri = /^data:application\/json;base64,/;
    let charsetUri = /^data:application\/json;charset=utf-?8,/;
    let uri = /^data:application\/json,/;
    let uriMatch = text.match(charsetUri) || text.match(uri);
    if (uriMatch) {
      return decodeURIComponent(text.substr(uriMatch[0].length));
    }
    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);
    if (baseUriMatch) {
      return fromBase64(text.substr(baseUriMatch[0].length));
    }
    let encoding = text.match(/data:application\/json;([^,]+),/)[1];
    throw new Error('Unsupported source map encoding ' + encoding);
  }
  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim();
  }
  isMap(map) {
    if (typeof map !== 'object') return false;
    return typeof map.mappings === 'string' || typeof map._mappings === 'string' || Array.isArray(map.sections);
  }
  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
    if (!comments) return;

    // sourceMappingURLs from comments, strings, etc.
    let start = css.lastIndexOf(comments.pop());
    let end = css.indexOf('*/', start);
    if (start > -1 && end > -1) {
      // Locate the last sourceMappingURL to avoid pickin
      this.annotation = this.getAnnotationURL(css.substring(start, end));
    }
  }
  loadFile(path) {
    this.root = dirname(path);
    if (existsSync(path)) {
      this.mapFile = path;
      return readFileSync(path, 'utf-8').toString().trim();
    }
  }
  loadMap(file, prev) {
    if (prev === false) return false;
    if (prev) {
      if (typeof prev === 'string') {
        return prev;
      } else if (typeof prev === 'function') {
        let prevPath = prev(file);
        if (prevPath) {
          let map = this.loadFile(prevPath);
          if (!map) {
            throw new Error('Unable to load previous source map: ' + prevPath.toString());
          }
          return map;
        }
      } else if (prev instanceof SourceMapConsumer) {
        return SourceMapGenerator.fromSourceMap(prev).toString();
      } else if (prev instanceof SourceMapGenerator) {
        return prev.toString();
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev);
      } else {
        throw new Error('Unsupported previous source map format: ' + prev.toString());
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation);
    } else if (this.annotation) {
      let map = this.annotation;
      if (file) map = join(dirname(file), map);
      return this.loadFile(map);
    }
  }
  startWith(string, start) {
    if (!string) return false;
    return string.substr(0, start.length) === start;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
}
module.exports = PreviousMap;
PreviousMap.default = PreviousMap;

/***/ }),

/***/ 66766:
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/processor.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Document = __webpack_require__(/*! ./document */ 97617);
let LazyResult = __webpack_require__(/*! ./lazy-result */ 19750);
let NoWorkResult = __webpack_require__(/*! ./no-work-result */ 15219);
let Root = __webpack_require__(/*! ./root */ 74412);
class Processor {
  constructor(plugins = []) {
    this.version = '8.5.2';
    this.plugins = this.normalize(plugins);
  }
  normalize(plugins) {
    let normalized = [];
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i();
      } else if (i.postcss) {
        i = i.postcss;
      }
      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins);
      } else if (typeof i === 'object' && i.postcssPlugin) {
        normalized.push(i);
      } else if (typeof i === 'function') {
        normalized.push(i);
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (true) {
          throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.');
        }
      } else {
        throw new Error(i + ' is not a PostCSS plugin');
      }
    }
    return normalized;
  }
  process(css, opts = {}) {
    if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
      return new NoWorkResult(this, css, opts);
    } else {
      return new LazyResult(this, css, opts);
    }
  }
  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]));
    return this;
  }
}
module.exports = Processor;
Processor.default = Processor;
Root.registerProcessor(Processor);
Document.registerProcessor(Processor);

/***/ }),

/***/ 20629:
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/result.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Warning = __webpack_require__(/*! ./warning */ 74214);
class Result {
  constructor(processor, root, opts) {
    this.processor = processor;
    this.messages = [];
    this.root = root;
    this.opts = opts;
    this.css = undefined;
    this.map = undefined;
  }
  toString() {
    return this.css;
  }
  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin;
      }
    }
    let warning = new Warning(text, opts);
    this.messages.push(warning);
    return warning;
  }
  warnings() {
    return this.messages.filter(i => i.type === 'warning');
  }
  get content() {
    return this.css;
  }
}
module.exports = Result;
Result.default = Result;

/***/ }),

/***/ 74412:
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/root.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Container = __webpack_require__(/*! ./container */ 59553);
let LazyResult, Processor;
class Root extends Container {
  constructor(defaults) {
    super(defaults);
    this.type = 'root';
    if (!this.nodes) this.nodes = [];
  }
  normalize(child, sample, type) {
    let nodes = super.normalize(child);
    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before;
        } else {
          delete sample.raws.before;
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before;
        }
      }
    }
    return nodes;
  }
  removeChild(child, ignore) {
    let index = this.index(child);
    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before;
    }
    return super.removeChild(child);
  }
  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts);
    return lazy.stringify();
  }
}
Root.registerLazyResult = dependant => {
  LazyResult = dependant;
};
Root.registerProcessor = dependant => {
  Processor = dependant;
};
module.exports = Root;
Root.default = Root;
Container.registerRoot(Root);

/***/ }),

/***/ 10302:
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/rule.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Container = __webpack_require__(/*! ./container */ 59553);
let list = __webpack_require__(/*! ./list */ 53272);
class Rule extends Container {
  constructor(defaults) {
    super(defaults);
    this.type = 'rule';
    if (!this.nodes) this.nodes = [];
  }
  get selectors() {
    return list.comma(this.selector);
  }
  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null;
    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');
    this.selector = values.join(sep);
  }
}
module.exports = Rule;
Rule.default = Rule;
Container.registerRule(Rule);

/***/ }),

/***/ 69716:
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/stringifier.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";


const DEFAULT_RAW = {
  after: '\n',
  beforeClose: '\n',
  beforeComment: '\n',
  beforeDecl: '\n',
  beforeOpen: ' ',
  beforeRule: '\n',
  colon: ': ',
  commentLeft: ' ',
  commentRight: ' ',
  emptyBody: '',
  indent: '    ',
  semicolon: false
};
function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1);
}
class Stringifier {
  constructor(builder) {
    this.builder = builder;
  }
  atrule(node, semicolon) {
    let name = '@' + node.name;
    let params = node.params ? this.rawValue(node, 'params') : '';
    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName;
    } else if (params) {
      name += ' ';
    }
    if (node.nodes) {
      this.block(node, name + params);
    } else {
      let end = (node.raws.between || '') + (semicolon ? ';' : '');
      this.builder(name + params + end, node);
    }
  }
  beforeAfter(node, detect) {
    let value;
    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment');
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule');
    } else {
      value = this.raw(node, null, 'beforeClose');
    }
    let buf = node.parent;
    let depth = 0;
    while (buf && buf.type !== 'root') {
      depth += 1;
      buf = buf.parent;
    }
    if (value.includes('\n')) {
      let indent = this.raw(node, null, 'indent');
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent;
      }
    }
    return value;
  }
  block(node, start) {
    let between = this.raw(node, 'between', 'beforeOpen');
    this.builder(start + between + '{', node, 'start');
    let after;
    if (node.nodes && node.nodes.length) {
      this.body(node);
      after = this.raw(node, 'after');
    } else {
      after = this.raw(node, 'after', 'emptyBody');
    }
    if (after) this.builder(after);
    this.builder('}', node, 'end');
  }
  body(node) {
    let last = node.nodes.length - 1;
    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break;
      last -= 1;
    }
    let semicolon = this.raw(node, 'semicolon');
    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];
      let before = this.raw(child, 'before');
      if (before) this.builder(before);
      this.stringify(child, last !== i || semicolon);
    }
  }
  comment(node) {
    let left = this.raw(node, 'left', 'commentLeft');
    let right = this.raw(node, 'right', 'commentRight');
    this.builder('/*' + left + node.text + right + '*/', node);
  }
  decl(node, semicolon) {
    let between = this.raw(node, 'between', 'colon');
    let string = node.prop + between + this.rawValue(node, 'value');
    if (node.important) {
      string += node.raws.important || ' !important';
    }
    if (semicolon) string += ';';
    this.builder(string, node);
  }
  document(node) {
    this.body(node);
  }
  raw(node, own, detect) {
    let value;
    if (!detect) detect = own;

    // Already had
    if (own) {
      value = node.raws[own];
      if (typeof value !== 'undefined') return value;
    }
    let parent = node.parent;
    if (detect === 'before') {
      // Hack for first rule in CSS
      if (!parent || parent.type === 'root' && parent.first === node) {
        return '';
      }

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') {
        return '';
      }
    }

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect];

    // Detect style by other nodes
    let root = node.root();
    if (!root.rawCache) root.rawCache = {};
    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect];
    }
    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect);
    } else {
      let method = 'raw' + capitalize(detect);
      if (this[method]) {
        value = this[method](root, node);
      } else {
        root.walk(i => {
          value = i.raws[own];
          if (typeof value !== 'undefined') return false;
        });
      }
    }
    if (typeof value === 'undefined') value = DEFAULT_RAW[detect];
    root.rawCache[detect] = value;
    return value;
  }
  rawBeforeClose(root) {
    let value;
    root.walk(i => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after;
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '');
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, '');
    return value;
  }
  rawBeforeComment(root, node) {
    let value;
    root.walkComments(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '');
        }
        return false;
      }
    });
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl');
    } else if (value) {
      value = value.replace(/\S/g, '');
    }
    return value;
  }
  rawBeforeDecl(root, node) {
    let value;
    root.walkDecls(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before;
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '');
        }
        return false;
      }
    });
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule');
    } else if (value) {
      value = value.replace(/\S/g, '');
    }
    return value;
  }
  rawBeforeOpen(root) {
    let value;
    root.walk(i => {
      if (i.type !== 'decl') {
        value = i.raws.between;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  }
  rawBeforeRule(root) {
    let value;
    root.walk(i => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before;
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '');
          }
          return false;
        }
      }
    });
    if (value) value = value.replace(/\S/g, '');
    return value;
  }
  rawColon(root) {
    let value;
    root.walkDecls(i => {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '');
        return false;
      }
    });
    return value;
  }
  rawEmptyBody(root) {
    let value;
    root.walk(i => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  }
  rawIndent(root) {
    if (root.raws.indent) return root.raws.indent;
    let value;
    root.walk(i => {
      let p = i.parent;
      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          let parts = i.raws.before.split('\n');
          value = parts[parts.length - 1];
          value = value.replace(/\S/g, '');
          return false;
        }
      }
    });
    return value;
  }
  rawSemicolon(root) {
    let value;
    root.walk(i => {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon;
        if (typeof value !== 'undefined') return false;
      }
    });
    return value;
  }
  rawValue(node, prop) {
    let value = node[prop];
    let raw = node.raws[prop];
    if (raw && raw.value === value) {
      return raw.raw;
    }
    return value;
  }
  root(node) {
    this.body(node);
    if (node.raws.after) this.builder(node.raws.after);
  }
  rule(node) {
    this.block(node, this.rawValue(node, 'selector'));
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end');
    }
  }
  stringify(node, semicolon) {
    /* c8 ignore start */
    if (!this[node.type]) {
      throw new Error('Unknown AST node type ' + node.type + '. ' + 'Maybe you need to change PostCSS stringifier.');
    }
    /* c8 ignore stop */
    this[node.type](node, semicolon);
  }
}
module.exports = Stringifier;
Stringifier.default = Stringifier;

/***/ }),

/***/ 17767:
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/stringify.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Stringifier = __webpack_require__(/*! ./stringifier */ 69716);
function stringify(node, builder) {
  let str = new Stringifier(builder);
  str.stringify(node);
}
module.exports = stringify;
stringify.default = stringify;

/***/ }),

/***/ 56119:
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/symbols.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


module.exports.isClean = Symbol('isClean');
module.exports.my = Symbol('my');

/***/ }),

/***/ 46837:
/*!********************************************************!*\
  !*** ./node_modules/postcss/lib/terminal-highlight.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let pico = __webpack_require__(/*! picocolors */ 33135);
let tokenizer = __webpack_require__(/*! ./tokenize */ 76085);
let Input;
function registerInput(dependant) {
  Input = dependant;
}
const HIGHLIGHT_THEME = {
  ';': pico.yellow,
  ':': pico.yellow,
  '(': pico.cyan,
  ')': pico.cyan,
  '[': pico.yellow,
  ']': pico.yellow,
  '{': pico.yellow,
  '}': pico.yellow,
  'at-word': pico.cyan,
  'brackets': pico.cyan,
  'call': pico.cyan,
  'class': pico.yellow,
  'comment': pico.gray,
  'hash': pico.magenta,
  'string': pico.green
};
function getTokenType([type, value], processor) {
  if (type === 'word') {
    if (value[0] === '.') {
      return 'class';
    }
    if (value[0] === '#') {
      return 'hash';
    }
  }
  if (!processor.endOfFile()) {
    let next = processor.nextToken();
    processor.back(next);
    if (next[0] === 'brackets' || next[0] === '(') return 'call';
  }
  return type;
}
function terminalHighlight(css) {
  let processor = tokenizer(new Input(css), {
    ignoreErrors: true
  });
  let result = '';
  while (!processor.endOfFile()) {
    let token = processor.nextToken();
    let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
    if (color) {
      result += token[1].split(/\r?\n/).map(i => color(i)).join('\n');
    } else {
      result += token[1];
    }
  }
  return result;
}
terminalHighlight.registerInput = registerInput;
module.exports = terminalHighlight;

/***/ }),

/***/ 76085:
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/tokenize.js ***!
  \**********************************************/
/***/ (function(module) {

"use strict";


const SINGLE_QUOTE = "'".charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = '\\'.charCodeAt(0);
const SLASH = '/'.charCodeAt(0);
const NEWLINE = '\n'.charCodeAt(0);
const SPACE = ' '.charCodeAt(0);
const FEED = '\f'.charCodeAt(0);
const TAB = '\t'.charCodeAt(0);
const CR = '\r'.charCodeAt(0);
const OPEN_SQUARE = '['.charCodeAt(0);
const CLOSE_SQUARE = ']'.charCodeAt(0);
const OPEN_PARENTHESES = '('.charCodeAt(0);
const CLOSE_PARENTHESES = ')'.charCodeAt(0);
const OPEN_CURLY = '{'.charCodeAt(0);
const CLOSE_CURLY = '}'.charCodeAt(0);
const SEMICOLON = ';'.charCodeAt(0);
const ASTERISK = '*'.charCodeAt(0);
const COLON = ':'.charCodeAt(0);
const AT = '@'.charCodeAt(0);
const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
const RE_HEX_ESCAPE = /[\da-f]/i;
module.exports = function tokenizer(input, options = {}) {
  let css = input.css.valueOf();
  let ignore = options.ignoreErrors;
  let code, content, escape, next, quote;
  let currentToken, escaped, escapePos, n, prev;
  let length = css.length;
  let pos = 0;
  let buffer = [];
  let returned = [];
  function position() {
    return pos;
  }
  function unclosed(what) {
    throw input.error('Unclosed ' + what, pos);
  }
  function endOfFile() {
    return returned.length === 0 && pos >= length;
  }
  function nextToken(opts) {
    if (returned.length) return returned.pop();
    if (pos >= length) return;
    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
    code = css.charCodeAt(pos);
    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED:
        {
          next = pos;
          do {
            next += 1;
            code = css.charCodeAt(next);
          } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
          currentToken = ['space', css.slice(pos, next)];
          pos = next - 1;
          break;
        }
      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES:
        {
          let controlChar = String.fromCharCode(code);
          currentToken = [controlChar, controlChar, pos];
          break;
        }
      case OPEN_PARENTHESES:
        {
          prev = buffer.length ? buffer.pop()[1] : '';
          n = css.charCodeAt(pos + 1);
          if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
            next = pos;
            do {
              escaped = false;
              next = css.indexOf(')', next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos;
                  break;
                } else {
                  unclosed('bracket');
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped = !escaped;
              }
            } while (escaped);
            currentToken = ['brackets', css.slice(pos, next + 1), pos, next];
            pos = next;
          } else {
            next = css.indexOf(')', pos + 1);
            content = css.slice(pos, next + 1);
            if (next === -1 || RE_BAD_BRACKET.test(content)) {
              currentToken = ['(', '(', pos];
            } else {
              currentToken = ['brackets', content, pos, next];
              pos = next;
            }
          }
          break;
        }
      case SINGLE_QUOTE:
      case DOUBLE_QUOTE:
        {
          quote = code === SINGLE_QUOTE ? "'" : '"';
          next = pos;
          do {
            escaped = false;
            next = css.indexOf(quote, next + 1);
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos + 1;
                break;
              } else {
                unclosed('string');
              }
            }
            escapePos = next;
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1;
              escaped = !escaped;
            }
          } while (escaped);
          currentToken = ['string', css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
      case AT:
        {
          RE_AT_END.lastIndex = pos + 1;
          RE_AT_END.test(css);
          if (RE_AT_END.lastIndex === 0) {
            next = css.length - 1;
          } else {
            next = RE_AT_END.lastIndex - 2;
          }
          currentToken = ['at-word', css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
      case BACKSLASH:
        {
          next = pos;
          escape = true;
          while (css.charCodeAt(next + 1) === BACKSLASH) {
            next += 1;
            escape = !escape;
          }
          code = css.charCodeAt(next + 1);
          if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
            next += 1;
            if (RE_HEX_ESCAPE.test(css.charAt(next))) {
              while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                next += 1;
              }
              if (css.charCodeAt(next + 1) === SPACE) {
                next += 1;
              }
            }
          }
          currentToken = ['word', css.slice(pos, next + 1), pos, next];
          pos = next;
          break;
        }
      default:
        {
          if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
            next = css.indexOf('*/', pos + 2) + 1;
            if (next === 0) {
              if (ignore || ignoreUnclosed) {
                next = css.length;
              } else {
                unclosed('comment');
              }
            }
            currentToken = ['comment', css.slice(pos, next + 1), pos, next];
            pos = next;
          } else {
            RE_WORD_END.lastIndex = pos + 1;
            RE_WORD_END.test(css);
            if (RE_WORD_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_WORD_END.lastIndex - 2;
            }
            currentToken = ['word', css.slice(pos, next + 1), pos, next];
            buffer.push(currentToken);
            pos = next;
          }
          break;
        }
    }
    pos++;
    return currentToken;
  }
  function back(token) {
    returned.push(token);
  }
  return {
    back,
    endOfFile,
    nextToken,
    position
  };
};

/***/ }),

/***/ 82924:
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/warn-once.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";
/* eslint-disable no-console */


let printed = {};
module.exports = function warnOnce(message) {
  if (printed[message]) return;
  printed[message] = true;
  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message);
  }
};

/***/ }),

/***/ 74214:
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/warning.js ***!
  \*********************************************/
/***/ (function(module) {

"use strict";


class Warning {
  constructor(text, opts = {}) {
    this.type = 'warning';
    this.text = text;
    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts);
      this.line = range.start.line;
      this.column = range.start.column;
      this.endLine = range.end.line;
      this.endColumn = range.end.column;
    }
    for (let opt in opts) this[opt] = opts[opt];
  }
  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message;
    }
    if (this.plugin) {
      return this.plugin + ': ' + this.text;
    }
    return this.text;
  }
}
module.exports = Warning;
Warning.default = Warning;

/***/ }),

/***/ 19855:
/*!********************************************!*\
  !*** ./node_modules/pretty-bytes/index.js ***!
  \********************************************/
/***/ (function(module) {

"use strict";


const BYTE_UNITS = ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
const BIBYTE_UNITS = ['B', 'kiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
const BIT_UNITS = ['b', 'kbit', 'Mbit', 'Gbit', 'Tbit', 'Pbit', 'Ebit', 'Zbit', 'Ybit'];
const BIBIT_UNITS = ['b', 'kibit', 'Mibit', 'Gibit', 'Tibit', 'Pibit', 'Eibit', 'Zibit', 'Yibit'];

/*
Formats the given number using `Number#toLocaleString`.
- If locale is a string, the value is expected to be a locale-key (for example: `de`).
- If locale is true, the system default locale is used for translation.
- If no value for locale is specified, the number is returned unmodified.
*/
const toLocaleString = (number, locale, options) => {
  let result = number;
  if (typeof locale === 'string' || Array.isArray(locale)) {
    result = number.toLocaleString(locale, options);
  } else if (locale === true || options !== undefined) {
    result = number.toLocaleString(undefined, options);
  }
  return result;
};
module.exports = (number, options) => {
  if (!Number.isFinite(number)) {
    throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
  }
  options = Object.assign({
    bits: false,
    binary: false
  }, options);
  const UNITS = options.bits ? options.binary ? BIBIT_UNITS : BIT_UNITS : options.binary ? BIBYTE_UNITS : BYTE_UNITS;
  if (options.signed && number === 0) {
    return ` 0 ${UNITS[0]}`;
  }
  const isNegative = number < 0;
  const prefix = isNegative ? '-' : options.signed ? '+' : '';
  if (isNegative) {
    number = -number;
  }
  let localeOptions;
  if (options.minimumFractionDigits !== undefined) {
    localeOptions = {
      minimumFractionDigits: options.minimumFractionDigits
    };
  }
  if (options.maximumFractionDigits !== undefined) {
    localeOptions = Object.assign({
      maximumFractionDigits: options.maximumFractionDigits
    }, localeOptions);
  }
  if (number < 1) {
    const numberString = toLocaleString(number, options.locale, localeOptions);
    return prefix + numberString + ' ' + UNITS[0];
  }
  const exponent = Math.min(Math.floor(options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3), UNITS.length - 1);
  // eslint-disable-next-line unicorn/prefer-exponentiation-operator
  number /= Math.pow(options.binary ? 1024 : 1000, exponent);
  if (!localeOptions) {
    number = number.toPrecision(3);
  }
  const numberString = toLocaleString(Number(number), options.locale, localeOptions);
  const unit = UNITS[exponent];
  return prefix + numberString + ' ' + unit;
};

/***/ }),

/***/ 82489:
/*!*****************************************************!*\
  !*** ./node_modules/source-map-js/lib/array-set.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ 26461);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};
exports.ArraySet = ArraySet;

/***/ }),

/***/ 49734:
/*!******************************************************!*\
  !*** ./node_modules/source-map-js/lib/base64-vlq.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ 66970);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);
  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);
  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;
  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }
    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }
    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);
  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

/***/ }),

/***/ 66970:
/*!**************************************************!*\
  !*** ./node_modules/source-map-js/lib/base64.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65; // 'A'
  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'
  var littleZ = 122; // 'z'

  var zero = 48; // '0'
  var nine = 57; // '9'

  var plus = 43; // '+'
  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/***/ }),

/***/ 10977:
/*!*********************************************************!*\
  !*** ./node_modules/source-map-js/lib/binary-search.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }
  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }
  return index;
};

/***/ }),

/***/ 19188:
/*!********************************************************!*\
  !*** ./node_modules/source-map-js/lib/mapping-list.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ 26461);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {
    generatedLine: -1,
    generatedColumn: 0
  };
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};
exports.MappingList = MappingList;

/***/ }),

/***/ 82007:
/*!******************************************************!*\
  !*** ./node_modules/source-map-js/lib/quick-sort.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

function SortTemplate(comparator) {
  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot, false) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }
      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  return doQuickSort;
}
function cloneSort(comparator) {
  let template = SortTemplate.toString();
  let templateFn = new Function(`return ${template}`)();
  return templateFn(comparator);
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */

let sortCache = new WeakMap();
exports.quickSort = function (ary, comparator, start = 0) {
  let doQuickSort = sortCache.get(comparator);
  if (doQuickSort === void 0) {
    doQuickSort = cloneSort(comparator);
    sortCache.set(comparator, doQuickSort);
  }
  doQuickSort(ary, comparator, start, ary.length - 1);
};

/***/ }),

/***/ 1464:
/*!***************************************************************!*\
  !*** ./node_modules/source-map-js/lib/source-map-consumer.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ 26461);
var binarySearch = __webpack_require__(/*! ./binary-search */ 10977);
var ArraySet = (__webpack_require__(/*! ./array-set */ 82489).ArraySet);
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ 49734);
var quickSort = (__webpack_require__(/*! ./quick-sort */ 82007).quickSort);
function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }
  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__generatedMappings;
  }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }
    return this.__originalMappings;
  }
});
SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
  var mappings;
  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }
  var sourceRoot = this.sourceRoot;
  var boundCallback = aCallback.bind(context);
  var names = this._names;
  var sources = this._sources;
  var sourceMapURL = this._sourceMapURL;
  for (var i = 0, n = mappings.length; i < n; i++) {
    var mapping = mappings[i];
    var source = mapping.source === null ? null : sources.at(mapping.source);
    if (source !== null) {
      source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
    }
    boundCallback({
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : names.at(mapping.name)
    });
  }
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };
  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }
  var mappings = [];
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }
  return mappings;
};
exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }
  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }
  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }
  sources = sources.map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }
  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }
  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  });

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];
  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;
    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;
      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }
      destOriginalMappings.push(destMapping);
    }
    destGeneratedMappings.push(destMapping);
  }
  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */

const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
  let l = array.length;
  let n = array.length - start;
  if (n <= 1) {
    return;
  } else if (n == 2) {
    let a = array[start];
    let b = array[start + 1];
    if (compareGenerated(a, b) > 0) {
      array[start] = b;
      array[start + 1] = a;
    }
  } else if (n < 20) {
    for (let i = start; i < l; i++) {
      for (let j = i; j > start; j--) {
        let a = array[j - 1];
        let b = array[j];
        if (compareGenerated(a, b) <= 0) {
          break;
        }
        array[j - 1] = b;
        array[j] = a;
      }
    }
  } else {
    quickSort(array, compareGenerated, start);
  }
}
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;
  let subarrayStart = 0;
  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
      sortGenerated(generatedMappings, subarrayStart);
      subarrayStart = generatedMappings.length;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine;
      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str = aStr.slice(index, end);
      segment = [];
      while (index < end) {
        base64VLQ.decode(aStr, index, temp);
        value = temp.value;
        index = temp.rest;
        segment.push(value);
      }
      if (segment.length === 2) {
        throw new Error('Found a source, but no line and column');
      }
      if (segment.length === 3) {
        throw new Error('Found a source and line, but no column');
      }

      // Generated column.
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;
      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];

        // Original line.
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        // Lines are stored 0-based
        mapping.originalLine += 1;

        // Original column.
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;
        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }
      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === 'number') {
        let currentSource = mapping.source;
        while (originalMappings.length <= currentSource) {
          originalMappings.push(null);
        }
        if (originalMappings[currentSource] === null) {
          originalMappings[currentSource] = [];
        }
        originalMappings[currentSource].push(mapping);
      }
    }
  }
  sortGenerated(generatedMappings, subarrayStart);
  this.__generatedMappings = generatedMappings;
  for (var i = 0; i < originalMappings.length; i++) {
    if (originalMappings[i] != null) {
      quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
    }
  }
  this.__originalMappings = [].concat(...originalMappings);
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }
  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];
      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };
  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._generatedMappings[index];
    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);
      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }
      var name = util.getArg(mapping, 'name', null);
      if (name !== null) {
        name = this._names.at(name);
      }
      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }
  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }
  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }
  var url;
  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }
    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }
  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };
  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
  if (index >= 0) {
    var mapping = this._originalMappings[index];
    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }
  return {
    line: null,
    column: null,
    lastColumn: null
  };
};
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }
  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }
  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');
    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }
    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];
  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }
  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);
    if (content || content === '') {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }
  return {
    line: null,
    column: null
  };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];
      var source = section.consumer._sources.at(mapping.source);
      if (source !== null) {
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
      }
      this._sources.add(source);
      source = this._sources.indexOf(source);
      var name = null;
      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);
      }

      // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };
      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }
  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

/***/ }),

/***/ 20823:
/*!****************************************************************!*\
  !*** ./node_modules/source-map-js/lib/source-map-generator.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ 49734);
var util = __webpack_require__(/*! ./util */ 26461);
var ArraySet = (__webpack_require__(/*! ./array-set */ 82489).ArraySet);
var MappingList = (__webpack_require__(/*! ./mapping-list */ 19188).MappingList);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  }));
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };
    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }
      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };
      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }
    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }
    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);
  if (!this._skipValidation) {
    if (this._validateMapping(generated, original, source, name) === false) {
      return;
    }
  }
  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }
  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }
  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }
  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  }
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var newSources = new ArraySet();
  var newNames = new ArraySet();

  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }
    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }
    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;

  // Copy sourcesContents of applied map.
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      this.setSourceContent(sourceFile, content);
    }
  }, this);
};

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    var message = 'original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.';
    if (this._ignoreInvalidMapping) {
      if (typeof console !== 'undefined' && console.warn) {
        console.warn(message);
      }
      return false;
    } else {
      throw new Error(message);
    }
  }
  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    var message = 'Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    });
    if (this._ignoreInvalidMapping) {
      if (typeof console !== 'undefined' && console.warn) {
        console.warn(message);
      }
      return false;
    } else {
      throw new Error(message);
    }
  }
};

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;
  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';
    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ',';
      }
    }
    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;
    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;

      // lines are stored 0-based in SourceMap spec version 3
      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;
      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }
    result += next;
  }
  return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }
    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }
  return map;
};

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};
exports.SourceMapGenerator = SourceMapGenerator;

/***/ }),

/***/ 21521:
/*!*******************************************************!*\
  !*** ./node_modules/source-map-js/lib/source-node.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ 20823).SourceMapGenerator);
var util = __webpack_require__(/*! ./util */ 26461);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode();

  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.
  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;
  var shiftNextLine = function () {
    var lineContents = getNextLine();
    // The last line of a file might not have a newline.
    var newLine = getNextLine() || "";
    return lineContents + newLine;
    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  };

  // We need to remember the position of "remainingLines"
  var lastGeneratedLine = 1,
    lastGeneratedColumn = 0;

  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
        // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        // No more remaining code, continue
        lastMapping = mapping;
        return;
      }
    }
    // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.
    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  // We have processed all mappings.
  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    // and add the remaining lines without any mapping
    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  }

  // Copy sourcesContent into SourceNode
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }
      node.setSourceContent(sourceFile, content);
    }
  });
  return node;
  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }
  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });
  return {
    code: generated.code,
    map: map
  };
};
exports.SourceNode = SourceNode;

/***/ }),

/***/ 26461:
/*!************************************************!*\
  !*** ./node_modules/source-map-js/lib/util.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;
function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;
function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;
var MAX_CACHED_INPUTS = 32;

/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */
function lruMemoize(f) {
  var cache = [];
  return function (input) {
    for (var i = 0; i < cache.length; i++) {
      if (cache[i].input === input) {
        var temp = cache[0];
        cache[0] = cache[i];
        cache[i] = temp;
        return cache[0].result;
      }
    }
    var result = f(input);
    cache.unshift({
      input,
      result
    });
    if (cache.length > MAX_CACHED_INPUTS) {
      cache.pop();
    }
    return result;
  };
}

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
var normalize = lruMemoize(function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);
  // Split the path into parts between `/` characters. This is much faster than
  // using `.split(/\/+/g)`.
  var parts = [];
  var start = 0;
  var i = 0;
  while (true) {
    start = i;
    i = path.indexOf("/", start);
    if (i === -1) {
      parts.push(path.slice(start));
      break;
    } else {
      parts.push(path.slice(start, i));
      while (i < path.length && path[i] === "/") {
        i++;
      }
    }
  }
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');
  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }
  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
});
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }
  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }
  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;
exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }
    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;
var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();
function identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }
  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;
function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }
  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;
function isProtoString(s) {
  if (!s) {
    return false;
  }
  var length = s.length;
  if (length < 9 /* "__proto__".length */) {
    return false;
  }
  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
    return false;
  }
  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }
  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }
  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }
  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;
function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
  var cmp;
  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }
  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }
  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }
  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }
  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }
  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }
  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }
  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }
  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }
  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }
  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';
  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   â€œsourcesâ€ entry.  This value is prepended to the individual
    //   entries in the â€œsourceâ€ field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   â€œsourceRootâ€, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }
  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

/***/ }),

/***/ 34755:
/*!**************************************************!*\
  !*** ./node_modules/source-map-js/source-map.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ 20823).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ 1464).SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ 21521).SourceNode;

/***/ }),

/***/ 76583:
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const os = __webpack_require__(/*! os */ 70857);
const tty = __webpack_require__(/*! tty */ 52018);
const hasFlag = __webpack_require__(/*! has-flag */ 77756);
const {
  env
} = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
  forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
  forceColor = 1;
}
if ('FORCE_COLOR' in env) {
  if (env.FORCE_COLOR === 'true') {
    forceColor = 1;
  } else if (env.FORCE_COLOR === 'false') {
    forceColor = 0;
  } else {
    forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function supportsColor(haveStream, streamIsTTY) {
  if (forceColor === 0) {
    return 0;
  }
  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
    return 3;
  }
  if (hasFlag('color=256')) {
    return 2;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === 'dumb') {
    return min;
  }
  if (process.platform === 'win32') {
    // Windows 10 build 10586 is the first Windows release that supports 256 colors.
    // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
    const osRelease = os.release().split('.');
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ('CI' in env) {
    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
      return 1;
    }
    return min;
  }
  if ('TEAMCITY_VERSION' in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === 'truecolor') {
    return 3;
  }
  if ('TERM_PROGRAM' in env) {
    const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Apple_Terminal':
        return 2;
      // No default
    }
  }

  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ('COLORTERM' in env) {
    return 1;
  }
  return min;
}
function getSupportLevel(stream) {
  const level = supportsColor(stream, stream && stream.isTTY);
  return translateLevel(level);
}
module.exports = {
  supportsColor: getSupportLevel,
  stdout: translateLevel(supportsColor(true, tty.isatty(1))),
  stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};

/***/ }),

/***/ 19169:
/*!***********************************************************************!*\
  !*** ./node_modules/postcss/node_modules/nanoid/non-secure/index.cjs ***!
  \***********************************************************************/
/***/ (function(module) {

// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = '';
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0;
    while (i--) {
      // `| 0` is more compact and faster than `Math.floor()`.
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
let nanoid = (size = 21) => {
  let id = '';
  // A compact alternative for `for (var i = 0; i < step; i++)`.
  let i = size | 0;
  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
module.exports = {
  nanoid,
  customAlphabet
};

/***/ }),

/***/ 95386:
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 71993:
/*!**************************************************************!*\
  !*** ./node_modules/@nguniversal/common/fesm2020/engine.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CommonEngine: function() { return /* binding */ CommonEngine; }
/* harmony export */ });
/* harmony import */ var _Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 89204);
/* harmony import */ var _angular_platform_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-server */ 82582);
/* harmony import */ var _nguniversal_common_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nguniversal/common/tools */ 18920);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ 79896);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! url */ 87016);







/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A common rendering engine utility. This abstracts the logic
 * for handling the platformServer compiler, the module cache, and
 * the document loader
 */
class CommonEngine {
  constructor(module, providers = []) {
    this.module = module;
    this.providers = providers;
    this.templateCache = new Map();
    this.pageExists = new Map();
    this.inlineCriticalCssProcessor = new _nguniversal_common_tools__WEBPACK_IMPORTED_MODULE_2__["ÉµInlineCriticalCssProcessor"]({
      minify: true
    });
  }
  /**
   * Render an HTML document for a specific URL with specified
   * render options
   */
  render(opts) {
    var _this = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const {
        inlineCriticalCss = true
      } = opts;
      if (opts.publicPath && opts.documentFilePath && opts.url !== undefined) {
        const url = new url__WEBPACK_IMPORTED_MODULE_5__.URL(opts.url);
        // Remove leading forward slash.
        const pathname = url.pathname.substring(1);
        const pagePath = (0,path__WEBPACK_IMPORTED_MODULE_4__.resolve)(opts.publicPath, pathname, 'index.html');
        if (pagePath !== (0,path__WEBPACK_IMPORTED_MODULE_4__.resolve)(opts.documentFilePath)) {
          // View path doesn't match with prerender path.
          let pageExists = _this.pageExists.get(pagePath);
          if (pageExists === undefined) {
            pageExists = yield exists(pagePath);
            _this.pageExists.set(pagePath, pageExists);
          }
          if (pageExists) {
            // Serve pre-rendered page.
            return fs__WEBPACK_IMPORTED_MODULE_3__.promises.readFile(pagePath, 'utf-8');
          }
        }
      }
      // if opts.document dosen't exist then opts.documentFilePath must
      const extraProviders = [{
        provide: _angular_platform_server__WEBPACK_IMPORTED_MODULE_1__["ÉµSERVER_CONTEXT"],
        useValue: 'ssr'
      }, ...(opts.providers ?? []), ..._this.providers];
      let doc = opts.document;
      if (!doc && opts.documentFilePath) {
        doc = yield _this.getDocument(opts.documentFilePath);
      }
      if (doc) {
        extraProviders.push({
          provide: _angular_platform_server__WEBPACK_IMPORTED_MODULE_1__.INITIAL_CONFIG,
          useValue: {
            document: inlineCriticalCss ?
            // Workaround for https://github.com/GoogleChromeLabs/critters/issues/64
            doc.replace(/ media="print" onload="this\.media='all'"><noscript><link .+?><\/noscript>/g, '>') : doc,
            url: opts.url
          }
        });
      }
      const moduleOrFactory = _this.module || opts.bootstrap;
      if (!moduleOrFactory) {
        throw new Error('A module or bootstrap option must be provided.');
      }
      const html = yield (0,_angular_platform_server__WEBPACK_IMPORTED_MODULE_1__.renderModule)(moduleOrFactory, {
        extraProviders
      });
      if (!inlineCriticalCss) {
        return html;
      }
      const {
        content,
        errors,
        warnings
      } = yield _this.inlineCriticalCssProcessor.process(html, {
        outputPath: opts.publicPath ?? (opts.documentFilePath ? (0,path__WEBPACK_IMPORTED_MODULE_4__.dirname)(opts.documentFilePath) : '')
      });
      // eslint-disable-next-line no-console
      warnings?.forEach(m => console.warn(m));
      // eslint-disable-next-line no-console
      errors?.forEach(m => console.error(m));
      return content;
    })();
  }
  /** Retrieve the document from the cache or the filesystem */
  getDocument(filePath) {
    var _this2 = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      let doc = _this2.templateCache.get(filePath);
      if (!doc) {
        doc = yield fs__WEBPACK_IMPORTED_MODULE_3__.promises.readFile(filePath, 'utf-8');
        _this2.templateCache.set(filePath, doc);
      }
      return doc;
    })();
  }
}
function exists(_x) {
  return _exists.apply(this, arguments);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Generated bundle index. Do not edit.
 */
function _exists() {
  _exists = (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (path) {
    try {
      yield fs__WEBPACK_IMPORTED_MODULE_3__.promises.access(path, fs__WEBPACK_IMPORTED_MODULE_3__.constants.F_OK);
      return true;
    } catch {
      return false;
    }
  });
  return _exists.apply(this, arguments);
}


/***/ }),

/***/ 18920:
/*!*************************************************************!*\
  !*** ./node_modules/@nguniversal/common/fesm2020/tools.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ÉµInlineCriticalCssProcessor": function() { return /* binding */ InlineCriticalCssProcessor; }
/* harmony export */ });
/* harmony import */ var _Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 89204);
/* harmony import */ var critters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! critters */ 51190);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ 79896);




/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class CrittersExtended extends critters__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(optionsExtended, resourceCache) {
    super({
      logger: {
        warn: s => this.warnings.push(s),
        error: s => this.errors.push(s),
        info: () => {}
      },
      logLevel: 'warn',
      path: optionsExtended.outputPath,
      publicPath: optionsExtended.deployUrl,
      compress: !!optionsExtended.minify,
      pruneSource: false,
      reduceInlineStyles: false,
      mergeStylesheets: false,
      preload: 'media',
      noscriptFallback: true,
      inlineFonts: true
    });
    this.optionsExtended = optionsExtended;
    this.resourceCache = resourceCache;
    this.warnings = [];
    this.errors = [];
  }
  readFile(path) {
    var _this = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      let resourceContent = _this.resourceCache.get(path);
      if (resourceContent === undefined) {
        resourceContent = yield fs__WEBPACK_IMPORTED_MODULE_2__.promises.readFile(path, 'utf-8');
        _this.resourceCache.set(path, resourceContent);
      }
      return resourceContent;
    })();
  }
}
class InlineCriticalCssProcessor {
  constructor(options) {
    this.options = options;
    this.resourceCache = new Map();
  }
  process(html, options) {
    var _this2 = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const critters = new CrittersExtended({
        ..._this2.options,
        ...options
      }, _this2.resourceCache);
      const content = yield critters.process(html);
      return {
        content,
        errors: critters.errors.length ? critters.errors : undefined,
        warnings: critters.warnings.length ? critters.warnings : undefined
      };
    })();
  }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



/***/ }),

/***/ 63400:
/*!******************************************************************************!*\
  !*** ./node_modules/@nguniversal/express-engine/fesm2020/express-engine.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ngExpressEngine: function() { return /* binding */ ngExpressEngine; }
/* harmony export */ });
/* harmony import */ var _nguniversal_common_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nguniversal/common/engine */ 71993);
/* harmony import */ var _nguniversal_express_engine_tokens__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @nguniversal/express-engine/tokens */ 87857);



/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * This is an express engine for handling Angular Applications
 */
function ngExpressEngine(setupOptions) {
  const engine = new _nguniversal_common_engine__WEBPACK_IMPORTED_MODULE_0__.CommonEngine(setupOptions.bootstrap, setupOptions.providers);
  return function (filePath, options, callback) {
    try {
      const renderOptions = {
        ...options
      };
      if (!setupOptions.bootstrap && !renderOptions.bootstrap) {
        throw new Error('You must pass in a NgModule to be bootstrapped');
      }
      const {
        req
      } = renderOptions;
      const res = renderOptions.res ?? req.res;
      renderOptions.url = renderOptions.url ?? `${req.protocol}://${req.get('host') || ''}${req.baseUrl}${req.url}`;
      renderOptions.documentFilePath = renderOptions.documentFilePath ?? filePath;
      renderOptions.providers = [...(renderOptions.providers ?? []), getReqResProviders(req, res)];
      // eslint-disable-next-line @typescript-eslint/no-unused-expressions
      renderOptions.publicPath = renderOptions.publicPath ?? setupOptions.publicPath ?? options.settings?.views;
      renderOptions.inlineCriticalCss = renderOptions.inlineCriticalCss ?? setupOptions.inlineCriticalCss;
      engine.render(renderOptions).then(html => callback(null, html)).catch(callback);
    } catch (err) {
      callback(err);
    }
  };
}
/**
 * Get providers of the request and response
 */
function getReqResProviders(req, res) {
  const providers = [{
    provide: _nguniversal_express_engine_tokens__WEBPACK_IMPORTED_MODULE_1__.REQUEST,
    useValue: req
  }];
  if (res) {
    providers.push({
      provide: _nguniversal_express_engine_tokens__WEBPACK_IMPORTED_MODULE_1__.RESPONSE,
      useValue: res
    });
  }
  return providers;
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Generated bundle index. Do not edit.
 */



/***/ }),

/***/ 51190:
/*!*************************************************!*\
  !*** ./node_modules/critters/dist/critters.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 89204);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ 79896);
/* harmony import */ var pretty_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pretty-bytes */ 19855);
/* harmony import */ var parse5__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! parse5 */ 53563);
/* harmony import */ var css_select__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! css-select */ 18219);
/* harmony import */ var parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! parse5-htmlparser2-tree-adapter */ 27319);
/* harmony import */ var postcss__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! postcss */ 80265);
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! chalk */ 33168);










/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

const PARSE5_OPTS = {
  treeAdapter: parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__
};
/**
 * Parse HTML into a mutable, serializable DOM Document.
 * The DOM implementation is an htmlparser2 DOM enhanced with basic DOM mutation methods.
 * @param {String} html   HTML to parse into a Document instance
 */

function createDocument(html) {
  const document = /** @type {HTMLDocument} */
  parse5__WEBPACK_IMPORTED_MODULE_4__.parse(html, PARSE5_OPTS);
  defineProperties(document, DocumentExtensions); // Extend Element.prototype with DOM manipulation methods.

  const scratch = document.createElement('div'); // Get a reference to the base Node class - used by createTextNode()

  document.$$Node = scratch.constructor;
  const elementProto = Object.getPrototypeOf(scratch);
  defineProperties(elementProto, ElementExtensions);
  elementProto.ownerDocument = document;
  return document;
}
/**
 * Serialize a Document to an HTML String
 * @param {HTMLDocument} document   A Document, such as one created via `createDocument()`
 */

function serializeDocument(document) {
  return parse5__WEBPACK_IMPORTED_MODULE_4__.serialize(document, PARSE5_OPTS);
}
/** @typedef {treeAdapter.Document & typeof ElementExtensions} HTMLDocument */

/**
 * Methods and descriptors to mix into Element.prototype
 * @private
 */

const ElementExtensions = {
  /** @extends treeAdapter.Element.prototype */
  nodeName: {
    get() {
      return this.tagName.toUpperCase();
    }
  },
  id: reflectedProperty('id'),
  className: reflectedProperty('class'),
  insertBefore(child, referenceNode) {
    if (!referenceNode) return this.appendChild(child);
    parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.insertBefore(this, child, referenceNode);
    return child;
  },
  appendChild(child) {
    parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.appendChild(this, child);
    return child;
  },
  removeChild(child) {
    parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.detachNode(child);
  },
  remove() {
    parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.detachNode(this);
  },
  textContent: {
    get() {
      return getText(this);
    },
    set(text) {
      this.children = [];
      parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.insertText(this, text);
    }
  },
  setAttribute(name, value) {
    if (this.attribs == null) this.attribs = {};
    if (value == null) value = '';
    this.attribs[name] = value;
  },
  removeAttribute(name) {
    if (this.attribs != null) {
      delete this.attribs[name];
    }
  },
  getAttribute(name) {
    return this.attribs != null && this.attribs[name];
  },
  hasAttribute(name) {
    return this.attribs != null && this.attribs[name] != null;
  },
  getAttributeNode(name) {
    const value = this.getAttribute(name);
    if (value != null) return {
      specified: true,
      value
    };
  }
};
/**
 * Methods and descriptors to mix into the global document instance
 * @private
 */

const DocumentExtensions = {
  /** @extends treeAdapter.Document.prototype */
  // document is just an Element in htmlparser2, giving it a nodeType of ELEMENT_NODE.
  // TODO: verify if these are needed for css-select
  nodeType: {
    get() {
      return 9;
    }
  },
  contentType: {
    get() {
      return 'text/html';
    }
  },
  nodeName: {
    get() {
      return '#document';
    }
  },
  documentElement: {
    get() {
      // Find the first <html> element within the document
      return this.childNodes.filter(child => String(child.tagName).toLowerCase() === 'html');
    }
  },
  compatMode: {
    get() {
      const compatMode = {
        'no-quirks': 'CSS1Compat',
        quirks: 'BackCompat',
        'limited-quirks': 'CSS1Compat'
      };
      return compatMode[parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.getDocumentMode(this)];
    }
  },
  head: {
    get() {
      return this.querySelector('head');
    }
  },
  body: {
    get() {
      return this.querySelector('body');
    }
  },
  createElement(name) {
    return parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.createElement(name, null, []);
  },
  createTextNode(text) {
    // there is no dedicated createTextNode equivalent exposed in htmlparser2's DOM
    const Node = this.$$Node;
    return new Node({
      type: 'text',
      data: text,
      parent: null,
      prev: null,
      next: null
    });
  },
  querySelector(sel) {
    return (0,css_select__WEBPACK_IMPORTED_MODULE_5__.selectOne)(sel, this.documentElement);
  },
  querySelectorAll(sel) {
    if (sel === ':root') {
      return this;
    }
    return (0,css_select__WEBPACK_IMPORTED_MODULE_5__.selectAll)(sel, this.documentElement);
  }
};
/**
 * Essentially `Object.defineProperties()`, except function values are assigned as value descriptors for convenience.
 * @private
 */

function defineProperties(obj, properties) {
  for (const i in properties) {
    const value = properties[i];
    Object.defineProperty(obj, i, typeof value === 'function' ? {
      value
    } : value);
  }
}
/**
 * Create a property descriptor defining a getter/setter pair alias for a named attribute.
 * @private
 */

function reflectedProperty(attributeName) {
  return {
    get() {
      return this.getAttribute(attributeName);
    },
    set(value) {
      this.setAttribute(attributeName, value);
    }
  };
}
/**
 * Helper to get the text content of a node
 * https://github.com/fb55/domutils/blob/master/src/stringify.ts#L21
 * @private
 */

function getText(node) {
  if (Array.isArray(node)) return node.map(getText).join('');
  if (parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.isElementNode(node)) return node.name === 'br' ? '\n' : getText(node.children);
  if (parse5_htmlparser2_tree_adapter__WEBPACK_IMPORTED_MODULE_6__.isTextNode(node)) return node.data;
  return '';
}

/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/**
 * Parse a textual CSS Stylesheet into a Stylesheet instance.
 * Stylesheet is a mutable postcss AST with format similar to CSSOM.
 * @see https://github.com/postcss/postcss/
 * @private
 * @param {String} stylesheet
 * @returns {css.Stylesheet} ast
 */

function parseStylesheet(stylesheet) {
  return (0,postcss__WEBPACK_IMPORTED_MODULE_7__.parse)(stylesheet);
}
/**
 * Serialize a postcss Stylesheet to a String of CSS.
 * @private
 * @param {css.Stylesheet} ast          A Stylesheet to serialize, such as one returned from `parseStylesheet()`
 * @param {Object} options              Options used by the stringify logic
 * @param {Boolean} [options.compress]  Compress CSS output (removes comments, whitespace, etc)
 */

function serializeStylesheet(ast, options) {
  let cssStr = '';
  (0,postcss__WEBPACK_IMPORTED_MODULE_7__.stringify)(ast, (result, node, type) => {
    var _node$raws;
    if (!options.compress) {
      cssStr += result;
      return;
    } // Simple minification logic

    if ((node == null ? void 0 : node.type) === 'comment') return;
    if ((node == null ? void 0 : node.type) === 'decl') {
      const prefix = node.prop + node.raws.between;
      cssStr += result.replace(prefix, prefix.trim());
      return;
    }
    if (type === 'start') {
      if (node.type === 'rule' && node.selectors) {
        cssStr += node.selectors.join(',') + '{';
      } else {
        cssStr += result.replace(/\s\{$/, '{');
      }
      return;
    }
    if (type === 'end' && result === '}' && node != null && (_node$raws = node.raws) != null && _node$raws.semicolon) {
      cssStr = cssStr.slice(0, -1);
    }
    cssStr += result.trim();
  });
  return cssStr;
}
/**
 * Converts a walkStyleRules() iterator to mark nodes with `.$$remove=true` instead of actually removing them.
 * This means they can be removed in a second pass, allowing the first pass to be nondestructive (eg: to preserve mirrored sheets).
 * @private
 * @param {Function} iterator   Invoked on each node in the tree. Return `false` to remove that node.
 * @returns {(rule) => void} nonDestructiveIterator
 */

function markOnly(predicate) {
  return rule => {
    const sel = rule.selectors;
    if (predicate(rule) === false) {
      rule.$$remove = true;
    }
    rule.$$markedSelectors = rule.selectors;
    if (rule._other) {
      rule._other.$$markedSelectors = rule._other.selectors;
    }
    rule.selectors = sel;
  };
}
/**
 * Apply filtered selectors to a rule from a previous markOnly run.
 * @private
 * @param {css.Rule} rule The Rule to apply marked selectors to (if they exist).
 */

function applyMarkedSelectors(rule) {
  if (rule.$$markedSelectors) {
    rule.selectors = rule.$$markedSelectors;
  }
  if (rule._other) {
    applyMarkedSelectors(rule._other);
  }
}
/**
 * Recursively walk all rules in a stylesheet.
 * @private
 * @param {css.Rule} node       A Stylesheet or Rule to descend into.
 * @param {Function} iterator   Invoked on each node in the tree. Return `false` to remove that node.
 */

function walkStyleRules(node, iterator) {
  node.nodes = node.nodes.filter(rule => {
    if (hasNestedRules(rule)) {
      walkStyleRules(rule, iterator);
    }
    rule._other = undefined;
    rule.filterSelectors = filterSelectors;
    return iterator(rule) !== false;
  });
}
/**
 * Recursively walk all rules in two identical stylesheets, filtering nodes into one or the other based on a predicate.
 * @private
 * @param {css.Rule} node       A Stylesheet or Rule to descend into.
 * @param {css.Rule} node2      A second tree identical to `node`
 * @param {Function} iterator   Invoked on each node in the tree. Return `false` to remove that node from the first tree, true to remove it from the second.
 */

function walkStyleRulesWithReverseMirror(node, node2, iterator) {
  if (node2 === null) return walkStyleRules(node, iterator);
  [node.nodes, node2.nodes] = splitFilter(node.nodes, node2.nodes, (rule, index, rules, rules2) => {
    const rule2 = rules2[index];
    if (hasNestedRules(rule)) {
      walkStyleRulesWithReverseMirror(rule, rule2, iterator);
    }
    rule._other = rule2;
    rule.filterSelectors = filterSelectors;
    return iterator(rule) !== false;
  });
} // Checks if a node has nested rules, like @media
// @keyframes are an exception since they are evaluated as a whole

function hasNestedRules(rule) {
  return rule.nodes && rule.nodes.length && rule.nodes.some(n => n.type === 'rule' || n.type === 'atrule') && rule.name !== 'keyframes' && rule.name !== '-webkit-keyframes';
} // Like [].filter(), but applies the opposite filtering result to a second copy of the Array without a second pass.
// This is just a quicker version of generating the compliment of the set returned from a filter operation.

function splitFilter(a, b, predicate) {
  const aOut = [];
  const bOut = [];
  for (let index = 0; index < a.length; index++) {
    if (predicate(a[index], index, a, b)) {
      aOut.push(a[index]);
    } else {
      bOut.push(a[index]);
    }
  }
  return [aOut, bOut];
} // can be invoked on a style rule to subset its selectors (with reverse mirroring)

function filterSelectors(predicate) {
  if (this._other) {
    const [a, b] = splitFilter(this.selectors, this._other.selectors, predicate);
    this.selectors = a;
    this._other.selectors = b;
  } else {
    this.selectors = this.selectors.filter(predicate);
  }
}
const LOG_LEVELS = ['trace', 'debug', 'info', 'warn', 'error', 'silent'];
const defaultLogger = {
  trace(msg) {
    console.trace(msg);
  },
  debug(msg) {
    console.debug(msg);
  },
  warn(msg) {
    console.warn(chalk__WEBPACK_IMPORTED_MODULE_8__.yellow(msg));
  },
  error(msg) {
    console.error(chalk__WEBPACK_IMPORTED_MODULE_8__.bold.red(msg));
  },
  info(msg) {
    console.info(chalk__WEBPACK_IMPORTED_MODULE_8__.bold.blue(msg));
  },
  silent() {}
};
function createLogger(logLevel) {
  const logLevelIdx = LOG_LEVELS.indexOf(logLevel);
  return LOG_LEVELS.reduce((logger, type, index) => {
    if (index >= logLevelIdx) {
      logger[type] = defaultLogger[type];
    } else {
      logger[type] = defaultLogger.silent;
    }
    return logger;
  }, {});
}

/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
/**
 * The mechanism to use for lazy-loading stylesheets.
 *
 * Note: <kbd>JS</kbd> indicates a strategy requiring JavaScript (falls back to `<noscript>` unless disabled).
 *
 * - **default:** Move stylesheet links to the end of the document and insert preload meta tags in their place.
 * - **"body":** Move all external stylesheet links to the end of the document.
 * - **"media":** Load stylesheets asynchronously by adding `media="not x"` and removing once loaded. <kbd>JS</kbd>
 * - **"swap":** Convert stylesheet links to preloads that swap to `rel="stylesheet"` once loaded ([details](https://www.filamentgroup.com/lab/load-css-simpler/#the-code)). <kbd>JS</kbd>
 * - **"swap-high":** Use `<link rel="alternate stylesheet preload">` and swap to `rel="stylesheet"` once loaded ([details](http://filamentgroup.github.io/loadCSS/test/new-high.html)). <kbd>JS</kbd>
 * - **"js":** Inject an asynchronous CSS loader similar to [LoadCSS](https://github.com/filamentgroup/loadCSS) and use it to load stylesheets. <kbd>JS</kbd>
 * - **"js-lazy":** Like `"js"`, but the stylesheet is disabled until fully loaded.
 * - **false:** Disables adding preload tags.
 * @typedef {(default|'body'|'media'|'swap'|'swap-high'|'js'|'js-lazy')} PreloadStrategy
 * @public
 */

/**
 * Controls which keyframes rules are inlined.
 *
 * - **"critical":** _(default)_ inline keyframes rules that are used by the critical CSS.
 * - **"all":** Inline all keyframes rules.
 * - **"none":** Remove all keyframes rules.
 * @typedef {('critical'|'all'|'none')} KeyframeStrategy
 * @private
 * @property {String} keyframes     Which {@link KeyframeStrategy keyframe strategy} to use (default: `critical`)_
 */

/**
 * Controls log level of the plugin. Specifies the level the logger should use. A logger will
 * not produce output for any log level beneath the specified level. Available levels and order
 * are:
 *
 * - **"info"** _(default)_
 * - **"warn"**
 * - **"error"**
 * - **"trace"**
 * - **"debug"**
 * - **"silent"**
 * @typedef {('info'|'warn'|'error'|'trace'|'debug'|'silent')} LogLevel
 * @public
 */

/**
 * Custom logger interface:
 * @typedef {object} Logger
 * @public
 * @property {function(String)} trace - Prints a trace message
 * @property {function(String)} debug - Prints a debug message
 * @property {function(String)} info - Prints an information message
 * @property {function(String)} warn - Prints a warning message
 * @property {function(String)} error - Prints an error message
 */

/**
 * All optional. Pass them to `new Critters({ ... })`.
 * @public
 * @typedef Options
 * @property {String} path     Base path location of the CSS files _(default: `''`)_
 * @property {String} publicPath     Public path of the CSS resources. This prefix is removed from the href _(default: `''`)_
 * @property {Boolean} external     Inline styles from external stylesheets _(default: `true`)_
 * @property {Number} inlineThreshold Inline external stylesheets smaller than a given size _(default: `0`)_
 * @property {Number} minimumExternalSize If the non-critical external stylesheet would be below this size, just inline it _(default: `0`)_
 * @property {Boolean} pruneSource  Remove inlined rules from the external stylesheet _(default: `false`)_
 * @property {Boolean} mergeStylesheets Merged inlined stylesheets into a single `<style>` tag _(default: `true`)_
 * @property {String[]} additionalStylesheets Glob for matching other stylesheets to be used while looking for critical CSS.
 * @property {String} preload       Which {@link PreloadStrategy preload strategy} to use
 * @property {Boolean} noscriptFallback Add `<noscript>` fallback to JS-based strategies
 * @property {Boolean} inlineFonts  Inline critical font-face rules _(default: `false`)_
 * @property {Boolean} preloadFonts Preloads critical fonts _(default: `true`)_
 * @property {Boolean} fonts        Shorthand for setting `inlineFonts` + `preloadFonts`
 *  - Values:
 *  - `true` to inline critical font-face rules and preload the fonts
 *  - `false` to don't inline any font-face rules and don't preload fonts
 * @property {String} keyframes     Controls which keyframes rules are inlined.
 *  - Values:
 *  - `"critical"`: _(default)_ inline keyframes rules used by the critical CSS
 *  - `"all"` inline all keyframes rules
 *  - `"none"` remove all keyframes rules
 * @property {Boolean} compress     Compress resulting critical CSS _(default: `true`)_
 * @property {String} logLevel      Controls {@link LogLevel log level} of the plugin _(default: `"info"`)_
 * @property {object} logger        Provide a custom logger interface {@link Logger logger}
 */

class Critters {
  /** @private */
  constructor(options) {
    this.options = Object.assign({
      logLevel: 'info',
      path: '',
      publicPath: '',
      reduceInlineStyles: true,
      pruneSource: false,
      additionalStylesheets: []
    }, options || {});
    this.urlFilter = this.options.filter;
    if (this.urlFilter instanceof RegExp) {
      this.urlFilter = this.urlFilter.test.bind(this.urlFilter);
    }
    this.logger = this.options.logger || createLogger(this.options.logLevel);
  }
  /**
   * Read the contents of a file from the specified filesystem or disk
   */

  readFile(filename) {
    const fs = this.fs;
    return new Promise((resolve, reject) => {
      const callback = (err, data) => {
        if (err) reject(err);else resolve(data);
      };
      if (fs && fs.readFile) {
        fs.readFile(filename, callback);
      } else {
        (0,fs__WEBPACK_IMPORTED_MODULE_2__.readFile)(filename, 'utf8', callback);
      }
    });
  }
  /**
   * Apply critical CSS processing to the html
   */

  process(html) {
    var _this = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const start = process.hrtime.bigint(); // Parse the generated HTML in a DOM we can mutate

      const document = createDocument(html);
      if (_this.options.additionalStylesheets.length > 0) {
        _this.embedAdditionalStylesheet(document);
      } // `external:false` skips processing of external sheets

      if (_this.options.external !== false) {
        const externalSheets = [].slice.call(document.querySelectorAll('link[rel="stylesheet"]'));
        yield Promise.all(externalSheets.map(link => _this.embedLinkedStylesheet(link, document)));
      } // go through all the style tags in the document and reduce them to only critical CSS

      const styles = _this.getAffectedStyleTags(document);
      yield Promise.all(styles.map(style => _this.processStyle(style, document)));
      if (_this.options.mergeStylesheets !== false && styles.length !== 0) {
        yield _this.mergeStylesheets(document);
      } // serialize the document back to HTML and we're done

      const output = serializeDocument(document);
      const end = process.hrtime.bigint();
      _this.logger.info('Time ' + parseFloat(end - start) / 1000000.0);
      return output;
    })();
  }
  /**
   * Get the style tags that need processing
   */

  getAffectedStyleTags(document) {
    const styles = [].slice.call(document.querySelectorAll('style')); // `inline:false` skips processing of inline stylesheets

    if (this.options.reduceInlineStyles === false) {
      return styles.filter(style => style.$$external);
    }
    return styles;
  }
  mergeStylesheets(document) {
    var _this2 = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const styles = _this2.getAffectedStyleTags(document);
      if (styles.length === 0) {
        _this2.logger.warn('Merging inline stylesheets into a single <style> tag skipped, no inline stylesheets to merge');
        return;
      }
      const first = styles[0];
      let sheet = first.textContent;
      for (let i = 1; i < styles.length; i++) {
        const node = styles[i];
        sheet += node.textContent;
        node.remove();
      }
      first.textContent = sheet;
    })();
  }
  /**
   * Given href, find the corresponding CSS asset
   */

  getCssAsset(href) {
    var _this3 = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const outputPath = _this3.options.path;
      const publicPath = _this3.options.publicPath; // CHECK - the output path
      // path on disk (with output.publicPath removed)

      let normalizedPath = href.replace(/^\//, '');
      const pathPrefix = (publicPath || '').replace(/(^\/|\/$)/g, '') + '/';
      if (normalizedPath.indexOf(pathPrefix) === 0) {
        normalizedPath = normalizedPath.substring(pathPrefix.length).replace(/^\//, '');
      } // Ignore remote stylesheets

      if (/^https?:\/\//.test(normalizedPath) || href.startsWith('//')) {
        return undefined;
      }
      const filename = path__WEBPACK_IMPORTED_MODULE_1__.resolve(outputPath, normalizedPath);
      let sheet;
      try {
        sheet = yield _this3.readFile(filename);
      } catch (e) {
        _this3.logger.warn(`Unable to locate stylesheet: ${filename}`);
      }
      return sheet;
    })();
  }
  checkInlineThreshold(link, style, sheet) {
    if (this.options.inlineThreshold && sheet.length < this.options.inlineThreshold) {
      const href = style.$$name;
      style.$$reduce = false;
      this.logger.info(`\u001b[32mInlined all of ${href} (${sheet.length} was below the threshold of ${this.options.inlineThreshold})\u001b[39m`);
      link.remove();
      return true;
    }
    return false;
  }
  /**
   * Inline the stylesheets from options.additionalStylesheets (assuming it passes `options.filter`)
   */

  embedAdditionalStylesheet(document) {
    var _this4 = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const styleSheetsIncluded = [];
      const sources = yield Promise.all(_this4.options.additionalStylesheets.map(cssFile => {
        if (styleSheetsIncluded.includes(cssFile)) {
          return;
        }
        styleSheetsIncluded.push(cssFile);
        const style = document.createElement('style');
        style.$$external = true;
        return _this4.getCssAsset(cssFile, style).then(sheet => [sheet, style]);
      }));
      sources.forEach(([sheet, style]) => {
        if (!sheet) return;
        style.textContent = sheet;
        document.head.appendChild(style);
      });
    })();
  }
  /**
   * Inline the target stylesheet referred to by a <link rel="stylesheet"> (assuming it passes `options.filter`)
   */

  embedLinkedStylesheet(link, document) {
    var _this5 = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const href = link.getAttribute('href');
      const media = link.getAttribute('media');
      const preloadMode = _this5.options.preload; // skip filtered resources, or network resources if no filter is provided

      if (_this5.urlFilter ? _this5.urlFilter(href) : !(href || '').match(/\.css$/)) {
        return Promise.resolve();
      } // the reduced critical CSS gets injected into a new <style> tag

      const style = document.createElement('style');
      style.$$external = true;
      const sheet = yield _this5.getCssAsset(href, style);
      if (!sheet) {
        return;
      }
      style.textContent = sheet;
      style.$$name = href;
      style.$$links = [link];
      link.parentNode.insertBefore(style, link);
      if (_this5.checkInlineThreshold(link, style, sheet)) {
        return;
      } // CSS loader is only injected for the first sheet, then this becomes an empty string

      let cssLoaderPreamble = "function $loadcss(u,m,l){(l=document.createElement('link')).rel='stylesheet';l.href=u;document.head.appendChild(l)}";
      const lazy = preloadMode === 'js-lazy';
      if (lazy) {
        cssLoaderPreamble = cssLoaderPreamble.replace('l.href', "l.media='print';l.onload=function(){l.media=m};l.href");
      } // Allow disabling any mutation of the stylesheet link:

      if (preloadMode === false) return;
      let noscriptFallback = false;
      if (preloadMode === 'body') {
        document.body.appendChild(link);
      } else {
        link.setAttribute('rel', 'preload');
        link.setAttribute('as', 'style');
        if (preloadMode === 'js' || preloadMode === 'js-lazy') {
          const script = document.createElement('script');
          const js = `${cssLoaderPreamble}$loadcss(${JSON.stringify(href)}${lazy ? ',' + JSON.stringify(media || 'all') : ''})`; // script.appendChild(document.createTextNode(js));

          script.textContent = js;
          link.parentNode.insertBefore(script, link.nextSibling);
          style.$$links.push(script);
          cssLoaderPreamble = '';
          noscriptFallback = true;
        } else if (preloadMode === 'media') {
          // @see https://github.com/filamentgroup/loadCSS/blob/af1106cfe0bf70147e22185afa7ead96c01dec48/src/loadCSS.js#L26
          link.setAttribute('rel', 'stylesheet');
          link.removeAttribute('as');
          link.setAttribute('media', 'print');
          link.setAttribute('onload', `this.media='${media || 'all'}'`);
          noscriptFallback = true;
        } else if (preloadMode === 'swap-high') {
          // @see http://filamentgroup.github.io/loadCSS/test/new-high.html
          link.setAttribute('rel', 'alternate stylesheet preload');
          link.setAttribute('title', 'styles');
          link.setAttribute('onload', `this.title='';this.rel='stylesheet'`);
          noscriptFallback = true;
        } else if (preloadMode === 'swap') {
          link.setAttribute('onload', "this.rel='stylesheet'");
          noscriptFallback = true;
        } else {
          const bodyLink = document.createElement('link');
          bodyLink.setAttribute('rel', 'stylesheet');
          if (media) bodyLink.setAttribute('media', media);
          bodyLink.setAttribute('href', href);
          document.body.appendChild(bodyLink);
          style.$$links.push(bodyLink);
        }
      }
      if (_this5.options.noscriptFallback !== false && noscriptFallback) {
        const noscript = document.createElement('noscript');
        const noscriptLink = document.createElement('link');
        noscriptLink.setAttribute('rel', 'stylesheet');
        noscriptLink.setAttribute('href', href);
        if (media) noscriptLink.setAttribute('media', media);
        noscript.appendChild(noscriptLink);
        link.parentNode.insertBefore(noscript, link.nextSibling);
        style.$$links.push(noscript);
      }
    })();
  }
  /**
   * Prune the source CSS files
   */

  pruneSource(style, before, sheetInverse) {
    // if external stylesheet would be below minimum size, just inline everything
    const minSize = this.options.minimumExternalSize;
    const name = style.$$name;
    if (minSize && sheetInverse.length < minSize) {
      this.logger.info(`\u001b[32mInlined all of ${name} (non-critical external stylesheet would have been ${sheetInverse.length}b, which was below the threshold of ${minSize})\u001b[39m`);
      style.textContent = before; // remove any associated external resources/loaders:

      if (style.$$links) {
        for (const link of style.$$links) {
          const parent = link.parentNode;
          if (parent) parent.removeChild(link);
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Parse the stylesheet within a <style> element, then reduce it to contain only rules used by the document.
   */

  processStyle(style, document) {
    var _this6 = this;
    return (0,_Users_karthikch_Downloads_fn7_main_ui_app_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (style.$$reduce === false) return;
      const name = style.$$name ? style.$$name.replace(/^\//, '') : 'inline CSS';
      const options = _this6.options; // const document = style.ownerDocument;

      let keyframesMode = options.keyframes || 'critical'; // we also accept a boolean value for options.keyframes

      if (keyframesMode === true) keyframesMode = 'all';
      if (keyframesMode === false) keyframesMode = 'none';
      let sheet = style.textContent; // store a reference to the previous serialized stylesheet for reporting stats

      const before = sheet; // Skip empty stylesheets

      if (!sheet) return;
      const ast = parseStylesheet(sheet);
      const astInverse = options.pruneSource ? parseStylesheet(sheet) : null; // a string to search for font names (very loose)

      let criticalFonts = '';
      const failedSelectors = [];
      const criticalKeyframeNames = []; // Walk all CSS rules, marking unused rules with `.$$remove=true` for removal in the second pass.
      // This first pass is also used to collect font and keyframe usage used in the second pass.

      walkStyleRules(ast, markOnly(rule => {
        if (rule.type === 'rule') {
          // Filter the selector list down to only those match
          rule.filterSelectors(sel => {
            // Strip pseudo-elements and pseudo-classes, since we only care that their associated elements exist.
            // This means any selector for a pseudo-element or having a pseudo-class will be inlined if the rest of the selector matches.
            if (sel === ':root' || sel.match(/^::?(before|after)$/)) {
              return true;
            }
            sel = sel.replace(/(?<!\\)::?[a-z-]+(?![a-z-(])/gi, '').replace(/::?not\(\s*\)/g, '').trim();
            if (!sel) return false;
            try {
              return document.querySelector(sel) != null;
            } catch (e) {
              failedSelectors.push(sel + ' -> ' + e.message);
              return false;
            }
          }); // If there are no matched selectors, remove the rule:

          if (!rule.selector) {
            return false;
          }
          if (rule.nodes) {
            for (let i = 0; i < rule.nodes.length; i++) {
              const decl = rule.nodes[i]; // detect used fonts

              if (decl.prop && decl.prop.match(/\bfont(-family)?\b/i)) {
                criticalFonts += ' ' + decl.value;
              } // detect used keyframes

              if (decl.prop === 'animation' || decl.prop === 'animation-name') {
                // @todo: parse animation declarations and extract only the name. for now we'll do a lazy match.
                const names = decl.value.split(/\s+/);
                for (let j = 0; j < names.length; j++) {
                  const name = names[j].trim();
                  if (name) criticalKeyframeNames.push(name);
                }
              }
            }
          }
        } // keep font rules, they're handled in the second pass:

        if (rule.type === 'atrule' && rule.name === 'font-face') return; // If there are no remaining rules, remove the whole rule:

        const rules = rule.nodes && rule.nodes.filter(rule => !rule.$$remove);
        return !rules || rules.length !== 0;
      }));
      if (failedSelectors.length !== 0) {
        _this6.logger.warn(`${failedSelectors.length} rules skipped due to selector errors:\n  ${failedSelectors.join('\n  ')}`);
      }
      const shouldPreloadFonts = options.fonts === true || options.preloadFonts === true;
      const shouldInlineFonts = options.fonts !== false && options.inlineFonts === true;
      const preloadedFonts = []; // Second pass, using data picked up from the first

      walkStyleRulesWithReverseMirror(ast, astInverse, rule => {
        // remove any rules marked in the first pass
        if (rule.$$remove === true) return false;
        applyMarkedSelectors(rule); // prune @keyframes rules

        if (rule.type === 'atrule' && rule.name === 'keyframes') {
          if (keyframesMode === 'none') return false;
          if (keyframesMode === 'all') return true;
          return criticalKeyframeNames.indexOf(rule.params) !== -1;
        } // prune @font-face rules

        if (rule.type === 'atrule' && rule.name === 'font-face') {
          let family, src;
          for (let i = 0; i < rule.nodes.length; i++) {
            const decl = rule.nodes[i];
            if (decl.prop === 'src') {
              // @todo parse this properly and generate multiple preloads with type="font/woff2" etc
              src = (decl.value.match(/url\s*\(\s*(['"]?)(.+?)\1\s*\)/) || [])[2];
            } else if (decl.prop === 'font-family') {
              family = decl.value;
            }
          }
          if (src && shouldPreloadFonts && preloadedFonts.indexOf(src) === -1) {
            preloadedFonts.push(src);
            const preload = document.createElement('link');
            preload.setAttribute('rel', 'preload');
            preload.setAttribute('as', 'font');
            preload.setAttribute('crossorigin', 'anonymous');
            preload.setAttribute('href', src.trim());
            document.head.appendChild(preload);
          } // if we're missing info, if the font is unused, or if critical font inlining is disabled, remove the rule:

          if (!family || !src || criticalFonts.indexOf(family) === -1 || !shouldInlineFonts) {
            return false;
          }
        }
      });
      sheet = serializeStylesheet(ast, {
        compress: _this6.options.compress !== false
      }); // If all rules were removed, get rid of the style element entirely

      if (sheet.trim().length === 0) {
        if (style.parentNode) {
          style.remove();
        }
        return;
      }
      let afterText = '';
      let styleInlinedCompletely = false;
      if (options.pruneSource) {
        const sheetInverse = serializeStylesheet(astInverse, {
          compress: _this6.options.compress !== false
        });
        styleInlinedCompletely = _this6.pruneSource(style, before, sheetInverse);
        if (styleInlinedCompletely) {
          const percent = sheetInverse.length / before.length * 100;
          afterText = `, reducing non-inlined size ${percent | 0}% to ${pretty_bytes__WEBPACK_IMPORTED_MODULE_3__(sheetInverse.length)}`;
        }
      } // replace the inline stylesheet with its critical'd counterpart

      if (!styleInlinedCompletely) {
        style.textContent = sheet;
      } // output stats

      const percent = sheet.length / before.length * 100 | 0;
      _this6.logger.info('\u001b[32mInlined ' + pretty_bytes__WEBPACK_IMPORTED_MODULE_3__(sheet.length) + ' (' + percent + '% of original ' + pretty_bytes__WEBPACK_IMPORTED_MODULE_3__(before.length) + ') of ' + name + afterText + '.\u001b[39m');
    })();
  }
}
/* harmony default export */ __webpack_exports__["default"] = (Critters);

/***/ }),

/***/ 80265:
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AtRule: function() { return /* binding */ AtRule; },
/* harmony export */   Comment: function() { return /* binding */ Comment; },
/* harmony export */   Container: function() { return /* binding */ Container; },
/* harmony export */   CssSyntaxError: function() { return /* binding */ CssSyntaxError; },
/* harmony export */   Declaration: function() { return /* binding */ Declaration; },
/* harmony export */   Document: function() { return /* binding */ Document; },
/* harmony export */   Input: function() { return /* binding */ Input; },
/* harmony export */   Node: function() { return /* binding */ Node; },
/* harmony export */   Processor: function() { return /* binding */ Processor; },
/* harmony export */   Result: function() { return /* binding */ Result; },
/* harmony export */   Root: function() { return /* binding */ Root; },
/* harmony export */   Rule: function() { return /* binding */ Rule; },
/* harmony export */   Warning: function() { return /* binding */ Warning; },
/* harmony export */   atRule: function() { return /* binding */ atRule; },
/* harmony export */   comment: function() { return /* binding */ comment; },
/* harmony export */   decl: function() { return /* binding */ decl; },
/* harmony export */   document: function() { return /* binding */ document; },
/* harmony export */   fromJSON: function() { return /* binding */ fromJSON; },
/* harmony export */   list: function() { return /* binding */ list; },
/* harmony export */   parse: function() { return /* binding */ parse; },
/* harmony export */   plugin: function() { return /* binding */ plugin; },
/* harmony export */   root: function() { return /* binding */ root; },
/* harmony export */   rule: function() { return /* binding */ rule; },
/* harmony export */   stringify: function() { return /* binding */ stringify; }
/* harmony export */ });
/* harmony import */ var _postcss_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./postcss.js */ 34015);

/* harmony default export */ __webpack_exports__["default"] = (_postcss_js__WEBPACK_IMPORTED_MODULE_0__);
const stringify = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.stringify;
const fromJSON = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.fromJSON;
const plugin = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.plugin;
const parse = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.parse;
const list = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.list;
const document = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.document;
const comment = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.comment;
const atRule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.atRule;
const rule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.rule;
const decl = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.decl;
const root = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.root;
const CssSyntaxError = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.CssSyntaxError;
const Declaration = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Declaration;
const Container = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Container;
const Processor = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Processor;
const Document = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Document;
const Comment = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Comment;
const Warning = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Warning;
const AtRule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.AtRule;
const Result = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Result;
const Input = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Input;
const Rule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Rule;
const Root = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Root;
const Node = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Node;

/***/ }),

/***/ 89204:
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _asyncToGenerator; }
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

/***/ }),

/***/ 2559:
/*!****************************************************!*\
  !*** ./node_modules/entities/lib/maps/decode.json ***!
  \****************************************************/
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');

/***/ }),

/***/ 94374:
/*!******************************************************!*\
  !*** ./node_modules/entities/lib/maps/entities.json ***!
  \******************************************************/
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Aacute":"Ã","aacute":"Ã¡","Abreve":"Ä‚","abreve":"Äƒ","ac":"âˆ¾","acd":"âˆ¿","acE":"âˆ¾Ì³","Acirc":"Ã‚","acirc":"Ã¢","acute":"Â´","Acy":"Ð","acy":"Ð°","AElig":"Ã†","aelig":"Ã¦","af":"â¡","Afr":"ð”„","afr":"ð”ž","Agrave":"Ã€","agrave":"Ã ","alefsym":"â„µ","aleph":"â„µ","Alpha":"Î‘","alpha":"Î±","Amacr":"Ä€","amacr":"Ä","amalg":"â¨¿","amp":"&","AMP":"&","andand":"â©•","And":"â©“","and":"âˆ§","andd":"â©œ","andslope":"â©˜","andv":"â©š","ang":"âˆ ","ange":"â¦¤","angle":"âˆ ","angmsdaa":"â¦¨","angmsdab":"â¦©","angmsdac":"â¦ª","angmsdad":"â¦«","angmsdae":"â¦¬","angmsdaf":"â¦­","angmsdag":"â¦®","angmsdah":"â¦¯","angmsd":"âˆ¡","angrt":"âˆŸ","angrtvb":"âŠ¾","angrtvbd":"â¦","angsph":"âˆ¢","angst":"Ã…","angzarr":"â¼","Aogon":"Ä„","aogon":"Ä…","Aopf":"ð”¸","aopf":"ð•’","apacir":"â©¯","ap":"â‰ˆ","apE":"â©°","ape":"â‰Š","apid":"â‰‹","apos":"\'","ApplyFunction":"â¡","approx":"â‰ˆ","approxeq":"â‰Š","Aring":"Ã…","aring":"Ã¥","Ascr":"ð’œ","ascr":"ð’¶","Assign":"â‰”","ast":"*","asymp":"â‰ˆ","asympeq":"â‰","Atilde":"Ãƒ","atilde":"Ã£","Auml":"Ã„","auml":"Ã¤","awconint":"âˆ³","awint":"â¨‘","backcong":"â‰Œ","backepsilon":"Ï¶","backprime":"â€µ","backsim":"âˆ½","backsimeq":"â‹","Backslash":"âˆ–","Barv":"â«§","barvee":"âŠ½","barwed":"âŒ…","Barwed":"âŒ†","barwedge":"âŒ…","bbrk":"âŽµ","bbrktbrk":"âŽ¶","bcong":"â‰Œ","Bcy":"Ð‘","bcy":"Ð±","bdquo":"â€ž","becaus":"âˆµ","because":"âˆµ","Because":"âˆµ","bemptyv":"â¦°","bepsi":"Ï¶","bernou":"â„¬","Bernoullis":"â„¬","Beta":"Î’","beta":"Î²","beth":"â„¶","between":"â‰¬","Bfr":"ð”…","bfr":"ð”Ÿ","bigcap":"â‹‚","bigcirc":"â—¯","bigcup":"â‹ƒ","bigodot":"â¨€","bigoplus":"â¨","bigotimes":"â¨‚","bigsqcup":"â¨†","bigstar":"â˜…","bigtriangledown":"â–½","bigtriangleup":"â–³","biguplus":"â¨„","bigvee":"â‹","bigwedge":"â‹€","bkarow":"â¤","blacklozenge":"â§«","blacksquare":"â–ª","blacktriangle":"â–´","blacktriangledown":"â–¾","blacktriangleleft":"â—‚","blacktriangleright":"â–¸","blank":"â£","blk12":"â–’","blk14":"â–‘","blk34":"â–“","block":"â–ˆ","bne":"=âƒ¥","bnequiv":"â‰¡âƒ¥","bNot":"â«­","bnot":"âŒ","Bopf":"ð”¹","bopf":"ð•“","bot":"âŠ¥","bottom":"âŠ¥","bowtie":"â‹ˆ","boxbox":"â§‰","boxdl":"â”","boxdL":"â••","boxDl":"â•–","boxDL":"â•—","boxdr":"â”Œ","boxdR":"â•’","boxDr":"â•“","boxDR":"â•”","boxh":"â”€","boxH":"â•","boxhd":"â”¬","boxHd":"â•¤","boxhD":"â•¥","boxHD":"â•¦","boxhu":"â”´","boxHu":"â•§","boxhU":"â•¨","boxHU":"â•©","boxminus":"âŠŸ","boxplus":"âŠž","boxtimes":"âŠ ","boxul":"â”˜","boxuL":"â•›","boxUl":"â•œ","boxUL":"â•","boxur":"â””","boxuR":"â•˜","boxUr":"â•™","boxUR":"â•š","boxv":"â”‚","boxV":"â•‘","boxvh":"â”¼","boxvH":"â•ª","boxVh":"â•«","boxVH":"â•¬","boxvl":"â”¤","boxvL":"â•¡","boxVl":"â•¢","boxVL":"â•£","boxvr":"â”œ","boxvR":"â•ž","boxVr":"â•Ÿ","boxVR":"â• ","bprime":"â€µ","breve":"Ë˜","Breve":"Ë˜","brvbar":"Â¦","bscr":"ð’·","Bscr":"â„¬","bsemi":"â","bsim":"âˆ½","bsime":"â‹","bsolb":"â§…","bsol":"\\\\","bsolhsub":"âŸˆ","bull":"â€¢","bullet":"â€¢","bump":"â‰Ž","bumpE":"âª®","bumpe":"â‰","Bumpeq":"â‰Ž","bumpeq":"â‰","Cacute":"Ä†","cacute":"Ä‡","capand":"â©„","capbrcup":"â©‰","capcap":"â©‹","cap":"âˆ©","Cap":"â‹’","capcup":"â©‡","capdot":"â©€","CapitalDifferentialD":"â……","caps":"âˆ©ï¸€","caret":"â","caron":"Ë‡","Cayleys":"â„­","ccaps":"â©","Ccaron":"ÄŒ","ccaron":"Ä","Ccedil":"Ã‡","ccedil":"Ã§","Ccirc":"Äˆ","ccirc":"Ä‰","Cconint":"âˆ°","ccups":"â©Œ","ccupssm":"â©","Cdot":"ÄŠ","cdot":"Ä‹","cedil":"Â¸","Cedilla":"Â¸","cemptyv":"â¦²","cent":"Â¢","centerdot":"Â·","CenterDot":"Â·","cfr":"ð” ","Cfr":"â„­","CHcy":"Ð§","chcy":"Ñ‡","check":"âœ“","checkmark":"âœ“","Chi":"Î§","chi":"Ï‡","circ":"Ë†","circeq":"â‰—","circlearrowleft":"â†º","circlearrowright":"â†»","circledast":"âŠ›","circledcirc":"âŠš","circleddash":"âŠ","CircleDot":"âŠ™","circledR":"Â®","circledS":"â“ˆ","CircleMinus":"âŠ–","CirclePlus":"âŠ•","CircleTimes":"âŠ—","cir":"â—‹","cirE":"â§ƒ","cire":"â‰—","cirfnint":"â¨","cirmid":"â«¯","cirscir":"â§‚","ClockwiseContourIntegral":"âˆ²","CloseCurlyDoubleQuote":"â€","CloseCurlyQuote":"â€™","clubs":"â™£","clubsuit":"â™£","colon":":","Colon":"âˆ·","Colone":"â©´","colone":"â‰”","coloneq":"â‰”","comma":",","commat":"@","comp":"âˆ","compfn":"âˆ˜","complement":"âˆ","complexes":"â„‚","cong":"â‰…","congdot":"â©­","Congruent":"â‰¡","conint":"âˆ®","Conint":"âˆ¯","ContourIntegral":"âˆ®","copf":"ð•”","Copf":"â„‚","coprod":"âˆ","Coproduct":"âˆ","copy":"Â©","COPY":"Â©","copysr":"â„—","CounterClockwiseContourIntegral":"âˆ³","crarr":"â†µ","cross":"âœ—","Cross":"â¨¯","Cscr":"ð’ž","cscr":"ð’¸","csub":"â«","csube":"â«‘","csup":"â«","csupe":"â«’","ctdot":"â‹¯","cudarrl":"â¤¸","cudarrr":"â¤µ","cuepr":"â‹ž","cuesc":"â‹Ÿ","cularr":"â†¶","cularrp":"â¤½","cupbrcap":"â©ˆ","cupcap":"â©†","CupCap":"â‰","cup":"âˆª","Cup":"â‹“","cupcup":"â©Š","cupdot":"âŠ","cupor":"â©…","cups":"âˆªï¸€","curarr":"â†·","curarrm":"â¤¼","curlyeqprec":"â‹ž","curlyeqsucc":"â‹Ÿ","curlyvee":"â‹Ž","curlywedge":"â‹","curren":"Â¤","curvearrowleft":"â†¶","curvearrowright":"â†·","cuvee":"â‹Ž","cuwed":"â‹","cwconint":"âˆ²","cwint":"âˆ±","cylcty":"âŒ­","dagger":"â€ ","Dagger":"â€¡","daleth":"â„¸","darr":"â†“","Darr":"â†¡","dArr":"â‡“","dash":"â€","Dashv":"â«¤","dashv":"âŠ£","dbkarow":"â¤","dblac":"Ë","Dcaron":"ÄŽ","dcaron":"Ä","Dcy":"Ð”","dcy":"Ð´","ddagger":"â€¡","ddarr":"â‡Š","DD":"â……","dd":"â…†","DDotrahd":"â¤‘","ddotseq":"â©·","deg":"Â°","Del":"âˆ‡","Delta":"Î”","delta":"Î´","demptyv":"â¦±","dfisht":"â¥¿","Dfr":"ð”‡","dfr":"ð”¡","dHar":"â¥¥","dharl":"â‡ƒ","dharr":"â‡‚","DiacriticalAcute":"Â´","DiacriticalDot":"Ë™","DiacriticalDoubleAcute":"Ë","DiacriticalGrave":"`","DiacriticalTilde":"Ëœ","diam":"â‹„","diamond":"â‹„","Diamond":"â‹„","diamondsuit":"â™¦","diams":"â™¦","die":"Â¨","DifferentialD":"â…†","digamma":"Ï","disin":"â‹²","div":"Ã·","divide":"Ã·","divideontimes":"â‹‡","divonx":"â‹‡","DJcy":"Ð‚","djcy":"Ñ’","dlcorn":"âŒž","dlcrop":"âŒ","dollar":"$","Dopf":"ð”»","dopf":"ð••","Dot":"Â¨","dot":"Ë™","DotDot":"âƒœ","doteq":"â‰","doteqdot":"â‰‘","DotEqual":"â‰","dotminus":"âˆ¸","dotplus":"âˆ”","dotsquare":"âŠ¡","doublebarwedge":"âŒ†","DoubleContourIntegral":"âˆ¯","DoubleDot":"Â¨","DoubleDownArrow":"â‡“","DoubleLeftArrow":"â‡","DoubleLeftRightArrow":"â‡”","DoubleLeftTee":"â«¤","DoubleLongLeftArrow":"âŸ¸","DoubleLongLeftRightArrow":"âŸº","DoubleLongRightArrow":"âŸ¹","DoubleRightArrow":"â‡’","DoubleRightTee":"âŠ¨","DoubleUpArrow":"â‡‘","DoubleUpDownArrow":"â‡•","DoubleVerticalBar":"âˆ¥","DownArrowBar":"â¤“","downarrow":"â†“","DownArrow":"â†“","Downarrow":"â‡“","DownArrowUpArrow":"â‡µ","DownBreve":"Ì‘","downdownarrows":"â‡Š","downharpoonleft":"â‡ƒ","downharpoonright":"â‡‚","DownLeftRightVector":"â¥","DownLeftTeeVector":"â¥ž","DownLeftVectorBar":"â¥–","DownLeftVector":"â†½","DownRightTeeVector":"â¥Ÿ","DownRightVectorBar":"â¥—","DownRightVector":"â‡","DownTeeArrow":"â†§","DownTee":"âŠ¤","drbkarow":"â¤","drcorn":"âŒŸ","drcrop":"âŒŒ","Dscr":"ð’Ÿ","dscr":"ð’¹","DScy":"Ð…","dscy":"Ñ•","dsol":"â§¶","Dstrok":"Ä","dstrok":"Ä‘","dtdot":"â‹±","dtri":"â–¿","dtrif":"â–¾","duarr":"â‡µ","duhar":"â¥¯","dwangle":"â¦¦","DZcy":"Ð","dzcy":"ÑŸ","dzigrarr":"âŸ¿","Eacute":"Ã‰","eacute":"Ã©","easter":"â©®","Ecaron":"Äš","ecaron":"Ä›","Ecirc":"ÃŠ","ecirc":"Ãª","ecir":"â‰–","ecolon":"â‰•","Ecy":"Ð­","ecy":"Ñ","eDDot":"â©·","Edot":"Ä–","edot":"Ä—","eDot":"â‰‘","ee":"â…‡","efDot":"â‰’","Efr":"ð”ˆ","efr":"ð”¢","eg":"âªš","Egrave":"Ãˆ","egrave":"Ã¨","egs":"âª–","egsdot":"âª˜","el":"âª™","Element":"âˆˆ","elinters":"â§","ell":"â„“","els":"âª•","elsdot":"âª—","Emacr":"Ä’","emacr":"Ä“","empty":"âˆ…","emptyset":"âˆ…","EmptySmallSquare":"â—»","emptyv":"âˆ…","EmptyVerySmallSquare":"â–«","emsp13":"â€„","emsp14":"â€…","emsp":"â€ƒ","ENG":"ÅŠ","eng":"Å‹","ensp":"â€‚","Eogon":"Ä˜","eogon":"Ä™","Eopf":"ð”¼","eopf":"ð•–","epar":"â‹•","eparsl":"â§£","eplus":"â©±","epsi":"Îµ","Epsilon":"Î•","epsilon":"Îµ","epsiv":"Ïµ","eqcirc":"â‰–","eqcolon":"â‰•","eqsim":"â‰‚","eqslantgtr":"âª–","eqslantless":"âª•","Equal":"â©µ","equals":"=","EqualTilde":"â‰‚","equest":"â‰Ÿ","Equilibrium":"â‡Œ","equiv":"â‰¡","equivDD":"â©¸","eqvparsl":"â§¥","erarr":"â¥±","erDot":"â‰“","escr":"â„¯","Escr":"â„°","esdot":"â‰","Esim":"â©³","esim":"â‰‚","Eta":"Î—","eta":"Î·","ETH":"Ã","eth":"Ã°","Euml":"Ã‹","euml":"Ã«","euro":"â‚¬","excl":"!","exist":"âˆƒ","Exists":"âˆƒ","expectation":"â„°","exponentiale":"â…‡","ExponentialE":"â…‡","fallingdotseq":"â‰’","Fcy":"Ð¤","fcy":"Ñ„","female":"â™€","ffilig":"ï¬ƒ","fflig":"ï¬€","ffllig":"ï¬„","Ffr":"ð”‰","ffr":"ð”£","filig":"ï¬","FilledSmallSquare":"â—¼","FilledVerySmallSquare":"â–ª","fjlig":"fj","flat":"â™­","fllig":"ï¬‚","fltns":"â–±","fnof":"Æ’","Fopf":"ð”½","fopf":"ð•—","forall":"âˆ€","ForAll":"âˆ€","fork":"â‹”","forkv":"â«™","Fouriertrf":"â„±","fpartint":"â¨","frac12":"Â½","frac13":"â…“","frac14":"Â¼","frac15":"â…•","frac16":"â…™","frac18":"â…›","frac23":"â…”","frac25":"â…–","frac34":"Â¾","frac35":"â…—","frac38":"â…œ","frac45":"â…˜","frac56":"â…š","frac58":"â…","frac78":"â…ž","frasl":"â„","frown":"âŒ¢","fscr":"ð’»","Fscr":"â„±","gacute":"Çµ","Gamma":"Î“","gamma":"Î³","Gammad":"Ïœ","gammad":"Ï","gap":"âª†","Gbreve":"Äž","gbreve":"ÄŸ","Gcedil":"Ä¢","Gcirc":"Äœ","gcirc":"Ä","Gcy":"Ð“","gcy":"Ð³","Gdot":"Ä ","gdot":"Ä¡","ge":"â‰¥","gE":"â‰§","gEl":"âªŒ","gel":"â‹›","geq":"â‰¥","geqq":"â‰§","geqslant":"â©¾","gescc":"âª©","ges":"â©¾","gesdot":"âª€","gesdoto":"âª‚","gesdotol":"âª„","gesl":"â‹›ï¸€","gesles":"âª”","Gfr":"ð”Š","gfr":"ð”¤","gg":"â‰«","Gg":"â‹™","ggg":"â‹™","gimel":"â„·","GJcy":"Ðƒ","gjcy":"Ñ“","gla":"âª¥","gl":"â‰·","glE":"âª’","glj":"âª¤","gnap":"âªŠ","gnapprox":"âªŠ","gne":"âªˆ","gnE":"â‰©","gneq":"âªˆ","gneqq":"â‰©","gnsim":"â‹§","Gopf":"ð”¾","gopf":"ð•˜","grave":"`","GreaterEqual":"â‰¥","GreaterEqualLess":"â‹›","GreaterFullEqual":"â‰§","GreaterGreater":"âª¢","GreaterLess":"â‰·","GreaterSlantEqual":"â©¾","GreaterTilde":"â‰³","Gscr":"ð’¢","gscr":"â„Š","gsim":"â‰³","gsime":"âªŽ","gsiml":"âª","gtcc":"âª§","gtcir":"â©º","gt":">","GT":">","Gt":"â‰«","gtdot":"â‹—","gtlPar":"â¦•","gtquest":"â©¼","gtrapprox":"âª†","gtrarr":"â¥¸","gtrdot":"â‹—","gtreqless":"â‹›","gtreqqless":"âªŒ","gtrless":"â‰·","gtrsim":"â‰³","gvertneqq":"â‰©ï¸€","gvnE":"â‰©ï¸€","Hacek":"Ë‡","hairsp":"â€Š","half":"Â½","hamilt":"â„‹","HARDcy":"Ðª","hardcy":"ÑŠ","harrcir":"â¥ˆ","harr":"â†”","hArr":"â‡”","harrw":"â†­","Hat":"^","hbar":"â„","Hcirc":"Ä¤","hcirc":"Ä¥","hearts":"â™¥","heartsuit":"â™¥","hellip":"â€¦","hercon":"âŠ¹","hfr":"ð”¥","Hfr":"â„Œ","HilbertSpace":"â„‹","hksearow":"â¤¥","hkswarow":"â¤¦","hoarr":"â‡¿","homtht":"âˆ»","hookleftarrow":"â†©","hookrightarrow":"â†ª","hopf":"ð•™","Hopf":"â„","horbar":"â€•","HorizontalLine":"â”€","hscr":"ð’½","Hscr":"â„‹","hslash":"â„","Hstrok":"Ä¦","hstrok":"Ä§","HumpDownHump":"â‰Ž","HumpEqual":"â‰","hybull":"âƒ","hyphen":"â€","Iacute":"Ã","iacute":"Ã­","ic":"â£","Icirc":"ÃŽ","icirc":"Ã®","Icy":"Ð˜","icy":"Ð¸","Idot":"Ä°","IEcy":"Ð•","iecy":"Ðµ","iexcl":"Â¡","iff":"â‡”","ifr":"ð”¦","Ifr":"â„‘","Igrave":"ÃŒ","igrave":"Ã¬","ii":"â…ˆ","iiiint":"â¨Œ","iiint":"âˆ­","iinfin":"â§œ","iiota":"â„©","IJlig":"Ä²","ijlig":"Ä³","Imacr":"Äª","imacr":"Ä«","image":"â„‘","ImaginaryI":"â…ˆ","imagline":"â„","imagpart":"â„‘","imath":"Ä±","Im":"â„‘","imof":"âŠ·","imped":"Æµ","Implies":"â‡’","incare":"â„…","in":"âˆˆ","infin":"âˆž","infintie":"â§","inodot":"Ä±","intcal":"âŠº","int":"âˆ«","Int":"âˆ¬","integers":"â„¤","Integral":"âˆ«","intercal":"âŠº","Intersection":"â‹‚","intlarhk":"â¨—","intprod":"â¨¼","InvisibleComma":"â£","InvisibleTimes":"â¢","IOcy":"Ð","iocy":"Ñ‘","Iogon":"Ä®","iogon":"Ä¯","Iopf":"ð•€","iopf":"ð•š","Iota":"Î™","iota":"Î¹","iprod":"â¨¼","iquest":"Â¿","iscr":"ð’¾","Iscr":"â„","isin":"âˆˆ","isindot":"â‹µ","isinE":"â‹¹","isins":"â‹´","isinsv":"â‹³","isinv":"âˆˆ","it":"â¢","Itilde":"Ä¨","itilde":"Ä©","Iukcy":"Ð†","iukcy":"Ñ–","Iuml":"Ã","iuml":"Ã¯","Jcirc":"Ä´","jcirc":"Äµ","Jcy":"Ð™","jcy":"Ð¹","Jfr":"ð”","jfr":"ð”§","jmath":"È·","Jopf":"ð•","jopf":"ð•›","Jscr":"ð’¥","jscr":"ð’¿","Jsercy":"Ðˆ","jsercy":"Ñ˜","Jukcy":"Ð„","jukcy":"Ñ”","Kappa":"Îš","kappa":"Îº","kappav":"Ï°","Kcedil":"Ä¶","kcedil":"Ä·","Kcy":"Ðš","kcy":"Ðº","Kfr":"ð”Ž","kfr":"ð”¨","kgreen":"Ä¸","KHcy":"Ð¥","khcy":"Ñ…","KJcy":"ÐŒ","kjcy":"Ñœ","Kopf":"ð•‚","kopf":"ð•œ","Kscr":"ð’¦","kscr":"ð“€","lAarr":"â‡š","Lacute":"Ä¹","lacute":"Äº","laemptyv":"â¦´","lagran":"â„’","Lambda":"Î›","lambda":"Î»","lang":"âŸ¨","Lang":"âŸª","langd":"â¦‘","langle":"âŸ¨","lap":"âª…","Laplacetrf":"â„’","laquo":"Â«","larrb":"â‡¤","larrbfs":"â¤Ÿ","larr":"â†","Larr":"â†ž","lArr":"â‡","larrfs":"â¤","larrhk":"â†©","larrlp":"â†«","larrpl":"â¤¹","larrsim":"â¥³","larrtl":"â†¢","latail":"â¤™","lAtail":"â¤›","lat":"âª«","late":"âª­","lates":"âª­ï¸€","lbarr":"â¤Œ","lBarr":"â¤Ž","lbbrk":"â²","lbrace":"{","lbrack":"[","lbrke":"â¦‹","lbrksld":"â¦","lbrkslu":"â¦","Lcaron":"Ä½","lcaron":"Ä¾","Lcedil":"Ä»","lcedil":"Ä¼","lceil":"âŒˆ","lcub":"{","Lcy":"Ð›","lcy":"Ð»","ldca":"â¤¶","ldquo":"â€œ","ldquor":"â€ž","ldrdhar":"â¥§","ldrushar":"â¥‹","ldsh":"â†²","le":"â‰¤","lE":"â‰¦","LeftAngleBracket":"âŸ¨","LeftArrowBar":"â‡¤","leftarrow":"â†","LeftArrow":"â†","Leftarrow":"â‡","LeftArrowRightArrow":"â‡†","leftarrowtail":"â†¢","LeftCeiling":"âŒˆ","LeftDoubleBracket":"âŸ¦","LeftDownTeeVector":"â¥¡","LeftDownVectorBar":"â¥™","LeftDownVector":"â‡ƒ","LeftFloor":"âŒŠ","leftharpoondown":"â†½","leftharpoonup":"â†¼","leftleftarrows":"â‡‡","leftrightarrow":"â†”","LeftRightArrow":"â†”","Leftrightarrow":"â‡”","leftrightarrows":"â‡†","leftrightharpoons":"â‡‹","leftrightsquigarrow":"â†­","LeftRightVector":"â¥Ž","LeftTeeArrow":"â†¤","LeftTee":"âŠ£","LeftTeeVector":"â¥š","leftthreetimes":"â‹‹","LeftTriangleBar":"â§","LeftTriangle":"âŠ²","LeftTriangleEqual":"âŠ´","LeftUpDownVector":"â¥‘","LeftUpTeeVector":"â¥ ","LeftUpVectorBar":"â¥˜","LeftUpVector":"â†¿","LeftVectorBar":"â¥’","LeftVector":"â†¼","lEg":"âª‹","leg":"â‹š","leq":"â‰¤","leqq":"â‰¦","leqslant":"â©½","lescc":"âª¨","les":"â©½","lesdot":"â©¿","lesdoto":"âª","lesdotor":"âªƒ","lesg":"â‹šï¸€","lesges":"âª“","lessapprox":"âª…","lessdot":"â‹–","lesseqgtr":"â‹š","lesseqqgtr":"âª‹","LessEqualGreater":"â‹š","LessFullEqual":"â‰¦","LessGreater":"â‰¶","lessgtr":"â‰¶","LessLess":"âª¡","lesssim":"â‰²","LessSlantEqual":"â©½","LessTilde":"â‰²","lfisht":"â¥¼","lfloor":"âŒŠ","Lfr":"ð”","lfr":"ð”©","lg":"â‰¶","lgE":"âª‘","lHar":"â¥¢","lhard":"â†½","lharu":"â†¼","lharul":"â¥ª","lhblk":"â–„","LJcy":"Ð‰","ljcy":"Ñ™","llarr":"â‡‡","ll":"â‰ª","Ll":"â‹˜","llcorner":"âŒž","Lleftarrow":"â‡š","llhard":"â¥«","lltri":"â—º","Lmidot":"Ä¿","lmidot":"Å€","lmoustache":"âŽ°","lmoust":"âŽ°","lnap":"âª‰","lnapprox":"âª‰","lne":"âª‡","lnE":"â‰¨","lneq":"âª‡","lneqq":"â‰¨","lnsim":"â‹¦","loang":"âŸ¬","loarr":"â‡½","lobrk":"âŸ¦","longleftarrow":"âŸµ","LongLeftArrow":"âŸµ","Longleftarrow":"âŸ¸","longleftrightarrow":"âŸ·","LongLeftRightArrow":"âŸ·","Longleftrightarrow":"âŸº","longmapsto":"âŸ¼","longrightarrow":"âŸ¶","LongRightArrow":"âŸ¶","Longrightarrow":"âŸ¹","looparrowleft":"â†«","looparrowright":"â†¬","lopar":"â¦…","Lopf":"ð•ƒ","lopf":"ð•","loplus":"â¨­","lotimes":"â¨´","lowast":"âˆ—","lowbar":"_","LowerLeftArrow":"â†™","LowerRightArrow":"â†˜","loz":"â—Š","lozenge":"â—Š","lozf":"â§«","lpar":"(","lparlt":"â¦“","lrarr":"â‡†","lrcorner":"âŒŸ","lrhar":"â‡‹","lrhard":"â¥­","lrm":"â€Ž","lrtri":"âŠ¿","lsaquo":"â€¹","lscr":"ð“","Lscr":"â„’","lsh":"â†°","Lsh":"â†°","lsim":"â‰²","lsime":"âª","lsimg":"âª","lsqb":"[","lsquo":"â€˜","lsquor":"â€š","Lstrok":"Å","lstrok":"Å‚","ltcc":"âª¦","ltcir":"â©¹","lt":"<","LT":"<","Lt":"â‰ª","ltdot":"â‹–","lthree":"â‹‹","ltimes":"â‹‰","ltlarr":"â¥¶","ltquest":"â©»","ltri":"â—ƒ","ltrie":"âŠ´","ltrif":"â—‚","ltrPar":"â¦–","lurdshar":"â¥Š","luruhar":"â¥¦","lvertneqq":"â‰¨ï¸€","lvnE":"â‰¨ï¸€","macr":"Â¯","male":"â™‚","malt":"âœ ","maltese":"âœ ","Map":"â¤…","map":"â†¦","mapsto":"â†¦","mapstodown":"â†§","mapstoleft":"â†¤","mapstoup":"â†¥","marker":"â–®","mcomma":"â¨©","Mcy":"Ðœ","mcy":"Ð¼","mdash":"â€”","mDDot":"âˆº","measuredangle":"âˆ¡","MediumSpace":"âŸ","Mellintrf":"â„³","Mfr":"ð”","mfr":"ð”ª","mho":"â„§","micro":"Âµ","midast":"*","midcir":"â«°","mid":"âˆ£","middot":"Â·","minusb":"âŠŸ","minus":"âˆ’","minusd":"âˆ¸","minusdu":"â¨ª","MinusPlus":"âˆ“","mlcp":"â«›","mldr":"â€¦","mnplus":"âˆ“","models":"âŠ§","Mopf":"ð•„","mopf":"ð•ž","mp":"âˆ“","mscr":"ð“‚","Mscr":"â„³","mstpos":"âˆ¾","Mu":"Îœ","mu":"Î¼","multimap":"âŠ¸","mumap":"âŠ¸","nabla":"âˆ‡","Nacute":"Åƒ","nacute":"Å„","nang":"âˆ âƒ’","nap":"â‰‰","napE":"â©°Ì¸","napid":"â‰‹Ì¸","napos":"Å‰","napprox":"â‰‰","natural":"â™®","naturals":"â„•","natur":"â™®","nbsp":"Â ","nbump":"â‰ŽÌ¸","nbumpe":"â‰Ì¸","ncap":"â©ƒ","Ncaron":"Å‡","ncaron":"Åˆ","Ncedil":"Å…","ncedil":"Å†","ncong":"â‰‡","ncongdot":"â©­Ì¸","ncup":"â©‚","Ncy":"Ð","ncy":"Ð½","ndash":"â€“","nearhk":"â¤¤","nearr":"â†—","neArr":"â‡—","nearrow":"â†—","ne":"â‰ ","nedot":"â‰Ì¸","NegativeMediumSpace":"â€‹","NegativeThickSpace":"â€‹","NegativeThinSpace":"â€‹","NegativeVeryThinSpace":"â€‹","nequiv":"â‰¢","nesear":"â¤¨","nesim":"â‰‚Ì¸","NestedGreaterGreater":"â‰«","NestedLessLess":"â‰ª","NewLine":"\\n","nexist":"âˆ„","nexists":"âˆ„","Nfr":"ð”‘","nfr":"ð”«","ngE":"â‰§Ì¸","nge":"â‰±","ngeq":"â‰±","ngeqq":"â‰§Ì¸","ngeqslant":"â©¾Ì¸","nges":"â©¾Ì¸","nGg":"â‹™Ì¸","ngsim":"â‰µ","nGt":"â‰«âƒ’","ngt":"â‰¯","ngtr":"â‰¯","nGtv":"â‰«Ì¸","nharr":"â†®","nhArr":"â‡Ž","nhpar":"â«²","ni":"âˆ‹","nis":"â‹¼","nisd":"â‹º","niv":"âˆ‹","NJcy":"ÐŠ","njcy":"Ñš","nlarr":"â†š","nlArr":"â‡","nldr":"â€¥","nlE":"â‰¦Ì¸","nle":"â‰°","nleftarrow":"â†š","nLeftarrow":"â‡","nleftrightarrow":"â†®","nLeftrightarrow":"â‡Ž","nleq":"â‰°","nleqq":"â‰¦Ì¸","nleqslant":"â©½Ì¸","nles":"â©½Ì¸","nless":"â‰®","nLl":"â‹˜Ì¸","nlsim":"â‰´","nLt":"â‰ªâƒ’","nlt":"â‰®","nltri":"â‹ª","nltrie":"â‹¬","nLtv":"â‰ªÌ¸","nmid":"âˆ¤","NoBreak":"â ","NonBreakingSpace":"Â ","nopf":"ð•Ÿ","Nopf":"â„•","Not":"â«¬","not":"Â¬","NotCongruent":"â‰¢","NotCupCap":"â‰­","NotDoubleVerticalBar":"âˆ¦","NotElement":"âˆ‰","NotEqual":"â‰ ","NotEqualTilde":"â‰‚Ì¸","NotExists":"âˆ„","NotGreater":"â‰¯","NotGreaterEqual":"â‰±","NotGreaterFullEqual":"â‰§Ì¸","NotGreaterGreater":"â‰«Ì¸","NotGreaterLess":"â‰¹","NotGreaterSlantEqual":"â©¾Ì¸","NotGreaterTilde":"â‰µ","NotHumpDownHump":"â‰ŽÌ¸","NotHumpEqual":"â‰Ì¸","notin":"âˆ‰","notindot":"â‹µÌ¸","notinE":"â‹¹Ì¸","notinva":"âˆ‰","notinvb":"â‹·","notinvc":"â‹¶","NotLeftTriangleBar":"â§Ì¸","NotLeftTriangle":"â‹ª","NotLeftTriangleEqual":"â‹¬","NotLess":"â‰®","NotLessEqual":"â‰°","NotLessGreater":"â‰¸","NotLessLess":"â‰ªÌ¸","NotLessSlantEqual":"â©½Ì¸","NotLessTilde":"â‰´","NotNestedGreaterGreater":"âª¢Ì¸","NotNestedLessLess":"âª¡Ì¸","notni":"âˆŒ","notniva":"âˆŒ","notnivb":"â‹¾","notnivc":"â‹½","NotPrecedes":"âŠ€","NotPrecedesEqual":"âª¯Ì¸","NotPrecedesSlantEqual":"â‹ ","NotReverseElement":"âˆŒ","NotRightTriangleBar":"â§Ì¸","NotRightTriangle":"â‹«","NotRightTriangleEqual":"â‹­","NotSquareSubset":"âŠÌ¸","NotSquareSubsetEqual":"â‹¢","NotSquareSuperset":"âŠÌ¸","NotSquareSupersetEqual":"â‹£","NotSubset":"âŠ‚âƒ’","NotSubsetEqual":"âŠˆ","NotSucceeds":"âŠ","NotSucceedsEqual":"âª°Ì¸","NotSucceedsSlantEqual":"â‹¡","NotSucceedsTilde":"â‰¿Ì¸","NotSuperset":"âŠƒâƒ’","NotSupersetEqual":"âŠ‰","NotTilde":"â‰","NotTildeEqual":"â‰„","NotTildeFullEqual":"â‰‡","NotTildeTilde":"â‰‰","NotVerticalBar":"âˆ¤","nparallel":"âˆ¦","npar":"âˆ¦","nparsl":"â«½âƒ¥","npart":"âˆ‚Ì¸","npolint":"â¨”","npr":"âŠ€","nprcue":"â‹ ","nprec":"âŠ€","npreceq":"âª¯Ì¸","npre":"âª¯Ì¸","nrarrc":"â¤³Ì¸","nrarr":"â†›","nrArr":"â‡","nrarrw":"â†Ì¸","nrightarrow":"â†›","nRightarrow":"â‡","nrtri":"â‹«","nrtrie":"â‹­","nsc":"âŠ","nsccue":"â‹¡","nsce":"âª°Ì¸","Nscr":"ð’©","nscr":"ð“ƒ","nshortmid":"âˆ¤","nshortparallel":"âˆ¦","nsim":"â‰","nsime":"â‰„","nsimeq":"â‰„","nsmid":"âˆ¤","nspar":"âˆ¦","nsqsube":"â‹¢","nsqsupe":"â‹£","nsub":"âŠ„","nsubE":"â«…Ì¸","nsube":"âŠˆ","nsubset":"âŠ‚âƒ’","nsubseteq":"âŠˆ","nsubseteqq":"â«…Ì¸","nsucc":"âŠ","nsucceq":"âª°Ì¸","nsup":"âŠ…","nsupE":"â«†Ì¸","nsupe":"âŠ‰","nsupset":"âŠƒâƒ’","nsupseteq":"âŠ‰","nsupseteqq":"â«†Ì¸","ntgl":"â‰¹","Ntilde":"Ã‘","ntilde":"Ã±","ntlg":"â‰¸","ntriangleleft":"â‹ª","ntrianglelefteq":"â‹¬","ntriangleright":"â‹«","ntrianglerighteq":"â‹­","Nu":"Î","nu":"Î½","num":"#","numero":"â„–","numsp":"â€‡","nvap":"â‰âƒ’","nvdash":"âŠ¬","nvDash":"âŠ­","nVdash":"âŠ®","nVDash":"âŠ¯","nvge":"â‰¥âƒ’","nvgt":">âƒ’","nvHarr":"â¤„","nvinfin":"â§ž","nvlArr":"â¤‚","nvle":"â‰¤âƒ’","nvlt":"<âƒ’","nvltrie":"âŠ´âƒ’","nvrArr":"â¤ƒ","nvrtrie":"âŠµâƒ’","nvsim":"âˆ¼âƒ’","nwarhk":"â¤£","nwarr":"â†–","nwArr":"â‡–","nwarrow":"â†–","nwnear":"â¤§","Oacute":"Ã“","oacute":"Ã³","oast":"âŠ›","Ocirc":"Ã”","ocirc":"Ã´","ocir":"âŠš","Ocy":"Ðž","ocy":"Ð¾","odash":"âŠ","Odblac":"Å","odblac":"Å‘","odiv":"â¨¸","odot":"âŠ™","odsold":"â¦¼","OElig":"Å’","oelig":"Å“","ofcir":"â¦¿","Ofr":"ð”’","ofr":"ð”¬","ogon":"Ë›","Ograve":"Ã’","ograve":"Ã²","ogt":"â§","ohbar":"â¦µ","ohm":"Î©","oint":"âˆ®","olarr":"â†º","olcir":"â¦¾","olcross":"â¦»","oline":"â€¾","olt":"â§€","Omacr":"ÅŒ","omacr":"Å","Omega":"Î©","omega":"Ï‰","Omicron":"ÎŸ","omicron":"Î¿","omid":"â¦¶","ominus":"âŠ–","Oopf":"ð•†","oopf":"ð• ","opar":"â¦·","OpenCurlyDoubleQuote":"â€œ","OpenCurlyQuote":"â€˜","operp":"â¦¹","oplus":"âŠ•","orarr":"â†»","Or":"â©”","or":"âˆ¨","ord":"â©","order":"â„´","orderof":"â„´","ordf":"Âª","ordm":"Âº","origof":"âŠ¶","oror":"â©–","orslope":"â©—","orv":"â©›","oS":"â“ˆ","Oscr":"ð’ª","oscr":"â„´","Oslash":"Ã˜","oslash":"Ã¸","osol":"âŠ˜","Otilde":"Ã•","otilde":"Ãµ","otimesas":"â¨¶","Otimes":"â¨·","otimes":"âŠ—","Ouml":"Ã–","ouml":"Ã¶","ovbar":"âŒ½","OverBar":"â€¾","OverBrace":"âž","OverBracket":"âŽ´","OverParenthesis":"âœ","para":"Â¶","parallel":"âˆ¥","par":"âˆ¥","parsim":"â«³","parsl":"â«½","part":"âˆ‚","PartialD":"âˆ‚","Pcy":"ÐŸ","pcy":"Ð¿","percnt":"%","period":".","permil":"â€°","perp":"âŠ¥","pertenk":"â€±","Pfr":"ð”“","pfr":"ð”­","Phi":"Î¦","phi":"Ï†","phiv":"Ï•","phmmat":"â„³","phone":"â˜Ž","Pi":"Î ","pi":"Ï€","pitchfork":"â‹”","piv":"Ï–","planck":"â„","planckh":"â„Ž","plankv":"â„","plusacir":"â¨£","plusb":"âŠž","pluscir":"â¨¢","plus":"+","plusdo":"âˆ”","plusdu":"â¨¥","pluse":"â©²","PlusMinus":"Â±","plusmn":"Â±","plussim":"â¨¦","plustwo":"â¨§","pm":"Â±","Poincareplane":"â„Œ","pointint":"â¨•","popf":"ð•¡","Popf":"â„™","pound":"Â£","prap":"âª·","Pr":"âª»","pr":"â‰º","prcue":"â‰¼","precapprox":"âª·","prec":"â‰º","preccurlyeq":"â‰¼","Precedes":"â‰º","PrecedesEqual":"âª¯","PrecedesSlantEqual":"â‰¼","PrecedesTilde":"â‰¾","preceq":"âª¯","precnapprox":"âª¹","precneqq":"âªµ","precnsim":"â‹¨","pre":"âª¯","prE":"âª³","precsim":"â‰¾","prime":"â€²","Prime":"â€³","primes":"â„™","prnap":"âª¹","prnE":"âªµ","prnsim":"â‹¨","prod":"âˆ","Product":"âˆ","profalar":"âŒ®","profline":"âŒ’","profsurf":"âŒ“","prop":"âˆ","Proportional":"âˆ","Proportion":"âˆ·","propto":"âˆ","prsim":"â‰¾","prurel":"âŠ°","Pscr":"ð’«","pscr":"ð“…","Psi":"Î¨","psi":"Ïˆ","puncsp":"â€ˆ","Qfr":"ð””","qfr":"ð”®","qint":"â¨Œ","qopf":"ð•¢","Qopf":"â„š","qprime":"â—","Qscr":"ð’¬","qscr":"ð“†","quaternions":"â„","quatint":"â¨–","quest":"?","questeq":"â‰Ÿ","quot":"\\"","QUOT":"\\"","rAarr":"â‡›","race":"âˆ½Ì±","Racute":"Å”","racute":"Å•","radic":"âˆš","raemptyv":"â¦³","rang":"âŸ©","Rang":"âŸ«","rangd":"â¦’","range":"â¦¥","rangle":"âŸ©","raquo":"Â»","rarrap":"â¥µ","rarrb":"â‡¥","rarrbfs":"â¤ ","rarrc":"â¤³","rarr":"â†’","Rarr":"â† ","rArr":"â‡’","rarrfs":"â¤ž","rarrhk":"â†ª","rarrlp":"â†¬","rarrpl":"â¥…","rarrsim":"â¥´","Rarrtl":"â¤–","rarrtl":"â†£","rarrw":"â†","ratail":"â¤š","rAtail":"â¤œ","ratio":"âˆ¶","rationals":"â„š","rbarr":"â¤","rBarr":"â¤","RBarr":"â¤","rbbrk":"â³","rbrace":"}","rbrack":"]","rbrke":"â¦Œ","rbrksld":"â¦Ž","rbrkslu":"â¦","Rcaron":"Å˜","rcaron":"Å™","Rcedil":"Å–","rcedil":"Å—","rceil":"âŒ‰","rcub":"}","Rcy":"Ð ","rcy":"Ñ€","rdca":"â¤·","rdldhar":"â¥©","rdquo":"â€","rdquor":"â€","rdsh":"â†³","real":"â„œ","realine":"â„›","realpart":"â„œ","reals":"â„","Re":"â„œ","rect":"â–­","reg":"Â®","REG":"Â®","ReverseElement":"âˆ‹","ReverseEquilibrium":"â‡‹","ReverseUpEquilibrium":"â¥¯","rfisht":"â¥½","rfloor":"âŒ‹","rfr":"ð”¯","Rfr":"â„œ","rHar":"â¥¤","rhard":"â‡","rharu":"â‡€","rharul":"â¥¬","Rho":"Î¡","rho":"Ï","rhov":"Ï±","RightAngleBracket":"âŸ©","RightArrowBar":"â‡¥","rightarrow":"â†’","RightArrow":"â†’","Rightarrow":"â‡’","RightArrowLeftArrow":"â‡„","rightarrowtail":"â†£","RightCeiling":"âŒ‰","RightDoubleBracket":"âŸ§","RightDownTeeVector":"â¥","RightDownVectorBar":"â¥•","RightDownVector":"â‡‚","RightFloor":"âŒ‹","rightharpoondown":"â‡","rightharpoonup":"â‡€","rightleftarrows":"â‡„","rightleftharpoons":"â‡Œ","rightrightarrows":"â‡‰","rightsquigarrow":"â†","RightTeeArrow":"â†¦","RightTee":"âŠ¢","RightTeeVector":"â¥›","rightthreetimes":"â‹Œ","RightTriangleBar":"â§","RightTriangle":"âŠ³","RightTriangleEqual":"âŠµ","RightUpDownVector":"â¥","RightUpTeeVector":"â¥œ","RightUpVectorBar":"â¥”","RightUpVector":"â†¾","RightVectorBar":"â¥“","RightVector":"â‡€","ring":"Ëš","risingdotseq":"â‰“","rlarr":"â‡„","rlhar":"â‡Œ","rlm":"â€","rmoustache":"âŽ±","rmoust":"âŽ±","rnmid":"â«®","roang":"âŸ­","roarr":"â‡¾","robrk":"âŸ§","ropar":"â¦†","ropf":"ð•£","Ropf":"â„","roplus":"â¨®","rotimes":"â¨µ","RoundImplies":"â¥°","rpar":")","rpargt":"â¦”","rppolint":"â¨’","rrarr":"â‡‰","Rrightarrow":"â‡›","rsaquo":"â€º","rscr":"ð“‡","Rscr":"â„›","rsh":"â†±","Rsh":"â†±","rsqb":"]","rsquo":"â€™","rsquor":"â€™","rthree":"â‹Œ","rtimes":"â‹Š","rtri":"â–¹","rtrie":"âŠµ","rtrif":"â–¸","rtriltri":"â§Ž","RuleDelayed":"â§´","ruluhar":"â¥¨","rx":"â„ž","Sacute":"Åš","sacute":"Å›","sbquo":"â€š","scap":"âª¸","Scaron":"Å ","scaron":"Å¡","Sc":"âª¼","sc":"â‰»","sccue":"â‰½","sce":"âª°","scE":"âª´","Scedil":"Åž","scedil":"ÅŸ","Scirc":"Åœ","scirc":"Å","scnap":"âªº","scnE":"âª¶","scnsim":"â‹©","scpolint":"â¨“","scsim":"â‰¿","Scy":"Ð¡","scy":"Ñ","sdotb":"âŠ¡","sdot":"â‹…","sdote":"â©¦","searhk":"â¤¥","searr":"â†˜","seArr":"â‡˜","searrow":"â†˜","sect":"Â§","semi":";","seswar":"â¤©","setminus":"âˆ–","setmn":"âˆ–","sext":"âœ¶","Sfr":"ð”–","sfr":"ð”°","sfrown":"âŒ¢","sharp":"â™¯","SHCHcy":"Ð©","shchcy":"Ñ‰","SHcy":"Ð¨","shcy":"Ñˆ","ShortDownArrow":"â†“","ShortLeftArrow":"â†","shortmid":"âˆ£","shortparallel":"âˆ¥","ShortRightArrow":"â†’","ShortUpArrow":"â†‘","shy":"Â­","Sigma":"Î£","sigma":"Ïƒ","sigmaf":"Ï‚","sigmav":"Ï‚","sim":"âˆ¼","simdot":"â©ª","sime":"â‰ƒ","simeq":"â‰ƒ","simg":"âªž","simgE":"âª ","siml":"âª","simlE":"âªŸ","simne":"â‰†","simplus":"â¨¤","simrarr":"â¥²","slarr":"â†","SmallCircle":"âˆ˜","smallsetminus":"âˆ–","smashp":"â¨³","smeparsl":"â§¤","smid":"âˆ£","smile":"âŒ£","smt":"âªª","smte":"âª¬","smtes":"âª¬ï¸€","SOFTcy":"Ð¬","softcy":"ÑŒ","solbar":"âŒ¿","solb":"â§„","sol":"/","Sopf":"ð•Š","sopf":"ð•¤","spades":"â™ ","spadesuit":"â™ ","spar":"âˆ¥","sqcap":"âŠ“","sqcaps":"âŠ“ï¸€","sqcup":"âŠ”","sqcups":"âŠ”ï¸€","Sqrt":"âˆš","sqsub":"âŠ","sqsube":"âŠ‘","sqsubset":"âŠ","sqsubseteq":"âŠ‘","sqsup":"âŠ","sqsupe":"âŠ’","sqsupset":"âŠ","sqsupseteq":"âŠ’","square":"â–¡","Square":"â–¡","SquareIntersection":"âŠ“","SquareSubset":"âŠ","SquareSubsetEqual":"âŠ‘","SquareSuperset":"âŠ","SquareSupersetEqual":"âŠ’","SquareUnion":"âŠ”","squarf":"â–ª","squ":"â–¡","squf":"â–ª","srarr":"â†’","Sscr":"ð’®","sscr":"ð“ˆ","ssetmn":"âˆ–","ssmile":"âŒ£","sstarf":"â‹†","Star":"â‹†","star":"â˜†","starf":"â˜…","straightepsilon":"Ïµ","straightphi":"Ï•","strns":"Â¯","sub":"âŠ‚","Sub":"â‹","subdot":"âª½","subE":"â«…","sube":"âŠ†","subedot":"â«ƒ","submult":"â«","subnE":"â«‹","subne":"âŠŠ","subplus":"âª¿","subrarr":"â¥¹","subset":"âŠ‚","Subset":"â‹","subseteq":"âŠ†","subseteqq":"â«…","SubsetEqual":"âŠ†","subsetneq":"âŠŠ","subsetneqq":"â«‹","subsim":"â«‡","subsub":"â«•","subsup":"â«“","succapprox":"âª¸","succ":"â‰»","succcurlyeq":"â‰½","Succeeds":"â‰»","SucceedsEqual":"âª°","SucceedsSlantEqual":"â‰½","SucceedsTilde":"â‰¿","succeq":"âª°","succnapprox":"âªº","succneqq":"âª¶","succnsim":"â‹©","succsim":"â‰¿","SuchThat":"âˆ‹","sum":"âˆ‘","Sum":"âˆ‘","sung":"â™ª","sup1":"Â¹","sup2":"Â²","sup3":"Â³","sup":"âŠƒ","Sup":"â‹‘","supdot":"âª¾","supdsub":"â«˜","supE":"â«†","supe":"âŠ‡","supedot":"â«„","Superset":"âŠƒ","SupersetEqual":"âŠ‡","suphsol":"âŸ‰","suphsub":"â«—","suplarr":"â¥»","supmult":"â«‚","supnE":"â«Œ","supne":"âŠ‹","supplus":"â«€","supset":"âŠƒ","Supset":"â‹‘","supseteq":"âŠ‡","supseteqq":"â«†","supsetneq":"âŠ‹","supsetneqq":"â«Œ","supsim":"â«ˆ","supsub":"â«”","supsup":"â«–","swarhk":"â¤¦","swarr":"â†™","swArr":"â‡™","swarrow":"â†™","swnwar":"â¤ª","szlig":"ÃŸ","Tab":"\\t","target":"âŒ–","Tau":"Î¤","tau":"Ï„","tbrk":"âŽ´","Tcaron":"Å¤","tcaron":"Å¥","Tcedil":"Å¢","tcedil":"Å£","Tcy":"Ð¢","tcy":"Ñ‚","tdot":"âƒ›","telrec":"âŒ•","Tfr":"ð”—","tfr":"ð”±","there4":"âˆ´","therefore":"âˆ´","Therefore":"âˆ´","Theta":"Î˜","theta":"Î¸","thetasym":"Ï‘","thetav":"Ï‘","thickapprox":"â‰ˆ","thicksim":"âˆ¼","ThickSpace":"âŸâ€Š","ThinSpace":"â€‰","thinsp":"â€‰","thkap":"â‰ˆ","thksim":"âˆ¼","THORN":"Ãž","thorn":"Ã¾","tilde":"Ëœ","Tilde":"âˆ¼","TildeEqual":"â‰ƒ","TildeFullEqual":"â‰…","TildeTilde":"â‰ˆ","timesbar":"â¨±","timesb":"âŠ ","times":"Ã—","timesd":"â¨°","tint":"âˆ­","toea":"â¤¨","topbot":"âŒ¶","topcir":"â«±","top":"âŠ¤","Topf":"ð•‹","topf":"ð•¥","topfork":"â«š","tosa":"â¤©","tprime":"â€´","trade":"â„¢","TRADE":"â„¢","triangle":"â–µ","triangledown":"â–¿","triangleleft":"â—ƒ","trianglelefteq":"âŠ´","triangleq":"â‰œ","triangleright":"â–¹","trianglerighteq":"âŠµ","tridot":"â—¬","trie":"â‰œ","triminus":"â¨º","TripleDot":"âƒ›","triplus":"â¨¹","trisb":"â§","tritime":"â¨»","trpezium":"â¢","Tscr":"ð’¯","tscr":"ð“‰","TScy":"Ð¦","tscy":"Ñ†","TSHcy":"Ð‹","tshcy":"Ñ›","Tstrok":"Å¦","tstrok":"Å§","twixt":"â‰¬","twoheadleftarrow":"â†ž","twoheadrightarrow":"â† ","Uacute":"Ãš","uacute":"Ãº","uarr":"â†‘","Uarr":"â†Ÿ","uArr":"â‡‘","Uarrocir":"â¥‰","Ubrcy":"ÐŽ","ubrcy":"Ñž","Ubreve":"Å¬","ubreve":"Å­","Ucirc":"Ã›","ucirc":"Ã»","Ucy":"Ð£","ucy":"Ñƒ","udarr":"â‡…","Udblac":"Å°","udblac":"Å±","udhar":"â¥®","ufisht":"â¥¾","Ufr":"ð”˜","ufr":"ð”²","Ugrave":"Ã™","ugrave":"Ã¹","uHar":"â¥£","uharl":"â†¿","uharr":"â†¾","uhblk":"â–€","ulcorn":"âŒœ","ulcorner":"âŒœ","ulcrop":"âŒ","ultri":"â—¸","Umacr":"Åª","umacr":"Å«","uml":"Â¨","UnderBar":"_","UnderBrace":"âŸ","UnderBracket":"âŽµ","UnderParenthesis":"â","Union":"â‹ƒ","UnionPlus":"âŠŽ","Uogon":"Å²","uogon":"Å³","Uopf":"ð•Œ","uopf":"ð•¦","UpArrowBar":"â¤’","uparrow":"â†‘","UpArrow":"â†‘","Uparrow":"â‡‘","UpArrowDownArrow":"â‡…","updownarrow":"â†•","UpDownArrow":"â†•","Updownarrow":"â‡•","UpEquilibrium":"â¥®","upharpoonleft":"â†¿","upharpoonright":"â†¾","uplus":"âŠŽ","UpperLeftArrow":"â†–","UpperRightArrow":"â†—","upsi":"Ï…","Upsi":"Ï’","upsih":"Ï’","Upsilon":"Î¥","upsilon":"Ï…","UpTeeArrow":"â†¥","UpTee":"âŠ¥","upuparrows":"â‡ˆ","urcorn":"âŒ","urcorner":"âŒ","urcrop":"âŒŽ","Uring":"Å®","uring":"Å¯","urtri":"â—¹","Uscr":"ð’°","uscr":"ð“Š","utdot":"â‹°","Utilde":"Å¨","utilde":"Å©","utri":"â–µ","utrif":"â–´","uuarr":"â‡ˆ","Uuml":"Ãœ","uuml":"Ã¼","uwangle":"â¦§","vangrt":"â¦œ","varepsilon":"Ïµ","varkappa":"Ï°","varnothing":"âˆ…","varphi":"Ï•","varpi":"Ï–","varpropto":"âˆ","varr":"â†•","vArr":"â‡•","varrho":"Ï±","varsigma":"Ï‚","varsubsetneq":"âŠŠï¸€","varsubsetneqq":"â«‹ï¸€","varsupsetneq":"âŠ‹ï¸€","varsupsetneqq":"â«Œï¸€","vartheta":"Ï‘","vartriangleleft":"âŠ²","vartriangleright":"âŠ³","vBar":"â«¨","Vbar":"â««","vBarv":"â«©","Vcy":"Ð’","vcy":"Ð²","vdash":"âŠ¢","vDash":"âŠ¨","Vdash":"âŠ©","VDash":"âŠ«","Vdashl":"â«¦","veebar":"âŠ»","vee":"âˆ¨","Vee":"â‹","veeeq":"â‰š","vellip":"â‹®","verbar":"|","Verbar":"â€–","vert":"|","Vert":"â€–","VerticalBar":"âˆ£","VerticalLine":"|","VerticalSeparator":"â˜","VerticalTilde":"â‰€","VeryThinSpace":"â€Š","Vfr":"ð”™","vfr":"ð”³","vltri":"âŠ²","vnsub":"âŠ‚âƒ’","vnsup":"âŠƒâƒ’","Vopf":"ð•","vopf":"ð•§","vprop":"âˆ","vrtri":"âŠ³","Vscr":"ð’±","vscr":"ð“‹","vsubnE":"â«‹ï¸€","vsubne":"âŠŠï¸€","vsupnE":"â«Œï¸€","vsupne":"âŠ‹ï¸€","Vvdash":"âŠª","vzigzag":"â¦š","Wcirc":"Å´","wcirc":"Åµ","wedbar":"â©Ÿ","wedge":"âˆ§","Wedge":"â‹€","wedgeq":"â‰™","weierp":"â„˜","Wfr":"ð”š","wfr":"ð”´","Wopf":"ð•Ž","wopf":"ð•¨","wp":"â„˜","wr":"â‰€","wreath":"â‰€","Wscr":"ð’²","wscr":"ð“Œ","xcap":"â‹‚","xcirc":"â—¯","xcup":"â‹ƒ","xdtri":"â–½","Xfr":"ð”›","xfr":"ð”µ","xharr":"âŸ·","xhArr":"âŸº","Xi":"Îž","xi":"Î¾","xlarr":"âŸµ","xlArr":"âŸ¸","xmap":"âŸ¼","xnis":"â‹»","xodot":"â¨€","Xopf":"ð•","xopf":"ð•©","xoplus":"â¨","xotime":"â¨‚","xrarr":"âŸ¶","xrArr":"âŸ¹","Xscr":"ð’³","xscr":"ð“","xsqcup":"â¨†","xuplus":"â¨„","xutri":"â–³","xvee":"â‹","xwedge":"â‹€","Yacute":"Ã","yacute":"Ã½","YAcy":"Ð¯","yacy":"Ñ","Ycirc":"Å¶","ycirc":"Å·","Ycy":"Ð«","ycy":"Ñ‹","yen":"Â¥","Yfr":"ð”œ","yfr":"ð”¶","YIcy":"Ð‡","yicy":"Ñ—","Yopf":"ð•","yopf":"ð•ª","Yscr":"ð’´","yscr":"ð“Ž","YUcy":"Ð®","yucy":"ÑŽ","yuml":"Ã¿","Yuml":"Å¸","Zacute":"Å¹","zacute":"Åº","Zcaron":"Å½","zcaron":"Å¾","Zcy":"Ð—","zcy":"Ð·","Zdot":"Å»","zdot":"Å¼","zeetrf":"â„¨","ZeroWidthSpace":"â€‹","Zeta":"Î–","zeta":"Î¶","zfr":"ð”·","Zfr":"â„¨","ZHcy":"Ð–","zhcy":"Ð¶","zigrarr":"â‡","zopf":"ð•«","Zopf":"â„¤","Zscr":"ð’µ","zscr":"ð“","zwj":"â€","zwnj":"â€Œ"}');

/***/ }),

/***/ 51554:
/*!****************************************************!*\
  !*** ./node_modules/entities/lib/maps/legacy.json ***!
  \****************************************************/
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Aacute":"Ã","aacute":"Ã¡","Acirc":"Ã‚","acirc":"Ã¢","acute":"Â´","AElig":"Ã†","aelig":"Ã¦","Agrave":"Ã€","agrave":"Ã ","amp":"&","AMP":"&","Aring":"Ã…","aring":"Ã¥","Atilde":"Ãƒ","atilde":"Ã£","Auml":"Ã„","auml":"Ã¤","brvbar":"Â¦","Ccedil":"Ã‡","ccedil":"Ã§","cedil":"Â¸","cent":"Â¢","copy":"Â©","COPY":"Â©","curren":"Â¤","deg":"Â°","divide":"Ã·","Eacute":"Ã‰","eacute":"Ã©","Ecirc":"ÃŠ","ecirc":"Ãª","Egrave":"Ãˆ","egrave":"Ã¨","ETH":"Ã","eth":"Ã°","Euml":"Ã‹","euml":"Ã«","frac12":"Â½","frac14":"Â¼","frac34":"Â¾","gt":">","GT":">","Iacute":"Ã","iacute":"Ã­","Icirc":"ÃŽ","icirc":"Ã®","iexcl":"Â¡","Igrave":"ÃŒ","igrave":"Ã¬","iquest":"Â¿","Iuml":"Ã","iuml":"Ã¯","laquo":"Â«","lt":"<","LT":"<","macr":"Â¯","micro":"Âµ","middot":"Â·","nbsp":"Â ","not":"Â¬","Ntilde":"Ã‘","ntilde":"Ã±","Oacute":"Ã“","oacute":"Ã³","Ocirc":"Ã”","ocirc":"Ã´","Ograve":"Ã’","ograve":"Ã²","ordf":"Âª","ordm":"Âº","Oslash":"Ã˜","oslash":"Ã¸","Otilde":"Ã•","otilde":"Ãµ","Ouml":"Ã–","ouml":"Ã¶","para":"Â¶","plusmn":"Â±","pound":"Â£","quot":"\\"","QUOT":"\\"","raquo":"Â»","reg":"Â®","REG":"Â®","sect":"Â§","shy":"Â­","sup1":"Â¹","sup2":"Â²","sup3":"Â³","szlig":"ÃŸ","THORN":"Ãž","thorn":"Ã¾","times":"Ã—","Uacute":"Ãš","uacute":"Ãº","Ucirc":"Ã›","ucirc":"Ã»","Ugrave":"Ã™","ugrave":"Ã¹","uml":"Â¨","Uuml":"Ãœ","uuml":"Ã¼","Yacute":"Ã","yacute":"Ã½","yen":"Â¥","yuml":"Ã¿"}');

/***/ }),

/***/ 57178:
/*!*************************************************!*\
  !*** ./node_modules/entities/lib/maps/xml.json ***!
  \*************************************************/
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""}');

/***/ })

};
;
//# sourceMappingURL=node_modules_nguniversal_express-engine_fesm2020_express-engine_mjs-_5d6c0.js.map